/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var t={651:t=>{t.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAA8SURBVDhP7dEhCgAxDADB+/k9Lh8rDCtq6yo6JrAhKt9s/k2JEjceNGlPiRI3HjRpT4kS7w81SpQ4PJhZxl3jEH3ZDWcAAAAASUVORK5CYII="}},e={};function i(s){var n=e[s];if(void 0!==n)return n.exports;var r=e[s]={exports:{}};return t[s](r,r.exports,i),r.exports}(()=>{const t=100,e=301,s=302,n=306,r=1e3,o=1001,a=1002,l=1003,h=1006,c=1008,m=1009,u=1012,_=1014,d=1015,p=1016,f=1020,y=1023,g=1026,x=1027,v=33776,S=33777,w=33778,b=33779,C=2300,A=2301,B=2302,M=2400,V=2401,T=2402,P=3e3,D=3001,I=7680,E=35044,R=35048,L="300 es",G=1035;class F{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const i=this._listeners[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const i=e.slice(0);for(let e=0,s=i.length;e<s;e++)i[e].call(this,t);t.target=null}}}const k=[];for(let t=0;t<256;t++)k[t]=(t<16?"0":"")+t.toString(16);let z=1234567;const O=Math.PI/180,N=180/Math.PI;function U(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,s=4294967295*Math.random()|0;return(k[255&t]+k[t>>8&255]+k[t>>16&255]+k[t>>24&255]+"-"+k[255&e]+k[e>>8&255]+"-"+k[e>>16&15|64]+k[e>>24&255]+"-"+k[63&i|128]+k[i>>8&255]+"-"+k[i>>16&255]+k[i>>24&255]+k[255&s]+k[s>>8&255]+k[s>>16&255]+k[s>>24&255]).toUpperCase()}function W(t,e,i){return Math.max(e,Math.min(i,t))}function j(t,e){return(t%e+e)%e}function H(t,e,i){return(1-i)*t+i*e}function q(t){return 0==(t&t-1)&&0!==t}function X(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var J=Object.freeze({__proto__:null,DEG2RAD:O,RAD2DEG:N,generateUUID:U,clamp:W,euclideanModulo:j,mapLinear:function(t,e,i,s,n){return s+(t-e)*(n-s)/(i-e)},inverseLerp:function(t,e,i){return t!==e?(i-t)/(e-t):0},lerp:H,damp:function(t,e,i,s){return H(t,e,1-Math.exp(-i*s))},pingpong:function(t,e=1){return e-Math.abs(j(t,2*e)-e)},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(z=t%2147483647),z=16807*z%2147483647,(z-1)/2147483646},degToRad:function(t){return t*O},radToDeg:function(t){return t*N},isPowerOfTwo:q,ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:X,setQuaternionFromProperEuler:function(t,e,i,s,n){const r=Math.cos,o=Math.sin,a=r(i/2),l=o(i/2),h=r((e+s)/2),c=o((e+s)/2),m=r((e-s)/2),u=o((e-s)/2),_=r((s-e)/2),d=o((s-e)/2);switch(n){case"XYX":t.set(a*c,l*m,l*u,a*h);break;case"YZY":t.set(l*u,a*c,l*m,a*h);break;case"ZXZ":t.set(l*m,l*u,a*c,a*h);break;case"XZX":t.set(a*c,l*d,l*_,a*h);break;case"YXY":t.set(l*_,a*c,l*d,a*h);break;case"ZYZ":t.set(l*d,l*_,a*c,a*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}});class Z{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Z.prototype.isVector2=!0;class Y{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,n,r,o,a,l){const h=this.elements;return h[0]=t,h[1]=s,h[2]=o,h[3]=e,h[4]=n,h[5]=a,h[6]=i,h[7]=r,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],o=i[3],a=i[6],l=i[1],h=i[4],c=i[7],m=i[2],u=i[5],_=i[8],d=s[0],p=s[3],f=s[6],y=s[1],g=s[4],x=s[7],v=s[2],S=s[5],w=s[8];return n[0]=r*d+o*y+a*v,n[3]=r*p+o*g+a*S,n[6]=r*f+o*x+a*w,n[1]=l*d+h*y+c*v,n[4]=l*p+h*g+c*S,n[7]=l*f+h*x+c*w,n[2]=m*d+u*y+_*v,n[5]=m*p+u*g+_*S,n[8]=m*f+u*x+_*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],l=t[7],h=t[8];return e*r*h-e*o*l-i*n*h+i*o*a+s*n*l-s*r*a}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],l=t[7],h=t[8],c=h*r-o*l,m=o*a-h*n,u=l*n-r*a,_=e*c+i*m+s*u;if(0===_)return this.set(0,0,0,0,0,0,0,0,0);const d=1/_;return t[0]=c*d,t[1]=(s*l-h*i)*d,t[2]=(o*i-s*r)*d,t[3]=m*d,t[4]=(h*e-s*a)*d,t[5]=(s*n-o*e)*d,t[6]=u*d,t[7]=(i*a-l*e)*d,t[8]=(r*e-i*n)*d,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,o){const a=Math.cos(n),l=Math.sin(n);return this.set(i*a,i*l,-i*(a*r+l*o)+r+t,-s*l,s*a,-s*(-l*r+a*o)+o+e,0,0,1),this}scale(t,e){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.elements,n=s[0],r=s[3],o=s[6],a=s[1],l=s[4],h=s[7];return s[0]=e*n+i*a,s[3]=e*r+i*l,s[6]=e*o+i*h,s[1]=-i*n+e*a,s[4]=-i*r+e*l,s[7]=-i*o+e*h,this}translate(t,e){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<9;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}function Q(t){for(let e=t.length-1;e>=0;--e)if(t[e]>65535)return!0;return!1}function K(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}Y.prototype.isMatrix3=!0,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;const $={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tt={h:0,s:0,l:0},et={h:0,s:0,l:0};function it(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t}function st(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function nt(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class rt{constructor(t,e,i){return void 0===e&&void 0===i?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}setHSL(t,e,i){if(t=j(t,1),e=W(e,0,1),i=W(i,0,1),0===e)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+e):i+e-i*e,n=2*i-s;this.r=it(n,s,t+1/3),this.g=it(n,s,t),this.b=it(n,s,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const s=i[1],n=i[2];switch(s){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)){const i=parseFloat(t[1])/360,s=parseInt(t[2],10)/100,n=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(i,s,n)}}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=i[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=$[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=st(t.r),this.g=st(t.g),this.b=st(t.b),this}copyLinearToSRGB(t){return this.r=nt(t.r),this.g=nt(t.g),this.b=nt(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,i=this.g,s=this.b,n=Math.max(e,i,s),r=Math.min(e,i,s);let o,a;const l=(r+n)/2;if(r===n)o=0,a=0;else{const t=n-r;switch(a=l<=.5?t/(n+r):t/(2-n-r),n){case e:o=(i-s)/t+(i<s?6:0);break;case i:o=(s-e)/t+2;break;case s:o=(e-i)/t+4}o/=6}return t.h=o,t.s=a,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,i){return this.getHSL(tt),tt.h+=t,tt.s+=e,tt.l+=i,this.setHSL(tt.h,tt.s,tt.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(tt),t.getHSL(et);const i=H(tt.h,et.h,e),s=H(tt.s,et.s,e),n=H(tt.l,et.l,e);return this.setHSL(i,s,n),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}let ot;rt.NAMES=$,rt.prototype.isColor=!0,rt.prototype.r=1,rt.prototype.g=1,rt.prototype.b=1;class at{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===ot&&(ot=K("canvas")),ot.width=t.width,ot.height=t.height;const i=ot.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=ot}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=K("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),n=s.data;for(let t=0;t<n.length;t++)n[t]=255*st(n[t]/255);return i.putImageData(s,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*st(e[t]/255)):e[t]=st(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let lt=0;class ht extends F{constructor(t=ht.DEFAULT_IMAGE,e=ht.DEFAULT_MAPPING,i=1001,s=1001,n=1006,r=1008,o=1023,a=1009,l=1,h=3e3){super(),Object.defineProperty(this,"id",{value:lt++}),this.uuid=U(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=s,this.magFilter=n,this.minFilter=r,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new Z(0,0),this.repeat=new Z(1,1),this.center=new Z(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Y,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const s=this.image;if(void 0===s.uuid&&(s.uuid=U()),!e&&void 0===t.images[s.uuid]){let e;if(Array.isArray(s)){e=[];for(let t=0,i=s.length;t<i;t++)s[t].isDataTexture?e.push(ct(s[t].image)):e.push(ct(s[t]))}else e=ct(s);t.images[s.uuid]={uuid:s.uuid,url:e}}i.image=s.uuid}return"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case r:t.x=t.x-Math.floor(t.x);break;case o:t.x=t.x<0?0:1;break;case a:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case r:t.y=t.y-Math.floor(t.y);break;case o:t.y=t.y<0?0:1;break;case a:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function ct(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?at.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}ht.DEFAULT_IMAGE=void 0,ht.DEFAULT_MAPPING=300,ht.prototype.isTexture=!0;class mt{constructor(t=0,e=0,i=0,s=1){this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const r=.01,o=.1,a=t.elements,l=a[0],h=a[4],c=a[8],m=a[1],u=a[5],_=a[9],d=a[2],p=a[6],f=a[10];if(Math.abs(h-m)<r&&Math.abs(c-d)<r&&Math.abs(_-p)<r){if(Math.abs(h+m)<o&&Math.abs(c+d)<o&&Math.abs(_+p)<o&&Math.abs(l+u+f-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,a=(u+1)/2,y=(f+1)/2,g=(h+m)/4,x=(c+d)/4,v=(_+p)/4;return t>a&&t>y?t<r?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(t),s=g/i,n=x/i):a>y?a<r?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(a),i=g/s,n=v/s):y<r?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(y),i=x/n,s=v/n),this.set(i,s,n,e),this}let y=Math.sqrt((p-_)*(p-_)+(c-d)*(c-d)+(m-h)*(m-h));return Math.abs(y)<.001&&(y=1),this.x=(p-_)/y,this.y=(c-d)/y,this.z=(m-h)/y,this.w=Math.acos((l+u+f-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}mt.prototype.isVector4=!0;class ut extends F{constructor(t,e,i={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new mt(0,0,t,e),this.scissorTest=!1,this.viewport=new mt(0,0,t,e),this.texture=new ht(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,this.texture.internalFormat=void 0!==i.internalFormat?i.internalFormat:null,this.texture.minFilter=void 0!==i.minFilter?i.minFilter:h,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,i=1){this.width===t&&this.height===e&&this.depth===i||(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=Object.assign({},t.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}ut.prototype.isWebGLRenderTarget=!0,class extends ut{constructor(t,e,i){super(t,e);const s=this.texture;this.texture=[];for(let t=0;t<i;t++)this.texture[t]=s.clone()}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let s=0,n=this.texture.length;s<n;s++)this.texture[s].image.width=t,this.texture[s].image.height=e,this.texture[s].image.depth=i;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,i=t.texture.length;e<i;e++)this.texture[e]=t.texture[e].clone();return this}}.prototype.isWebGLMultipleRenderTargets=!0;class _t extends ut{constructor(t,e,i={}){super(t,e,i),this.samples=4,this.ignoreDepthForMultisampleCopy=void 0===i.ignoreDepth||i.ignoreDepth,this.useRenderToTexture=void 0!==i.useRenderToTexture&&i.useRenderToTexture,this.useRenderbuffer=!1===this.useRenderToTexture}copy(t){return super.copy.call(this,t),this.samples=t.samples,this.useRenderToTexture=t.useRenderToTexture,this.useRenderbuffer=t.useRenderbuffer,this}}_t.prototype.isWebGLMultisampleRenderTarget=!0;class dt{constructor(t=0,e=0,i=0,s=1){this._x=t,this._y=e,this._z=i,this._w=s}static slerp(t,e,i,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,s)}static slerpFlat(t,e,i,s,n,r,o){let a=i[s+0],l=i[s+1],h=i[s+2],c=i[s+3];const m=n[r+0],u=n[r+1],_=n[r+2],d=n[r+3];if(0===o)return t[e+0]=a,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===o)return t[e+0]=m,t[e+1]=u,t[e+2]=_,void(t[e+3]=d);if(c!==d||a!==m||l!==u||h!==_){let t=1-o;const e=a*m+l*u+h*_+c*d,i=e>=0?1:-1,s=1-e*e;if(s>Number.EPSILON){const n=Math.sqrt(s),r=Math.atan2(n,e*i);t=Math.sin(t*r)/n,o=Math.sin(o*r)/n}const n=o*i;if(a=a*t+m*n,l=l*t+u*n,h=h*t+_*n,c=c*t+d*n,t===1-o){const t=1/Math.sqrt(a*a+l*l+h*h+c*c);a*=t,l*=t,h*=t,c*=t}}t[e]=a,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const o=i[s],a=i[s+1],l=i[s+2],h=i[s+3],c=n[r],m=n[r+1],u=n[r+2],_=n[r+3];return t[e]=o*_+h*c+a*u-l*m,t[e+1]=a*_+h*m+l*c-o*u,t[e+2]=l*_+h*u+o*m-a*c,t[e+3]=h*_-o*c-a*m-l*u,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,s=t._y,n=t._z,r=t._order,o=Math.cos,a=Math.sin,l=o(i/2),h=o(s/2),c=o(n/2),m=a(i/2),u=a(s/2),_=a(n/2);switch(r){case"XYZ":this._x=m*h*c+l*u*_,this._y=l*u*c-m*h*_,this._z=l*h*_+m*u*c,this._w=l*h*c-m*u*_;break;case"YXZ":this._x=m*h*c+l*u*_,this._y=l*u*c-m*h*_,this._z=l*h*_-m*u*c,this._w=l*h*c+m*u*_;break;case"ZXY":this._x=m*h*c-l*u*_,this._y=l*u*c+m*h*_,this._z=l*h*_+m*u*c,this._w=l*h*c-m*u*_;break;case"ZYX":this._x=m*h*c-l*u*_,this._y=l*u*c+m*h*_,this._z=l*h*_-m*u*c,this._w=l*h*c+m*u*_;break;case"YZX":this._x=m*h*c+l*u*_,this._y=l*u*c+m*h*_,this._z=l*h*_-m*u*c,this._w=l*h*c-m*u*_;break;case"XZY":this._x=m*h*c-l*u*_,this._y=l*u*c-m*h*_,this._z=l*h*_+m*u*c,this._w=l*h*c+m*u*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],o=e[5],a=e[9],l=e[2],h=e[6],c=e[10],m=i+o+c;if(m>0){const t=.5/Math.sqrt(m+1);this._w=.25/t,this._x=(h-a)*t,this._y=(n-l)*t,this._z=(r-s)*t}else if(i>o&&i>c){const t=2*Math.sqrt(1+i-o-c);this._w=(h-a)/t,this._x=.25*t,this._y=(s+r)/t,this._z=(n+l)/t}else if(o>c){const t=2*Math.sqrt(1+o-i-c);this._w=(n-l)/t,this._x=(s+r)/t,this._y=.25*t,this._z=(a+h)/t}else{const t=2*Math.sqrt(1+c-i-o);this._w=(r-s)/t,this._x=(n+l)/t,this._y=(a+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(W(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,o=e._x,a=e._y,l=e._z,h=e._w;return this._x=i*h+r*o+s*l-n*a,this._y=s*h+r*a+n*o-i*l,this._z=n*h+r*l+i*a-s*o,this._w=r*h-i*o-s*a-n*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let o=r*t._w+i*t._x+s*t._y+n*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._w=t*r+e*this._w,this._x=t*i+e*this._x,this._y=t*s+e*this._y,this._z=t*n+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(a),h=Math.atan2(l,o),c=Math.sin((1-e)*h)/l,m=Math.sin(e*h)/l;return this._w=r*c+this._w*m,this._x=i*c+this._x*m,this._y=s*c+this._y*m,this._z=n*c+this._z*m,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),s=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(e*Math.cos(s),i*Math.sin(n),i*Math.cos(n),e*Math.sin(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}dt.prototype.isQuaternion=!0;class pt{constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(yt.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(yt.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,o=t.z,a=t.w,l=a*e+r*s-o*i,h=a*i+o*e-n*s,c=a*s+n*i-r*e,m=-n*e-r*i-o*s;return this.x=l*a+m*-n+h*-o-c*-r,this.y=h*a+m*-r+c*-n-l*-o,this.z=c*a+m*-o+l*-r-h*-n,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,o=e.y,a=e.z;return this.x=s*a-n*o,this.y=n*r-i*a,this.z=i*o-s*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return ft.copy(this).projectOnVector(t),this.sub(ft)}reflect(t){return this.sub(ft.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(W(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}pt.prototype.isVector3=!0;const ft=new pt,yt=new dt;class gt{constructor(t=new pt(1/0,1/0,1/0),e=new pt(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,s=1/0,n=-1/0,r=-1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=3){const l=t[a],h=t[a+1],c=t[a+2];l<e&&(e=l),h<i&&(i=h),c<s&&(s=c),l>n&&(n=l),h>r&&(r=h),c>o&&(o=c)}return this.min.set(e,i,s),this.max.set(n,r,o),this}setFromBufferAttribute(t){let e=1/0,i=1/0,s=1/0,n=-1/0,r=-1/0,o=-1/0;for(let a=0,l=t.count;a<l;a++){const l=t.getX(a),h=t.getY(a),c=t.getZ(a);l<e&&(e=l),h<i&&(i=h),c<s&&(s=c),l>n&&(n=l),h>r&&(r=h),c>o&&(o=c)}return this.min.set(e,i,s),this.max.set(n,r,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=vt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(void 0!==i)if(e&&null!=i.attributes&&void 0!==i.attributes.position){const e=i.attributes.position;for(let i=0,s=e.count;i<s;i++)vt.fromBufferAttribute(e,i).applyMatrix4(t.matrixWorld),this.expandByPoint(vt)}else null===i.boundingBox&&i.computeBoundingBox(),St.copy(i.boundingBox),St.applyMatrix4(t.matrixWorld),this.union(St);const s=t.children;for(let t=0,i=s.length;t<i;t++)this.expandByObject(s[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,vt),vt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Vt),Tt.subVectors(this.max,Vt),wt.subVectors(t.a,Vt),bt.subVectors(t.b,Vt),Ct.subVectors(t.c,Vt),At.subVectors(bt,wt),Bt.subVectors(Ct,bt),Mt.subVectors(wt,Ct);let e=[0,-At.z,At.y,0,-Bt.z,Bt.y,0,-Mt.z,Mt.y,At.z,0,-At.x,Bt.z,0,-Bt.x,Mt.z,0,-Mt.x,-At.y,At.x,0,-Bt.y,Bt.x,0,-Mt.y,Mt.x,0];return!!It(e,wt,bt,Ct,Tt)&&(e=[1,0,0,0,1,0,0,0,1],!!It(e,wt,bt,Ct,Tt)&&(Pt.crossVectors(At,Bt),e=[Pt.x,Pt.y,Pt.z],It(e,wt,bt,Ct,Tt)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return vt.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(vt).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(xt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),xt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),xt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),xt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),xt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),xt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),xt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),xt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(xt)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}gt.prototype.isBox3=!0;const xt=[new pt,new pt,new pt,new pt,new pt,new pt,new pt,new pt],vt=new pt,St=new gt,wt=new pt,bt=new pt,Ct=new pt,At=new pt,Bt=new pt,Mt=new pt,Vt=new pt,Tt=new pt,Pt=new pt,Dt=new pt;function It(t,e,i,s,n){for(let r=0,o=t.length-3;r<=o;r+=3){Dt.fromArray(t,r);const o=n.x*Math.abs(Dt.x)+n.y*Math.abs(Dt.y)+n.z*Math.abs(Dt.z),a=e.dot(Dt),l=i.dot(Dt),h=s.dot(Dt);if(Math.max(-Math.max(a,l,h),Math.min(a,l,h))>o)return!1}return!0}const Et=new gt,Rt=new pt,Lt=new pt,Gt=new pt;class Ft{constructor(t=new pt,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;void 0!==e?i.copy(e):Et.setFromPoints(t).getCenter(i);let s=0;for(let e=0,n=t.length;e<n;e++)s=Math.max(s,i.distanceToSquared(t[e]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Gt.subVectors(t,this.center);const e=Gt.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),i=.5*(t-this.radius);this.center.add(Gt.multiplyScalar(i/t)),this.radius+=i}return this}union(t){return!0===this.center.equals(t.center)?Lt.set(0,0,1).multiplyScalar(t.radius):Lt.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Rt.copy(t.center).add(Lt)),this.expandByPoint(Rt.copy(t.center).sub(Lt)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const kt=new pt,zt=new pt,Ot=new pt,Nt=new pt,Ut=new pt,Wt=new pt,jt=new pt;class Ht{constructor(t=new pt,e=new pt(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,kt)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=kt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(kt.copy(this.direction).multiplyScalar(e).add(this.origin),kt.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){zt.copy(t).add(e).multiplyScalar(.5),Ot.copy(e).sub(t).normalize(),Nt.copy(this.origin).sub(zt);const n=.5*t.distanceTo(e),r=-this.direction.dot(Ot),o=Nt.dot(this.direction),a=-Nt.dot(Ot),l=Nt.lengthSq(),h=Math.abs(1-r*r);let c,m,u,_;if(h>0)if(c=r*a-o,m=r*o-a,_=n*h,c>=0)if(m>=-_)if(m<=_){const t=1/h;c*=t,m*=t,u=c*(c+r*m+2*o)+m*(r*c+m+2*a)+l}else m=n,c=Math.max(0,-(r*m+o)),u=-c*c+m*(m+2*a)+l;else m=-n,c=Math.max(0,-(r*m+o)),u=-c*c+m*(m+2*a)+l;else m<=-_?(c=Math.max(0,-(-r*n+o)),m=c>0?-n:Math.min(Math.max(-n,-a),n),u=-c*c+m*(m+2*a)+l):m<=_?(c=0,m=Math.min(Math.max(-n,-a),n),u=m*(m+2*a)+l):(c=Math.max(0,-(r*n+o)),m=c>0?n:Math.min(Math.max(-n,-a),n),u=-c*c+m*(m+2*a)+l);else m=r>0?-n:n,c=Math.max(0,-(r*m+o)),u=-c*c+m*(m+2*a)+l;return i&&i.copy(this.direction).multiplyScalar(c).add(this.origin),s&&s.copy(Ot).multiplyScalar(m).add(zt),u}intersectSphere(t,e){kt.subVectors(t.center,this.origin);const i=kt.dot(this.direction),s=kt.dot(kt)-i*i,n=t.radius*t.radius;if(s>n)return null;const r=Math.sqrt(n-s),o=i-r,a=i+r;return o<0&&a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return null===i?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,n,r,o,a;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,m=this.origin;return l>=0?(i=(t.min.x-m.x)*l,s=(t.max.x-m.x)*l):(i=(t.max.x-m.x)*l,s=(t.min.x-m.x)*l),h>=0?(n=(t.min.y-m.y)*h,r=(t.max.y-m.y)*h):(n=(t.max.y-m.y)*h,r=(t.min.y-m.y)*h),i>r||n>s?null:((n>i||i!=i)&&(i=n),(r<s||s!=s)&&(s=r),c>=0?(o=(t.min.z-m.z)*c,a=(t.max.z-m.z)*c):(o=(t.max.z-m.z)*c,a=(t.min.z-m.z)*c),i>a||o>s?null:((o>i||i!=i)&&(i=o),(a<s||s!=s)&&(s=a),s<0?null:this.at(i>=0?i:s,e)))}intersectsBox(t){return null!==this.intersectBox(t,kt)}intersectTriangle(t,e,i,s,n){Ut.subVectors(e,t),Wt.subVectors(i,t),jt.crossVectors(Ut,Wt);let r,o=this.direction.dot(jt);if(o>0){if(s)return null;r=1}else{if(!(o<0))return null;r=-1,o=-o}Nt.subVectors(this.origin,t);const a=r*this.direction.dot(Wt.crossVectors(Nt,Wt));if(a<0)return null;const l=r*this.direction.dot(Ut.cross(Nt));if(l<0)return null;if(a+l>o)return null;const h=-r*Nt.dot(jt);return h<0?null:this.at(h/o,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class qt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,n,r,o,a,l,h,c,m,u,_,d,p){const f=this.elements;return f[0]=t,f[4]=e,f[8]=i,f[12]=s,f[1]=n,f[5]=r,f[9]=o,f[13]=a,f[2]=l,f[6]=h,f[10]=c,f[14]=m,f[3]=u,f[7]=_,f[11]=d,f[15]=p,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new qt).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/Xt.setFromMatrixColumn(t,0).length(),n=1/Xt.setFromMatrixColumn(t,1).length(),r=1/Xt.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),o=Math.sin(i),a=Math.cos(s),l=Math.sin(s),h=Math.cos(n),c=Math.sin(n);if("XYZ"===t.order){const t=r*h,i=r*c,s=o*h,n=o*c;e[0]=a*h,e[4]=-a*c,e[8]=l,e[1]=i+s*l,e[5]=t-n*l,e[9]=-o*a,e[2]=n-t*l,e[6]=s+i*l,e[10]=r*a}else if("YXZ"===t.order){const t=a*h,i=a*c,s=l*h,n=l*c;e[0]=t+n*o,e[4]=s*o-i,e[8]=r*l,e[1]=r*c,e[5]=r*h,e[9]=-o,e[2]=i*o-s,e[6]=n+t*o,e[10]=r*a}else if("ZXY"===t.order){const t=a*h,i=a*c,s=l*h,n=l*c;e[0]=t-n*o,e[4]=-r*c,e[8]=s+i*o,e[1]=i+s*o,e[5]=r*h,e[9]=n-t*o,e[2]=-r*l,e[6]=o,e[10]=r*a}else if("ZYX"===t.order){const t=r*h,i=r*c,s=o*h,n=o*c;e[0]=a*h,e[4]=s*l-i,e[8]=t*l+n,e[1]=a*c,e[5]=n*l+t,e[9]=i*l-s,e[2]=-l,e[6]=o*a,e[10]=r*a}else if("YZX"===t.order){const t=r*a,i=r*l,s=o*a,n=o*l;e[0]=a*h,e[4]=n-t*c,e[8]=s*c+i,e[1]=c,e[5]=r*h,e[9]=-o*h,e[2]=-l*h,e[6]=i*c+s,e[10]=t-n*c}else if("XZY"===t.order){const t=r*a,i=r*l,s=o*a,n=o*l;e[0]=a*h,e[4]=-c,e[8]=l*h,e[1]=t*c+n,e[5]=r*h,e[9]=i*c-s,e[2]=s*c-i,e[6]=o*h,e[10]=n*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Zt,t,Yt)}lookAt(t,e,i){const s=this.elements;return $t.subVectors(t,e),0===$t.lengthSq()&&($t.z=1),$t.normalize(),Qt.crossVectors(i,$t),0===Qt.lengthSq()&&(1===Math.abs(i.z)?$t.x+=1e-4:$t.z+=1e-4,$t.normalize(),Qt.crossVectors(i,$t)),Qt.normalize(),Kt.crossVectors($t,Qt),s[0]=Qt.x,s[4]=Kt.x,s[8]=$t.x,s[1]=Qt.y,s[5]=Kt.y,s[9]=$t.y,s[2]=Qt.z,s[6]=Kt.z,s[10]=$t.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],o=i[4],a=i[8],l=i[12],h=i[1],c=i[5],m=i[9],u=i[13],_=i[2],d=i[6],p=i[10],f=i[14],y=i[3],g=i[7],x=i[11],v=i[15],S=s[0],w=s[4],b=s[8],C=s[12],A=s[1],B=s[5],M=s[9],V=s[13],T=s[2],P=s[6],D=s[10],I=s[14],E=s[3],R=s[7],L=s[11],G=s[15];return n[0]=r*S+o*A+a*T+l*E,n[4]=r*w+o*B+a*P+l*R,n[8]=r*b+o*M+a*D+l*L,n[12]=r*C+o*V+a*I+l*G,n[1]=h*S+c*A+m*T+u*E,n[5]=h*w+c*B+m*P+u*R,n[9]=h*b+c*M+m*D+u*L,n[13]=h*C+c*V+m*I+u*G,n[2]=_*S+d*A+p*T+f*E,n[6]=_*w+d*B+p*P+f*R,n[10]=_*b+d*M+p*D+f*L,n[14]=_*C+d*V+p*I+f*G,n[3]=y*S+g*A+x*T+v*E,n[7]=y*w+g*B+x*P+v*R,n[11]=y*b+g*M+x*D+v*L,n[15]=y*C+g*V+x*I+v*G,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],o=t[5],a=t[9],l=t[13],h=t[2],c=t[6],m=t[10],u=t[14];return t[3]*(+n*a*c-s*l*c-n*o*m+i*l*m+s*o*u-i*a*u)+t[7]*(+e*a*u-e*l*m+n*r*m-s*r*u+s*l*h-n*a*h)+t[11]*(+e*l*c-e*o*u-n*r*c+i*r*u+n*o*h-i*l*h)+t[15]*(-s*o*h-e*a*c+e*o*m+s*r*c-i*r*m+i*a*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],l=t[7],h=t[8],c=t[9],m=t[10],u=t[11],_=t[12],d=t[13],p=t[14],f=t[15],y=c*p*l-d*m*l+d*a*u-o*p*u-c*a*f+o*m*f,g=_*m*l-h*p*l-_*a*u+r*p*u+h*a*f-r*m*f,x=h*d*l-_*c*l+_*o*u-r*d*u-h*o*f+r*c*f,v=_*c*a-h*d*a-_*o*m+r*d*m+h*o*p-r*c*p,S=e*y+i*g+s*x+n*v;if(0===S)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/S;return t[0]=y*w,t[1]=(d*m*n-c*p*n-d*s*u+i*p*u+c*s*f-i*m*f)*w,t[2]=(o*p*n-d*a*n+d*s*l-i*p*l-o*s*f+i*a*f)*w,t[3]=(c*a*n-o*m*n-c*s*l+i*m*l+o*s*u-i*a*u)*w,t[4]=g*w,t[5]=(h*p*n-_*m*n+_*s*u-e*p*u-h*s*f+e*m*f)*w,t[6]=(_*a*n-r*p*n-_*s*l+e*p*l+r*s*f-e*a*f)*w,t[7]=(r*m*n-h*a*n+h*s*l-e*m*l-r*s*u+e*a*u)*w,t[8]=x*w,t[9]=(_*c*n-h*d*n-_*i*u+e*d*u+h*i*f-e*c*f)*w,t[10]=(r*d*n-_*o*n+_*i*l-e*d*l-r*i*f+e*o*f)*w,t[11]=(h*o*n-r*c*n-h*i*l+e*c*l+r*i*u-e*o*u)*w,t[12]=v*w,t[13]=(h*d*s-_*c*s+_*i*m-e*d*m-h*i*p+e*c*p)*w,t[14]=(_*o*s-r*d*s-_*i*a+e*d*a+r*i*p-e*o*p)*w,t[15]=(r*c*s-h*o*s+h*i*a-e*c*a-r*i*m+e*o*m)*w,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,o=t.y,a=t.z,l=n*r,h=n*o;return this.set(l*r+i,l*o-s*a,l*a+s*o,0,l*o+s*a,h*o+i,h*a-s*r,0,l*a-s*o,h*a+s*r,n*a*a+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,o=e._z,a=e._w,l=n+n,h=r+r,c=o+o,m=n*l,u=n*h,_=n*c,d=r*h,p=r*c,f=o*c,y=a*l,g=a*h,x=a*c,v=i.x,S=i.y,w=i.z;return s[0]=(1-(d+f))*v,s[1]=(u+x)*v,s[2]=(_-g)*v,s[3]=0,s[4]=(u-x)*S,s[5]=(1-(m+f))*S,s[6]=(p+y)*S,s[7]=0,s[8]=(_+g)*w,s[9]=(p-y)*w,s[10]=(1-(m+d))*w,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=Xt.set(s[0],s[1],s[2]).length();const r=Xt.set(s[4],s[5],s[6]).length(),o=Xt.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],Jt.copy(this);const a=1/n,l=1/r,h=1/o;return Jt.elements[0]*=a,Jt.elements[1]*=a,Jt.elements[2]*=a,Jt.elements[4]*=l,Jt.elements[5]*=l,Jt.elements[6]*=l,Jt.elements[8]*=h,Jt.elements[9]*=h,Jt.elements[10]*=h,e.setFromRotationMatrix(Jt),i.x=n,i.y=r,i.z=o,this}makePerspective(t,e,i,s,n,r){void 0===r&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,a=2*n/(e-t),l=2*n/(i-s),h=(e+t)/(e-t),c=(i+s)/(i-s),m=-(r+n)/(r-n),u=-2*r*n/(r-n);return o[0]=a,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=l,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=m,o[14]=u,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,s,n,r){const o=this.elements,a=1/(e-t),l=1/(i-s),h=1/(r-n),c=(e+t)*a,m=(i+s)*l,u=(r+n)*h;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-c,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-m,o[2]=0,o[6]=0,o[10]=-2*h,o[14]=-u,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<16;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}qt.prototype.isMatrix4=!0;const Xt=new pt,Jt=new qt,Zt=new pt(0,0,0),Yt=new pt(1,1,1),Qt=new pt,Kt=new pt,$t=new pt,te=new qt,ee=new dt;class ie{constructor(t=0,e=0,i=0,s=ie.DefaultOrder){this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],r=s[4],o=s[8],a=s[1],l=s[5],h=s[9],c=s[2],m=s[6],u=s[10];switch(e){case"XYZ":this._y=Math.asin(W(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,u),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(m,l),this._z=0);break;case"YXZ":this._x=Math.asin(-W(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,u),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-c,n),this._z=0);break;case"ZXY":this._x=Math.asin(W(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(-c,u),this._z=Math.atan2(-r,l)):(this._y=0,this._z=Math.atan2(a,n));break;case"ZYX":this._y=Math.asin(-W(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(m,u),this._z=Math.atan2(a,n)):(this._x=0,this._z=Math.atan2(-r,l));break;case"YZX":this._z=Math.asin(W(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,n)):(this._x=0,this._y=Math.atan2(o,u));break;case"XZY":this._z=Math.asin(-W(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(m,l),this._y=Math.atan2(o,n)):(this._x=Math.atan2(-h,u),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return te.makeRotationFromQuaternion(t),this.setFromRotationMatrix(te,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return ee.setFromEuler(this),this.setFromQuaternion(ee,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new pt(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}ie.prototype.isEuler=!0,ie.DefaultOrder="XYZ",ie.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class se{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let ne=0;const re=new pt,oe=new dt,ae=new qt,le=new pt,he=new pt,ce=new pt,me=new dt,ue=new pt(1,0,0),_e=new pt(0,1,0),de=new pt(0,0,1),pe={type:"added"},fe={type:"removed"};class ye extends F{constructor(){super(),Object.defineProperty(this,"id",{value:ne++}),this.uuid=U(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ye.DefaultUp.clone();const t=new pt,e=new ie,i=new dt,s=new pt(1,1,1);e._onChange((function(){i.setFromEuler(e,!1)})),i._onChange((function(){e.setFromQuaternion(i,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new qt},normalMatrix:{value:new Y}}),this.matrix=new qt,this.matrixWorld=new qt,this.matrixAutoUpdate=ye.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new se,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return oe.setFromAxisAngle(t,e),this.quaternion.multiply(oe),this}rotateOnWorldAxis(t,e){return oe.setFromAxisAngle(t,e),this.quaternion.premultiply(oe),this}rotateX(t){return this.rotateOnAxis(ue,t)}rotateY(t){return this.rotateOnAxis(_e,t)}rotateZ(t){return this.rotateOnAxis(de,t)}translateOnAxis(t,e){return re.copy(t).applyQuaternion(this.quaternion),this.position.add(re.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ue,t)}translateY(t){return this.translateOnAxis(_e,t)}translateZ(t){return this.translateOnAxis(de,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(ae.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?le.copy(t):le.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),he.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ae.lookAt(he,le,this.up):ae.lookAt(le,he,this.up),this.quaternion.setFromRotationMatrix(ae),s&&(ae.extractRotation(s.matrixWorld),oe.setFromRotationMatrix(ae),this.quaternion.premultiply(oe.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(pe)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(fe)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(fe)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ae.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ae.multiply(t.parent.matrixWorld)),t.applyMatrix4(ae),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const s=this.children[i].getObjectByProperty(t,e);if(void 0!==s)return s}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(he,t,ce),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(he,me,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(!0===t&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};function n(e,i){return void 0===e[i.uuid]&&(e[i.uuid]=i.toJSON(t)),i.uuid}if(s.uuid=this.uuid,s.type=this.type,""!==this.name&&(s.name=this.name),!0===this.castShadow&&(s.castShadow=!0),!0===this.receiveShadow&&(s.receiveShadow=!0),!1===this.visible&&(s.visible=!1),!1===this.frustumCulled&&(s.frustumCulled=!1),0!==this.renderOrder&&(s.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(s.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=n(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const i=e.shapes;if(Array.isArray(i))for(let e=0,s=i.length;e<s;e++){const s=i[e];n(t.shapes,s)}else n(t.shapes,i)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(n(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let i=0,s=this.material.length;i<s;i++)e.push(n(t.materials,this.material[i]));s.material=e}else s.material=n(t.materials,this.material);if(this.children.length>0){s.children=[];for(let e=0;e<this.children.length;e++)s.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let e=0;e<this.animations.length;e++){const i=this.animations[e];s.animations.push(n(t.animations,i))}}if(e){const e=r(t.geometries),s=r(t.materials),n=r(t.textures),o=r(t.images),a=r(t.shapes),l=r(t.skeletons),h=r(t.animations);e.length>0&&(i.geometries=e),s.length>0&&(i.materials=s),n.length>0&&(i.textures=n),o.length>0&&(i.images=o),a.length>0&&(i.shapes=a),l.length>0&&(i.skeletons=l),h.length>0&&(i.animations=h)}return i.object=s,i;function r(t){const e=[];for(const i in t){const s=t[i];delete s.metadata,e.push(s)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const i=t.children[e];this.add(i.clone())}return this}}ye.DefaultUp=new pt(0,1,0),ye.DefaultMatrixAutoUpdate=!0,ye.prototype.isObject3D=!0;const ge=new pt,xe=new pt,ve=new pt,Se=new pt,we=new pt,be=new pt,Ce=new pt,Ae=new pt,Be=new pt,Me=new pt;class Ve{constructor(t=new pt,e=new pt,i=new pt){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),ge.subVectors(t,e),s.cross(ge);const n=s.lengthSq();return n>0?s.multiplyScalar(1/Math.sqrt(n)):s.set(0,0,0)}static getBarycoord(t,e,i,s,n){ge.subVectors(s,e),xe.subVectors(i,e),ve.subVectors(t,e);const r=ge.dot(ge),o=ge.dot(xe),a=ge.dot(ve),l=xe.dot(xe),h=xe.dot(ve),c=r*l-o*o;if(0===c)return n.set(-2,-1,-1);const m=1/c,u=(l*a-o*h)*m,_=(r*h-o*a)*m;return n.set(1-u-_,_,u)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Se),Se.x>=0&&Se.y>=0&&Se.x+Se.y<=1}static getUV(t,e,i,s,n,r,o,a){return this.getBarycoord(t,e,i,s,Se),a.set(0,0),a.addScaledVector(n,Se.x),a.addScaledVector(r,Se.y),a.addScaledVector(o,Se.z),a}static isFrontFacing(t,e,i,s){return ge.subVectors(i,e),xe.subVectors(t,e),ge.cross(xe).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ge.subVectors(this.c,this.b),xe.subVectors(this.a,this.b),.5*ge.cross(xe).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Ve.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Ve.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,s,n){return Ve.getUV(t,this.a,this.b,this.c,e,i,s,n)}containsPoint(t){return Ve.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Ve.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,n=this.c;let r,o;we.subVectors(s,i),be.subVectors(n,i),Ae.subVectors(t,i);const a=we.dot(Ae),l=be.dot(Ae);if(a<=0&&l<=0)return e.copy(i);Be.subVectors(t,s);const h=we.dot(Be),c=be.dot(Be);if(h>=0&&c<=h)return e.copy(s);const m=a*c-h*l;if(m<=0&&a>=0&&h<=0)return r=a/(a-h),e.copy(i).addScaledVector(we,r);Me.subVectors(t,n);const u=we.dot(Me),_=be.dot(Me);if(_>=0&&u<=_)return e.copy(n);const d=u*l-a*_;if(d<=0&&l>=0&&_<=0)return o=l/(l-_),e.copy(i).addScaledVector(be,o);const p=h*_-u*c;if(p<=0&&c-h>=0&&u-_>=0)return Ce.subVectors(n,s),o=(c-h)/(c-h+(u-_)),e.copy(s).addScaledVector(Ce,o);const f=1/(p+d+m);return r=d*f,o=m*f,e.copy(i).addScaledVector(we,r).addScaledVector(be,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Te=0;class Pe extends F{constructor(){super(),Object.defineProperty(this,"id",{value:Te++}),this.uuid=U(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=t,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=I,this.stencilZFail=I,this.stencilZPass=I,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const i=t[e];if(void 0===i){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===i;continue}const s=this[e];void 0!==s?s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function s(t){const e=[];for(const i in t){const s=t[i];delete s.metadata,e.push(s)}return e}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(i.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=this.flatShading),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),e){const e=s(t.textures),n=s(t.images);e.length>0&&(i.textures=e),n.length>0&&(i.images=n)}return i}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(null!==e){const t=e.length;i=new Array(t);for(let s=0;s!==t;++s)i[s]=e[s].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}Pe.prototype.isMaterial=!0;class De extends Pe{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new rt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}De.prototype.isMeshBasicMaterial=!0;const Ie=new pt,Ee=new Z;class Re{constructor(t,e,i){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===i,this.usage=E,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,n=this.itemSize;s<n;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let i=0;for(let s=0,n=t.length;s<n;s++){let n=t[s];void 0===n&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),n=new rt),e[i++]=n.r,e[i++]=n.g,e[i++]=n.b}return this}copyVector2sArray(t){const e=this.array;let i=0;for(let s=0,n=t.length;s<n;s++){let n=t[s];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),n=new Z),e[i++]=n.x,e[i++]=n.y}return this}copyVector3sArray(t){const e=this.array;let i=0;for(let s=0,n=t.length;s<n;s++){let n=t[s];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),n=new pt),e[i++]=n.x,e[i++]=n.y,e[i++]=n.z}return this}copyVector4sArray(t){const e=this.array;let i=0;for(let s=0,n=t.length;s<n;s++){let n=t[s];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),n=new mt),e[i++]=n.x,e[i++]=n.y,e[i++]=n.z,e[i++]=n.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,i=this.count;e<i;e++)Ee.fromBufferAttribute(this,e),Ee.applyMatrix3(t),this.setXY(e,Ee.x,Ee.y);else if(3===this.itemSize)for(let e=0,i=this.count;e<i;e++)Ie.fromBufferAttribute(this,e),Ie.applyMatrix3(t),this.setXYZ(e,Ie.x,Ie.y,Ie.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)Ie.x=this.getX(e),Ie.y=this.getY(e),Ie.z=this.getZ(e),Ie.applyMatrix4(t),this.setXYZ(e,Ie.x,Ie.y,Ie.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Ie.x=this.getX(e),Ie.y=this.getY(e),Ie.z=this.getZ(e),Ie.applyNormalMatrix(t),this.setXYZ(e,Ie.x,Ie.y,Ie.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Ie.x=this.getX(e),Ie.y=this.getY(e),Ie.z=this.getZ(e),Ie.transformDirection(t),this.setXYZ(e,Ie.x,Ie.y,Ie.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==E&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}Re.prototype.isBufferAttribute=!0;class Le extends Re{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Ge extends Re{constructor(t,e,i){super(new Uint32Array(t),e,i)}}(class extends Re{constructor(t,e,i){super(new Uint16Array(t),e,i)}}).prototype.isFloat16BufferAttribute=!0;class Fe extends Re{constructor(t,e,i){super(new Float32Array(t),e,i)}}let ke=0;const ze=new qt,Oe=new ye,Ne=new pt,Ue=new gt,We=new gt,je=new pt;class He extends F{constructor(){super(),Object.defineProperty(this,"id",{value:ke++}),this.uuid=U(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Q(t)?Ge:Le)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(void 0!==i){const e=(new Y).getNormalMatrix(t);i.applyNormalMatrix(e),i.needsUpdate=!0}const s=this.attributes.tangent;return void 0!==s&&(s.transformDirection(t),s.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return ze.makeRotationFromQuaternion(t),this.applyMatrix4(ze),this}rotateX(t){return ze.makeRotationX(t),this.applyMatrix4(ze),this}rotateY(t){return ze.makeRotationY(t),this.applyMatrix4(ze),this}rotateZ(t){return ze.makeRotationZ(t),this.applyMatrix4(ze),this}translate(t,e,i){return ze.makeTranslation(t,e,i),this.applyMatrix4(ze),this}scale(t,e,i){return ze.makeScale(t,e,i),this.applyMatrix4(ze),this}lookAt(t){return Oe.lookAt(t),Oe.updateMatrix(),this.applyMatrix4(Oe.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ne).negate(),this.translate(Ne.x,Ne.y,Ne.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const s=t[i];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Fe(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new gt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new pt(-1/0,-1/0,-1/0),new pt(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];Ue.setFromBufferAttribute(i),this.morphTargetsRelative?(je.addVectors(this.boundingBox.min,Ue.min),this.boundingBox.expandByPoint(je),je.addVectors(this.boundingBox.max,Ue.max),this.boundingBox.expandByPoint(je)):(this.boundingBox.expandByPoint(Ue.min),this.boundingBox.expandByPoint(Ue.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Ft);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new pt,1/0);if(t){const i=this.boundingSphere.center;if(Ue.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];We.setFromBufferAttribute(i),this.morphTargetsRelative?(je.addVectors(Ue.min,We.min),Ue.expandByPoint(je),je.addVectors(Ue.max,We.max),Ue.expandByPoint(je)):(Ue.expandByPoint(We.min),Ue.expandByPoint(We.max))}Ue.getCenter(i);let s=0;for(let e=0,n=t.count;e<n;e++)je.fromBufferAttribute(t,e),s=Math.max(s,i.distanceToSquared(je));if(e)for(let n=0,r=e.length;n<r;n++){const r=e[n],o=this.morphTargetsRelative;for(let e=0,n=r.count;e<n;e++)je.fromBufferAttribute(r,e),o&&(Ne.fromBufferAttribute(t,e),je.add(Ne)),s=Math.max(s,i.distanceToSquared(je))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const i=t.array,s=e.position.array,n=e.normal.array,r=e.uv.array,o=s.length/3;void 0===e.tangent&&this.setAttribute("tangent",new Re(new Float32Array(4*o),4));const a=e.tangent.array,l=[],h=[];for(let t=0;t<o;t++)l[t]=new pt,h[t]=new pt;const c=new pt,m=new pt,u=new pt,_=new Z,d=new Z,p=new Z,f=new pt,y=new pt;function g(t,e,i){c.fromArray(s,3*t),m.fromArray(s,3*e),u.fromArray(s,3*i),_.fromArray(r,2*t),d.fromArray(r,2*e),p.fromArray(r,2*i),m.sub(c),u.sub(c),d.sub(_),p.sub(_);const n=1/(d.x*p.y-p.x*d.y);isFinite(n)&&(f.copy(m).multiplyScalar(p.y).addScaledVector(u,-d.y).multiplyScalar(n),y.copy(u).multiplyScalar(d.x).addScaledVector(m,-p.x).multiplyScalar(n),l[t].add(f),l[e].add(f),l[i].add(f),h[t].add(y),h[e].add(y),h[i].add(y))}let x=this.groups;0===x.length&&(x=[{start:0,count:i.length}]);for(let t=0,e=x.length;t<e;++t){const e=x[t],s=e.start;for(let t=s,n=s+e.count;t<n;t+=3)g(i[t+0],i[t+1],i[t+2])}const v=new pt,S=new pt,w=new pt,b=new pt;function C(t){w.fromArray(n,3*t),b.copy(w);const e=l[t];v.copy(e),v.sub(w.multiplyScalar(w.dot(e))).normalize(),S.crossVectors(b,e);const i=S.dot(h[t])<0?-1:1;a[4*t]=v.x,a[4*t+1]=v.y,a[4*t+2]=v.z,a[4*t+3]=i}for(let t=0,e=x.length;t<e;++t){const e=x[t],s=e.start;for(let t=s,n=s+e.count;t<n;t+=3)C(i[t+0]),C(i[t+1]),C(i[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let i=this.getAttribute("normal");if(void 0===i)i=new Re(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let t=0,e=i.count;t<e;t++)i.setXYZ(t,0,0,0);const s=new pt,n=new pt,r=new pt,o=new pt,a=new pt,l=new pt,h=new pt,c=new pt;if(t)for(let m=0,u=t.count;m<u;m+=3){const u=t.getX(m+0),_=t.getX(m+1),d=t.getX(m+2);s.fromBufferAttribute(e,u),n.fromBufferAttribute(e,_),r.fromBufferAttribute(e,d),h.subVectors(r,n),c.subVectors(s,n),h.cross(c),o.fromBufferAttribute(i,u),a.fromBufferAttribute(i,_),l.fromBufferAttribute(i,d),o.add(h),a.add(h),l.add(h),i.setXYZ(u,o.x,o.y,o.z),i.setXYZ(_,a.x,a.y,a.z),i.setXYZ(d,l.x,l.y,l.z)}else for(let t=0,o=e.count;t<o;t+=3)s.fromBufferAttribute(e,t+0),n.fromBufferAttribute(e,t+1),r.fromBufferAttribute(e,t+2),h.subVectors(r,n),c.subVectors(s,n),h.cross(c),i.setXYZ(t+0,h.x,h.y,h.z),i.setXYZ(t+1,h.x,h.y,h.z),i.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const s in i){if(void 0===t.attributes[s])continue;const n=i[s].array,r=t.attributes[s],o=r.array,a=r.itemSize*e,l=Math.min(o.length,n.length-a);for(let t=0,e=a;t<l;t++,e++)n[e]=o[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)je.fromBufferAttribute(t,e),je.normalize(),t.setXYZ(e,je.x,je.y,je.z)}toNonIndexed(){function t(t,e){const i=t.array,s=t.itemSize,n=t.normalized,r=new i.constructor(e.length*s);let o=0,a=0;for(let n=0,l=e.length;n<l;n++){o=t.isInterleavedBufferAttribute?e[n]*t.data.stride+t.offset:e[n]*s;for(let t=0;t<s;t++)r[a++]=i[o++]}return new Re(r,s,n)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new He,i=this.index.array,s=this.attributes;for(const n in s){const r=t(s[n],i);e.setAttribute(n,r)}const n=this.morphAttributes;for(const s in n){const r=[],o=n[s];for(let e=0,s=o.length;e<s;e++){const s=t(o[e],i);r.push(s)}e.morphAttributes[s]=r}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let t=0,i=r.length;t<i;t++){const i=r[t];e.addGroup(i.start,i.count,i.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const i in e)void 0!==e[i]&&(t[i]=e[i]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const e in i){const s=i[e];t.data.attributes[e]=s.toJSON(t.data)}const s={};let n=!1;for(const e in this.morphAttributes){const i=this.morphAttributes[e],r=[];for(let e=0,s=i.length;e<s;e++){const s=i[e];r.push(s.toJSON(t.data))}r.length>0&&(s[e]=r,n=!0)}n&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;null!==i&&this.setIndex(i.clone(e));const s=t.attributes;for(const t in s){const i=s[t];this.setAttribute(t,i.clone(e))}const n=t.morphAttributes;for(const t in n){const i=[],s=n[t];for(let t=0,n=s.length;t<n;t++)i.push(s[t].clone(e));this.morphAttributes[t]=i}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let t=0,e=r.length;t<e;t++){const e=r[t];this.addGroup(e.start,e.count,e.materialIndex)}const o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}He.prototype.isBufferGeometry=!0;const qe=new qt,Xe=new Ht,Je=new Ft,Ze=new pt,Ye=new pt,Qe=new pt,Ke=new pt,$e=new pt,ti=new pt,ei=new pt,ii=new pt,si=new pt,ni=new Z,ri=new Z,oi=new Z,ai=new pt,li=new pt;class hi extends ye{constructor(t=new He,e=new De){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){const i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const i=this.geometry,s=this.material,n=this.matrixWorld;if(void 0===s)return;if(null===i.boundingSphere&&i.computeBoundingSphere(),Je.copy(i.boundingSphere),Je.applyMatrix4(n),!1===t.ray.intersectsSphere(Je))return;if(qe.copy(n).invert(),Xe.copy(t.ray).applyMatrix4(qe),null!==i.boundingBox&&!1===Xe.intersectsBox(i.boundingBox))return;let r;if(i.isBufferGeometry){const n=i.index,o=i.attributes.position,a=i.morphAttributes.position,l=i.morphTargetsRelative,h=i.attributes.uv,c=i.attributes.uv2,m=i.groups,u=i.drawRange;if(null!==n)if(Array.isArray(s))for(let i=0,_=m.length;i<_;i++){const _=m[i],d=s[_.materialIndex];for(let i=Math.max(_.start,u.start),s=Math.min(n.count,Math.min(_.start+_.count,u.start+u.count));i<s;i+=3){const s=n.getX(i),m=n.getX(i+1),u=n.getX(i+2);r=ci(this,d,t,Xe,o,a,l,h,c,s,m,u),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=_.materialIndex,e.push(r))}}else for(let i=Math.max(0,u.start),m=Math.min(n.count,u.start+u.count);i<m;i+=3){const m=n.getX(i),u=n.getX(i+1),_=n.getX(i+2);r=ci(this,s,t,Xe,o,a,l,h,c,m,u,_),r&&(r.faceIndex=Math.floor(i/3),e.push(r))}else if(void 0!==o)if(Array.isArray(s))for(let i=0,n=m.length;i<n;i++){const n=m[i],_=s[n.materialIndex];for(let i=Math.max(n.start,u.start),s=Math.min(o.count,Math.min(n.start+n.count,u.start+u.count));i<s;i+=3)r=ci(this,_,t,Xe,o,a,l,h,c,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),r.face.materialIndex=n.materialIndex,e.push(r))}else for(let i=Math.max(0,u.start),n=Math.min(o.count,u.start+u.count);i<n;i+=3)r=ci(this,s,t,Xe,o,a,l,h,c,i,i+1,i+2),r&&(r.faceIndex=Math.floor(i/3),e.push(r))}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function ci(t,e,i,s,n,r,o,a,l,h,c,m){Ze.fromBufferAttribute(n,h),Ye.fromBufferAttribute(n,c),Qe.fromBufferAttribute(n,m);const u=t.morphTargetInfluences;if(r&&u){ei.set(0,0,0),ii.set(0,0,0),si.set(0,0,0);for(let t=0,e=r.length;t<e;t++){const e=u[t],i=r[t];0!==e&&(Ke.fromBufferAttribute(i,h),$e.fromBufferAttribute(i,c),ti.fromBufferAttribute(i,m),o?(ei.addScaledVector(Ke,e),ii.addScaledVector($e,e),si.addScaledVector(ti,e)):(ei.addScaledVector(Ke.sub(Ze),e),ii.addScaledVector($e.sub(Ye),e),si.addScaledVector(ti.sub(Qe),e)))}Ze.add(ei),Ye.add(ii),Qe.add(si)}t.isSkinnedMesh&&(t.boneTransform(h,Ze),t.boneTransform(c,Ye),t.boneTransform(m,Qe));const _=function(t,e,i,s,n,r,o,a){let l;if(l=1===e.side?s.intersectTriangle(o,r,n,!0,a):s.intersectTriangle(n,r,o,2!==e.side,a),null===l)return null;li.copy(a),li.applyMatrix4(t.matrixWorld);const h=i.ray.origin.distanceTo(li);return h<i.near||h>i.far?null:{distance:h,point:li.clone(),object:t}}(t,e,i,s,Ze,Ye,Qe,ai);if(_){a&&(ni.fromBufferAttribute(a,h),ri.fromBufferAttribute(a,c),oi.fromBufferAttribute(a,m),_.uv=Ve.getUV(ai,Ze,Ye,Qe,ni,ri,oi,new Z)),l&&(ni.fromBufferAttribute(l,h),ri.fromBufferAttribute(l,c),oi.fromBufferAttribute(l,m),_.uv2=Ve.getUV(ai,Ze,Ye,Qe,ni,ri,oi,new Z));const t={a:h,b:c,c:m,normal:new pt,materialIndex:0};Ve.getNormal(Ze,Ye,Qe,t.normal),_.face=t}return _}hi.prototype.isMesh=!0;class mi extends He{constructor(t=1,e=1,i=1,s=1,n=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:s,heightSegments:n,depthSegments:r};const o=this;s=Math.floor(s),n=Math.floor(n),r=Math.floor(r);const a=[],l=[],h=[],c=[];let m=0,u=0;function _(t,e,i,s,n,r,_,d,p,f,y){const g=r/p,x=_/f,v=r/2,S=_/2,w=d/2,b=p+1,C=f+1;let A=0,B=0;const M=new pt;for(let r=0;r<C;r++){const o=r*x-S;for(let a=0;a<b;a++){const m=a*g-v;M[t]=m*s,M[e]=o*n,M[i]=w,l.push(M.x,M.y,M.z),M[t]=0,M[e]=0,M[i]=d>0?1:-1,h.push(M.x,M.y,M.z),c.push(a/p),c.push(1-r/f),A+=1}}for(let t=0;t<f;t++)for(let e=0;e<p;e++){const i=m+e+b*t,s=m+e+b*(t+1),n=m+(e+1)+b*(t+1),r=m+(e+1)+b*t;a.push(i,s,r),a.push(s,n,r),B+=6}o.addGroup(u,B,y),u+=B,m+=A}_("z","y","x",-1,-1,i,e,t,r,n,0),_("z","y","x",1,-1,i,e,-t,r,n,1),_("x","z","y",1,1,t,i,e,s,r,2),_("x","z","y",1,-1,t,i,-e,s,r,3),_("x","y","z",1,-1,t,e,i,s,n,4),_("x","y","z",-1,-1,t,e,-i,s,n,5),this.setIndex(a),this.setAttribute("position",new Fe(l,3)),this.setAttribute("normal",new Fe(h,3)),this.setAttribute("uv",new Fe(c,2))}static fromJSON(t){return new mi(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ui(t){const e={};for(const i in t){e[i]={};for(const s in t[i]){const n=t[i][s];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?e[i][s]=n.clone():Array.isArray(n)?e[i][s]=n.slice():e[i][s]=n}}return e}function _i(t){const e={};for(let i=0;i<t.length;i++){const s=ui(t[i]);for(const t in s)e[t]=s[t]}return e}const di={clone:ui,merge:_i};class pi extends Pe{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ui(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?e.uniforms[i]={type:"t",value:s.toJSON(t).uuid}:s&&s.isColor?e.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?e.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?e.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?e.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?e.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?e.uniforms[i]={type:"m4",value:s.toArray()}:e.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const i={};for(const t in this.extensions)!0===this.extensions[t]&&(i[t]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}pi.prototype.isShaderMaterial=!0;class fi extends ye{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new qt,this.projectionMatrix=new qt,this.projectionMatrixInverse=new qt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}fi.prototype.isCamera=!0;class yi extends fi{constructor(t=50,e=1,i=.1,s=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*N*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*O*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*N*Math.atan(Math.tan(.5*O*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,i,s,n,r){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*O*this.fov)/this.zoom,i=2*e,s=this.aspect*i,n=-.5*s;const r=this.view;if(null!==this.view&&this.view.enabled){const t=r.fullWidth,o=r.fullHeight;n+=r.offsetX*s/t,e-=r.offsetY*i/o,s*=r.width/t,i*=r.height/o}const o=this.filmOffset;0!==o&&(n+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+s,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}yi.prototype.isPerspectiveCamera=!0;const gi=90;class xi extends ye{constructor(t,e,i){if(super(),this.type="CubeCamera",!0!==i.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=i;const s=new yi(gi,1,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new pt(1,0,0)),this.add(s);const n=new yi(gi,1,t,e);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new pt(-1,0,0)),this.add(n);const r=new yi(gi,1,t,e);r.layers=this.layers,r.up.set(0,0,1),r.lookAt(new pt(0,1,0)),this.add(r);const o=new yi(gi,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new pt(0,-1,0)),this.add(o);const a=new yi(gi,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new pt(0,0,1)),this.add(a);const l=new yi(gi,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new pt(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const i=this.renderTarget,[s,n,r,o,a,l]=this.children,h=t.xr.enabled,c=t.getRenderTarget();t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,s),t.setRenderTarget(i,1),t.render(e,n),t.setRenderTarget(i,2),t.render(e,r),t.setRenderTarget(i,3),t.render(e,o),t.setRenderTarget(i,4),t.render(e,a),i.texture.generateMipmaps=m,t.setRenderTarget(i,5),t.render(e,l),t.setRenderTarget(c),t.xr.enabled=h,i.texture.needsPMREMUpdate=!0}}class vi extends ht{constructor(t,i,s,n,r,o,a,l,h,c){super(t=void 0!==t?t:[],i=void 0!==i?i:e,s,n,r,o,a,l,h,c),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}vi.prototype.isCubeTexture=!0;class Si extends ut{constructor(t,e,i){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=i),super(t,t,e),e=e||{},this.texture=new vi(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:h}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=y,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={tEquirect:{value:null}},s="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",n="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",r=new mi(5,5,5),o=new pi({name:"CubemapFromEquirect",uniforms:ui(i),vertexShader:s,fragmentShader:n,side:1,blending:0});o.uniforms.tEquirect.value=e;const a=new hi(r,o),l=e.minFilter;return e.minFilter===c&&(e.minFilter=h),new xi(1,10,this).update(t,a),e.minFilter=l,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,i,s){const n=t.getRenderTarget();for(let n=0;n<6;n++)t.setRenderTarget(this,n),t.clear(e,i,s);t.setRenderTarget(n)}}Si.prototype.isWebGLCubeRenderTarget=!0;const wi=new pt,bi=new pt,Ci=new Y;class Ai{constructor(t=new pt(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=wi.subVectors(i,e).cross(bi.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const i=t.delta(wi),s=this.normal.dot(i);if(0===s)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/s;return n<0||n>1?null:e.copy(i).multiplyScalar(n).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||Ci.getNormalMatrix(t),s=this.coplanarPoint(wi).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Ai.prototype.isPlane=!0;const Bi=new Ft,Mi=new pt;class Vi{constructor(t=new Ai,e=new Ai,i=new Ai,s=new Ai,n=new Ai,r=new Ai){this.planes=[t,e,i,s,n,r]}set(t,e,i,s,n,r){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(s),o[4].copy(n),o[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,s=i[0],n=i[1],r=i[2],o=i[3],a=i[4],l=i[5],h=i[6],c=i[7],m=i[8],u=i[9],_=i[10],d=i[11],p=i[12],f=i[13],y=i[14],g=i[15];return e[0].setComponents(o-s,c-a,d-m,g-p).normalize(),e[1].setComponents(o+s,c+a,d+m,g+p).normalize(),e[2].setComponents(o+n,c+l,d+u,g+f).normalize(),e[3].setComponents(o-n,c-l,d-u,g-f).normalize(),e[4].setComponents(o-r,c-h,d-_,g-y).normalize(),e[5].setComponents(o+r,c+h,d+_,g+y).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),Bi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Bi)}intersectsSprite(t){return Bi.center.set(0,0,0),Bi.radius=.7071067811865476,Bi.applyMatrix4(t.matrixWorld),this.intersectsSphere(Bi)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Mi.x=s.normal.x>0?t.max.x:t.min.x,Mi.y=s.normal.y>0?t.max.y:t.min.y,Mi.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Mi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Ti(){let t=null,e=!1,i=null,s=null;function n(e,r){i(e,r),s=t.requestAnimationFrame(n)}return{start:function(){!0!==e&&null!==i&&(s=t.requestAnimationFrame(n),e=!0)},stop:function(){t.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(t){i=t},setContext:function(e){t=e}}}function Pi(t,e){const i=e.isWebGL2,s=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),s.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const i=s.get(e);i&&(t.deleteBuffer(i.buffer),s.delete(e))},update:function(e,n){if(e.isGLBufferAttribute){const t=s.get(e);return void((!t||t.version<e.version)&&s.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const r=s.get(e);void 0===r?s.set(e,function(e,s){const n=e.array,r=e.usage,o=t.createBuffer();t.bindBuffer(s,o),t.bufferData(s,n,r),e.onUploadCallback();let a=5126;return n instanceof Float32Array?a=5126:n instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):n instanceof Uint16Array?e.isFloat16BufferAttribute?i?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:n instanceof Int16Array?a=5122:n instanceof Uint32Array?a=5125:n instanceof Int32Array?a=5124:n instanceof Int8Array?a=5120:(n instanceof Uint8Array||n instanceof Uint8ClampedArray)&&(a=5121),{buffer:o,type:a,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version}}(e,n)):r.version<e.version&&(function(e,s,n){const r=s.array,o=s.updateRange;t.bindBuffer(n,e),-1===o.count?t.bufferSubData(n,0,r):(i?t.bufferSubData(n,o.offset*r.BYTES_PER_ELEMENT,r,o.offset,o.count):t.bufferSubData(n,o.offset*r.BYTES_PER_ELEMENT,r.subarray(o.offset,o.offset+o.count)),o.count=-1)}(r.buffer,e,n),r.version=e.version)}}}class Di extends He{constructor(t=1,e=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:s};const n=t/2,r=e/2,o=Math.floor(i),a=Math.floor(s),l=o+1,h=a+1,c=t/o,m=e/a,u=[],_=[],d=[],p=[];for(let t=0;t<h;t++){const e=t*m-r;for(let i=0;i<l;i++){const s=i*c-n;_.push(s,-e,0),d.push(0,0,1),p.push(i/o),p.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<o;e++){const i=e+l*t,s=e+l*(t+1),n=e+1+l*(t+1),r=e+1+l*t;u.push(i,s,r),u.push(s,n,r)}this.setIndex(u),this.setAttribute("position",new Fe(_,3)),this.setAttribute("normal",new Fe(d,3)),this.setAttribute("uv",new Fe(p,2))}static fromJSON(t){return new Di(t.width,t.height,t.widthSegments,t.heightSegments)}}const Ii={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},Ei={common:{diffuse:{value:new rt(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Y},uv2Transform:{value:new Y},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Z(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new rt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new rt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Y}},sprite:{diffuse:{value:new rt(16777215)},opacity:{value:1},center:{value:new Z(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Y}}},Ri={basic:{uniforms:_i([Ei.common,Ei.specularmap,Ei.envmap,Ei.aomap,Ei.lightmap,Ei.fog]),vertexShader:Ii.meshbasic_vert,fragmentShader:Ii.meshbasic_frag},lambert:{uniforms:_i([Ei.common,Ei.specularmap,Ei.envmap,Ei.aomap,Ei.lightmap,Ei.emissivemap,Ei.fog,Ei.lights,{emissive:{value:new rt(0)}}]),vertexShader:Ii.meshlambert_vert,fragmentShader:Ii.meshlambert_frag},phong:{uniforms:_i([Ei.common,Ei.specularmap,Ei.envmap,Ei.aomap,Ei.lightmap,Ei.emissivemap,Ei.bumpmap,Ei.normalmap,Ei.displacementmap,Ei.fog,Ei.lights,{emissive:{value:new rt(0)},specular:{value:new rt(1118481)},shininess:{value:30}}]),vertexShader:Ii.meshphong_vert,fragmentShader:Ii.meshphong_frag},standard:{uniforms:_i([Ei.common,Ei.envmap,Ei.aomap,Ei.lightmap,Ei.emissivemap,Ei.bumpmap,Ei.normalmap,Ei.displacementmap,Ei.roughnessmap,Ei.metalnessmap,Ei.fog,Ei.lights,{emissive:{value:new rt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ii.meshphysical_vert,fragmentShader:Ii.meshphysical_frag},toon:{uniforms:_i([Ei.common,Ei.aomap,Ei.lightmap,Ei.emissivemap,Ei.bumpmap,Ei.normalmap,Ei.displacementmap,Ei.gradientmap,Ei.fog,Ei.lights,{emissive:{value:new rt(0)}}]),vertexShader:Ii.meshtoon_vert,fragmentShader:Ii.meshtoon_frag},matcap:{uniforms:_i([Ei.common,Ei.bumpmap,Ei.normalmap,Ei.displacementmap,Ei.fog,{matcap:{value:null}}]),vertexShader:Ii.meshmatcap_vert,fragmentShader:Ii.meshmatcap_frag},points:{uniforms:_i([Ei.points,Ei.fog]),vertexShader:Ii.points_vert,fragmentShader:Ii.points_frag},dashed:{uniforms:_i([Ei.common,Ei.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ii.linedashed_vert,fragmentShader:Ii.linedashed_frag},depth:{uniforms:_i([Ei.common,Ei.displacementmap]),vertexShader:Ii.depth_vert,fragmentShader:Ii.depth_frag},normal:{uniforms:_i([Ei.common,Ei.bumpmap,Ei.normalmap,Ei.displacementmap,{opacity:{value:1}}]),vertexShader:Ii.meshnormal_vert,fragmentShader:Ii.meshnormal_frag},sprite:{uniforms:_i([Ei.sprite,Ei.fog]),vertexShader:Ii.sprite_vert,fragmentShader:Ii.sprite_frag},background:{uniforms:{uvTransform:{value:new Y},t2D:{value:null}},vertexShader:Ii.background_vert,fragmentShader:Ii.background_frag},cube:{uniforms:_i([Ei.envmap,{opacity:{value:1}}]),vertexShader:Ii.cube_vert,fragmentShader:Ii.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ii.equirect_vert,fragmentShader:Ii.equirect_frag},distanceRGBA:{uniforms:_i([Ei.common,Ei.displacementmap,{referencePosition:{value:new pt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ii.distanceRGBA_vert,fragmentShader:Ii.distanceRGBA_frag},shadow:{uniforms:_i([Ei.lights,Ei.fog,{color:{value:new rt(0)},opacity:{value:1}}]),vertexShader:Ii.shadow_vert,fragmentShader:Ii.shadow_frag}};function Li(t,e,i,s,r,o){const a=new rt(0);let l,h,c=!0===r?0:1,m=null,u=0,_=null;function d(t,e){i.buffers.color.setClear(t.r,t.g,t.b,e,o)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),c=e,d(a,c)},getClearAlpha:function(){return c},setClearAlpha:function(t){c=t,d(a,c)},render:function(i,r){let o=!1,p=!0===r.isScene?r.background:null;p&&p.isTexture&&(p=e.get(p));const f=t.xr,y=f.getSession&&f.getSession();y&&"additive"===y.environmentBlendMode&&(p=null),null===p?d(a,c):p&&p.isColor&&(d(p,1),o=!0),(t.autoClear||o)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),p&&(p.isCubeTexture||p.mapping===n)?(void 0===h&&(h=new hi(new mi(1,1,1),new pi({name:"BackgroundCubeMaterial",uniforms:ui(Ri.cube.uniforms),vertexShader:Ri.cube.vertexShader,fragmentShader:Ri.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(h)),h.material.uniforms.envMap.value=p,h.material.uniforms.flipEnvMap.value=p.isCubeTexture&&!1===p.isRenderTargetTexture?-1:1,m===p&&u===p.version&&_===t.toneMapping||(h.material.needsUpdate=!0,m=p,u=p.version,_=t.toneMapping),i.unshift(h,h.geometry,h.material,0,0,null)):p&&p.isTexture&&(void 0===l&&(l=new hi(new Di(2,2),new pi({name:"BackgroundMaterial",uniforms:ui(Ri.background.uniforms),vertexShader:Ri.background.vertexShader,fragmentShader:Ri.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(l)),l.material.uniforms.t2D.value=p,!0===p.matrixAutoUpdate&&p.updateMatrix(),l.material.uniforms.uvTransform.value.copy(p.matrix),m===p&&u===p.version&&_===t.toneMapping||(l.material.needsUpdate=!0,m=p,u=p.version,_=t.toneMapping),i.unshift(l,l.geometry,l.material,0,0,null))}}}function Gi(t,e,i,s){const n=t.getParameter(34921),r=s.isWebGL2?null:e.get("OES_vertex_array_object"),o=s.isWebGL2||null!==r,a={},l=u(null);let h=l;function c(e){return s.isWebGL2?t.bindVertexArray(e):r.bindVertexArrayOES(e)}function m(e){return s.isWebGL2?t.deleteVertexArray(e):r.deleteVertexArrayOES(e)}function u(t){const e=[],i=[],s=[];for(let t=0;t<n;t++)e[t]=0,i[t]=0,s[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:i,attributeDivisors:s,object:t,attributes:{},index:null}}function _(){const t=h.newAttributes;for(let e=0,i=t.length;e<i;e++)t[e]=0}function d(t){p(t,0)}function p(i,n){const r=h.newAttributes,o=h.enabledAttributes,a=h.attributeDivisors;r[i]=1,0===o[i]&&(t.enableVertexAttribArray(i),o[i]=1),a[i]!==n&&((s.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](i,n),a[i]=n)}function f(){const e=h.newAttributes,i=h.enabledAttributes;for(let s=0,n=i.length;s<n;s++)i[s]!==e[s]&&(t.disableVertexAttribArray(s),i[s]=0)}function y(e,i,n,r,o,a){!0!==s.isWebGL2||5124!==n&&5125!==n?t.vertexAttribPointer(e,i,n,r,o,a):t.vertexAttribIPointer(e,i,n,o,a)}function g(){x(),h!==l&&(h=l,c(h.object))}function x(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(n,l,m,g,x){let v=!1;if(o){const e=function(e,i,n){const o=!0===n.wireframe;let l=a[e.id];void 0===l&&(l={},a[e.id]=l);let h=l[i.id];void 0===h&&(h={},l[i.id]=h);let c=h[o];return void 0===c&&(c=u(s.isWebGL2?t.createVertexArray():r.createVertexArrayOES()),h[o]=c),c}(g,m,l);h!==e&&(h=e,c(h.object)),v=function(t,e){const i=h.attributes,s=t.attributes;let n=0;for(const t in s){const e=i[t],r=s[t];if(void 0===e)return!0;if(e.attribute!==r)return!0;if(e.data!==r.data)return!0;n++}return h.attributesNum!==n||h.index!==e}(g,x),v&&function(t,e){const i={},s=t.attributes;let n=0;for(const t in s){const e=s[t],r={};r.attribute=e,e.data&&(r.data=e.data),i[t]=r,n++}h.attributes=i,h.attributesNum=n,h.index=e}(g,x)}else{const t=!0===l.wireframe;h.geometry===g.id&&h.program===m.id&&h.wireframe===t||(h.geometry=g.id,h.program=m.id,h.wireframe=t,v=!0)}!0===n.isInstancedMesh&&(v=!0),null!==x&&i.update(x,34963),v&&(function(n,r,o,a){if(!1===s.isWebGL2&&(n.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;_();const l=a.attributes,h=o.getAttributes(),c=r.defaultAttributeValues;for(const e in h){const s=h[e];if(s.location>=0){let r=l[e];if(void 0===r&&("instanceMatrix"===e&&n.instanceMatrix&&(r=n.instanceMatrix),"instanceColor"===e&&n.instanceColor&&(r=n.instanceColor)),void 0!==r){const e=r.normalized,o=r.itemSize,l=i.get(r);if(void 0===l)continue;const h=l.buffer,c=l.type,m=l.bytesPerElement;if(r.isInterleavedBufferAttribute){const i=r.data,l=i.stride,u=r.offset;if(i&&i.isInstancedInterleavedBuffer){for(let t=0;t<s.locationSize;t++)p(s.location+t,i.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=i.meshPerAttribute*i.count)}else for(let t=0;t<s.locationSize;t++)d(s.location+t);t.bindBuffer(34962,h);for(let t=0;t<s.locationSize;t++)y(s.location+t,o/s.locationSize,c,e,l*m,(u+o/s.locationSize*t)*m)}else{if(r.isInstancedBufferAttribute){for(let t=0;t<s.locationSize;t++)p(s.location+t,r.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=r.meshPerAttribute*r.count)}else for(let t=0;t<s.locationSize;t++)d(s.location+t);t.bindBuffer(34962,h);for(let t=0;t<s.locationSize;t++)y(s.location+t,o/s.locationSize,c,e,o*m,o/s.locationSize*t*m)}}else if(void 0!==c){const i=c[e];if(void 0!==i)switch(i.length){case 2:t.vertexAttrib2fv(s.location,i);break;case 3:t.vertexAttrib3fv(s.location,i);break;case 4:t.vertexAttrib4fv(s.location,i);break;default:t.vertexAttrib1fv(s.location,i)}}}}f()}(n,l,m,g),null!==x&&t.bindBuffer(34963,i.get(x).buffer))},reset:g,resetDefaultState:x,dispose:function(){g();for(const t in a){const e=a[t];for(const t in e){const i=e[t];for(const t in i)m(i[t].object),delete i[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;const e=a[t.id];for(const t in e){const i=e[t];for(const t in i)m(i[t].object),delete i[t];delete e[t]}delete a[t.id]},releaseStatesOfProgram:function(t){for(const e in a){const i=a[e];if(void 0===i[t.id])continue;const s=i[t.id];for(const t in s)m(s[t].object),delete s[t];delete i[t.id]}},initAttributes:_,enableAttribute:d,disableUnusedAttributes:f}}function Fi(t,e,i,s){const n=s.isWebGL2;let r;this.setMode=function(t){r=t},this.render=function(e,s){t.drawArrays(r,e,s),i.update(s,r,1)},this.renderInstances=function(s,o,a){if(0===a)return;let l,h;if(n)l=t,h="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[h](r,s,o,a),i.update(o,r,a)}}function ki(t,e,i){let s;function n(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const r="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let o=void 0!==i.precision?i.precision:"highp";const a=n(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=r||e.has("WEBGL_draw_buffers"),h=!0===i.logarithmicDepthBuffer,c=t.getParameter(34930),m=t.getParameter(35660),u=t.getParameter(3379),_=t.getParameter(34076),d=t.getParameter(34921),p=t.getParameter(36347),f=t.getParameter(36348),y=t.getParameter(36349),g=m>0,x=r||e.has("OES_texture_float");return{isWebGL2:r,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===e.has("EXT_texture_filter_anisotropic")){const i=e.get("EXT_texture_filter_anisotropic");s=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:n,precision:o,logarithmicDepthBuffer:h,maxTextures:c,maxVertexTextures:m,maxTextureSize:u,maxCubemapSize:_,maxAttributes:d,maxVertexUniforms:p,maxVaryings:f,maxFragmentUniforms:y,vertexTextures:g,floatFragmentTextures:x,floatVertexTextures:g&&x,maxSamples:r?t.getParameter(36183):0}}function zi(t){const e=this;let i=null,s=0,n=!1,r=!1;const o=new Ai,a=new Y,l={value:null,needsUpdate:!1};function h(){l.value!==i&&(l.value=i,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function c(t,i,s,n){const r=null!==t?t.length:0;let h=null;if(0!==r){if(h=l.value,!0!==n||null===h){const e=s+4*r,n=i.matrixWorldInverse;a.getNormalMatrix(n),(null===h||h.length<e)&&(h=new Float32Array(e));for(let e=0,i=s;e!==r;++e,i+=4)o.copy(t[e]).applyMatrix4(n,a),o.normal.toArray(h,i),h[i+3]=o.constant}l.value=h,l.needsUpdate=!0}return e.numPlanes=r,e.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,r){const o=0!==t.length||e||0!==s||n;return n=e,i=c(t,r,0),s=t.length,o},this.beginShadows=function(){r=!0,c(null)},this.endShadows=function(){r=!1,h()},this.setState=function(e,o,a){const m=e.clippingPlanes,u=e.clipIntersection,_=e.clipShadows,d=t.get(e);if(!n||null===m||0===m.length||r&&!_)r?c(null):h();else{const t=r?0:s,e=4*t;let n=d.clippingState||null;l.value=n,n=c(m,o,e,a);for(let t=0;t!==e;++t)n[t]=i[t];d.clippingState=n,this.numIntersection=u?this.numPlanes:0,this.numPlanes+=t}}}function Oi(t){let i=new WeakMap;function n(t,i){return 303===i?t.mapping=e:304===i&&(t.mapping=s),t}function r(t){const e=t.target;e.removeEventListener("dispose",r);const s=i.get(e);void 0!==s&&(i.delete(e),s.dispose())}return{get:function(e){if(e&&e.isTexture&&!1===e.isRenderTargetTexture){const s=e.mapping;if(303===s||304===s){if(i.has(e))return n(i.get(e).texture,e.mapping);{const s=e.image;if(s&&s.height>0){const o=new Si(s.height/2);return o.fromEquirectangularTexture(t,e),i.set(e,o),e.addEventListener("dispose",r),n(o.texture,e.mapping)}return null}}}return e},dispose:function(){i=new WeakMap}}}Ri.physical={uniforms:_i([Ri.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Z(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new rt(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Z},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new rt(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new rt(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ii.meshphysical_vert,fragmentShader:Ii.meshphysical_frag};class Ni extends fi{constructor(t=-1,e=1,i=1,s=-1,n=.1,r=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=n,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,n,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let n=i-t,r=i+t,o=s+e,a=s-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=t*this.view.offsetX,r=n+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(n,r,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}Ni.prototype.isOrthographicCamera=!0;class Ui extends pi{constructor(t){super(t),this.type="RawShaderMaterial"}}Ui.prototype.isRawShaderMaterial=!0;const Wi=Math.pow(2,8),ji=[.125,.215,.35,.446,.526,.582],Hi=5+ji.length,qi=new Ni,{_lodPlanes:Xi,_sizeLods:Ji,_sigmas:Zi}=is(),Yi=new rt;let Qi=null;const Ki=(1+Math.sqrt(5))/2,$i=1/Ki,ts=[new pt(1,1,1),new pt(-1,1,1),new pt(1,1,-1),new pt(-1,1,-1),new pt(0,Ki,$i),new pt(0,Ki,-$i),new pt($i,0,Ki),new pt(-$i,0,Ki),new pt(Ki,$i,0),new pt(-Ki,$i,0)];class es{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(20),i=new pt(0,1,0);return new Ui({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,i=.1,s=100){Qi=this._renderer.getRenderTarget();const n=this._allocateTargets();return this._sceneToCubeUV(t,i,s,n),e>0&&this._blur(n,0,0,e),this._applyPMREM(n),this._cleanup(n),n}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=os(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=rs(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<Xi.length;t++)Xi[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(Qi),t.scissorTest=!1,ns(t,0,0,t.width,t.height)}_fromTexture(t,e){Qi=this._renderer.getRenderTarget();const i=e||this._allocateTargets(t);return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(t){const e={magFilter:h,minFilter:h,generateMipmaps:!1,type:p,format:y,encoding:P,depthBuffer:!1},i=ss(e);return i.depthBuffer=!t,null===this._pingPongRenderTarget&&(this._pingPongRenderTarget=ss(e)),i}_compileMaterial(t){const e=new hi(Xi[0],t);this._renderer.compile(e,qi)}_sceneToCubeUV(t,e,i,s){const n=new yi(90,1,e,i),r=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,h=a.toneMapping;a.getClearColor(Yi),a.toneMapping=0,a.autoClear=!1;const c=new De({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),m=new hi(new mi,c);let u=!1;const _=t.background;_?_.isColor&&(c.color.copy(_),t.background=null,u=!0):(c.color.copy(Yi),u=!0);for(let e=0;e<6;e++){const i=e%3;0===i?(n.up.set(0,r[e],0),n.lookAt(o[e],0,0)):1===i?(n.up.set(0,0,r[e]),n.lookAt(0,o[e],0)):(n.up.set(0,r[e],0),n.lookAt(0,0,o[e])),ns(s,i*Wi,e>2?Wi:0,Wi,Wi),a.setRenderTarget(s),u&&a.render(m,n),a.render(t,n)}m.geometry.dispose(),m.material.dispose(),a.toneMapping=h,a.autoClear=l,t.background=_}_textureToCubeUV(t,i){const n=this._renderer,r=t.mapping===e||t.mapping===s;r?(null===this._cubemapShader&&(this._cubemapShader=os()),this._cubemapShader.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectShader&&(this._equirectShader=rs());const o=r?this._cubemapShader:this._equirectShader,a=new hi(Xi[0],o),l=o.uniforms;l.envMap.value=t,r||l.texelSize.value.set(1/t.image.width,1/t.image.height),ns(i,0,0,3*Wi,2*Wi),n.setRenderTarget(i),n.render(a,qi)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;for(let e=1;e<Hi;e++){const i=Math.sqrt(Zi[e]*Zi[e]-Zi[e-1]*Zi[e-1]),s=ts[(e-1)%ts.length];this._blur(t,e-1,e,i,s)}e.autoClear=i}_blur(t,e,i,s,n){const r=this._pingPongRenderTarget;this._halfBlur(t,r,e,i,s,"latitudinal",n),this._halfBlur(r,t,i,i,s,"longitudinal",n)}_halfBlur(t,e,i,s,n,r,o){const a=this._renderer,l=this._blurMaterial;"latitudinal"!==r&&"longitudinal"!==r&&console.error("blur direction must be either latitudinal or longitudinal!");const h=new hi(Xi[s],l),c=l.uniforms,m=Ji[i]-1,u=isFinite(n)?Math.PI/(2*m):2*Math.PI/39,_=n/u,d=isFinite(n)?1+Math.floor(3*_):20;d>20&&console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${d} samples when the maximum is set to 20`);const p=[];let f=0;for(let t=0;t<20;++t){const e=t/_,i=Math.exp(-e*e/2);p.push(i),0===t?f+=i:t<d&&(f+=2*i)}for(let t=0;t<p.length;t++)p[t]=p[t]/f;c.envMap.value=t.texture,c.samples.value=d,c.weights.value=p,c.latitudinal.value="latitudinal"===r,o&&(c.poleAxis.value=o),c.dTheta.value=u,c.mipInt.value=8-i;const y=Ji[s];ns(e,3*Math.max(0,Wi-2*y),(0===s?0:2*Wi)+2*y*(s>4?s-8+4:0),3*y,2*y),a.setRenderTarget(e),a.render(h,qi)}}function is(){const t=[],e=[],i=[];let s=8;for(let n=0;n<Hi;n++){const r=Math.pow(2,s);e.push(r);let o=1/r;n>4?o=ji[n-8+4-1]:0===n&&(o=0),i.push(o);const a=1/(r-1),l=-a/2,h=1+a/2,c=[l,l,h,l,h,h,l,l,h,h,l,h],m=6,u=6,_=3,d=2,p=1,f=new Float32Array(_*u*m),y=new Float32Array(d*u*m),g=new Float32Array(p*u*m);for(let t=0;t<m;t++){const e=t%3*2/3-1,i=t>2?0:-1,s=[e,i,0,e+2/3,i,0,e+2/3,i+1,0,e,i,0,e+2/3,i+1,0,e,i+1,0];f.set(s,_*u*t),y.set(c,d*u*t);const n=[t,t,t,t,t,t];g.set(n,p*u*t)}const x=new He;x.setAttribute("position",new Re(f,_)),x.setAttribute("uv",new Re(y,d)),x.setAttribute("faceIndex",new Re(g,p)),t.push(x),s>4&&s--}return{_lodPlanes:t,_sizeLods:e,_sigmas:i}}function ss(t){const e=new ut(3*Wi,3*Wi,t);return e.texture.mapping=n,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function ns(t,e,i,s,n){t.viewport.set(e,i,s,n),t.scissor.set(e,i,s,n)}function rs(){const t=new Z(1,1);return new Ui({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function os(){return new Ui({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function as(t){let i=new WeakMap,n=null;function r(t){const e=t.target;e.removeEventListener("dispose",r);const s=i.get(e);void 0!==s&&(i.delete(e),s.dispose())}return{get:function(o){if(o&&o.isTexture){const a=o.mapping,l=303===a||304===a,h=a===e||a===s;if(l||h){if(o.isRenderTargetTexture&&!0===o.needsPMREMUpdate){o.needsPMREMUpdate=!1;let e=i.get(o);return null===n&&(n=new es(t)),e=l?n.fromEquirectangular(o,e):n.fromCubemap(o,e),i.set(o,e),e.texture}if(i.has(o))return i.get(o).texture;{const e=o.image;if(l&&e&&e.height>0||h&&e&&function(t){let e=0;for(let i=0;i<6;i++)void 0!==t[i]&&e++;return 6===e}(e)){null===n&&(n=new es(t));const e=l?n.fromEquirectangular(o):n.fromCubemap(o);return i.set(o,e),o.addEventListener("dispose",r),e.texture}return null}}}return o},dispose:function(){i=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function ls(t){const e={};function i(i){if(void 0!==e[i])return e[i];let s;switch(i){case"WEBGL_depth_texture":s=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=t.getExtension(i)}return e[i]=s,s}return{has:function(t){return null!==i(t)},init:function(t){t.isWebGL2?i("EXT_color_buffer_float"):(i("WEBGL_depth_texture"),i("OES_texture_float"),i("OES_texture_half_float"),i("OES_texture_half_float_linear"),i("OES_standard_derivatives"),i("OES_element_index_uint"),i("OES_vertex_array_object"),i("ANGLE_instanced_arrays")),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture")},get:function(t){const e=i(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function hs(t,e,i,s){const n={},r=new WeakMap;function o(t){const a=t.target;null!==a.index&&e.remove(a.index);for(const t in a.attributes)e.remove(a.attributes[t]);a.removeEventListener("dispose",o),delete n[a.id];const l=r.get(a);l&&(e.remove(l),r.delete(a)),s.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,i.memory.geometries--}function a(t){const i=[],s=t.index,n=t.attributes.position;let o=0;if(null!==s){const t=s.array;o=s.version;for(let e=0,s=t.length;e<s;e+=3){const s=t[e+0],n=t[e+1],r=t[e+2];i.push(s,n,n,r,r,s)}}else{const t=n.array;o=n.version;for(let e=0,s=t.length/3-1;e<s;e+=3){const t=e+0,s=e+1,n=e+2;i.push(t,s,s,n,n,t)}}const a=new(Q(i)?Ge:Le)(i,1);a.version=o;const l=r.get(t);l&&e.remove(l),r.set(t,a)}return{get:function(t,e){return!0===n[e.id]||(e.addEventListener("dispose",o),n[e.id]=!0,i.memory.geometries++),e},update:function(t){const i=t.attributes;for(const t in i)e.update(i[t],34962);const s=t.morphAttributes;for(const t in s){const i=s[t];for(let t=0,s=i.length;t<s;t++)e.update(i[t],34962)}},getWireframeAttribute:function(t){const e=r.get(t);if(e){const i=t.index;null!==i&&e.version<i.version&&a(t)}else a(t);return r.get(t)}}}function cs(t,e,i,s){const n=s.isWebGL2;let r,o,a;this.setMode=function(t){r=t},this.setIndex=function(t){o=t.type,a=t.bytesPerElement},this.render=function(e,s){t.drawElements(r,s,o,e*a),i.update(s,r,1)},this.renderInstances=function(s,l,h){if(0===h)return;let c,m;if(n)c=t,m="drawElementsInstanced";else if(c=e.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",null===c)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[m](r,l,o,s*a,h),i.update(l,r,h)}}function ms(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,i,s){switch(e.calls++,i){case 4:e.triangles+=s*(t/3);break;case 1:e.lines+=s*(t/2);break;case 3:e.lines+=s*(t-1);break;case 2:e.lines+=s*t;break;case 0:e.points+=s*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}class us extends ht{constructor(t=null,e=1,i=1,s=1){super(null),this.image={data:t,width:e,height:i,depth:s},this.magFilter=l,this.minFilter=l,this.wrapR=o,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}function _s(t,e){return t[0]-e[0]}function ds(t,e){return Math.abs(e[1])-Math.abs(t[1])}function ps(t,e){let i=1;const s=e.isInterleavedBufferAttribute?e.data.array:e.array;s instanceof Int8Array?i=127:s instanceof Int16Array?i=32767:s instanceof Int32Array?i=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",s),t.divideScalar(i)}function fs(t,e,i){const s={},n=new Float32Array(8),r=new WeakMap,o=new pt,a=[];for(let t=0;t<8;t++)a[t]=[t,0];return{update:function(l,h,c,m){const u=l.morphTargetInfluences;if(!0===e.isWebGL2){const s=h.morphAttributes.position.length;let n=r.get(h);if(void 0===n||n.count!==s){void 0!==n&&n.texture.dispose();const t=void 0!==h.morphAttributes.normal,i=h.morphAttributes.position,a=h.morphAttributes.normal||[],l=!0===t?2:1;let c=h.attributes.position.count*l,m=1;c>e.maxTextureSize&&(m=Math.ceil(c/e.maxTextureSize),c=e.maxTextureSize);const u=new Float32Array(c*m*4*s),_=new us(u,c,m,s);_.format=y,_.type=d,_.needsUpdate=!0;const p=4*l;for(let e=0;e<s;e++){const s=i[e],n=a[e],r=c*m*4*e;for(let e=0;e<s.count;e++){o.fromBufferAttribute(s,e),!0===s.normalized&&ps(o,s);const i=e*p;u[r+i+0]=o.x,u[r+i+1]=o.y,u[r+i+2]=o.z,u[r+i+3]=0,!0===t&&(o.fromBufferAttribute(n,e),!0===n.normalized&&ps(o,n),u[r+i+4]=o.x,u[r+i+5]=o.y,u[r+i+6]=o.z,u[r+i+7]=0)}}function f(){_.dispose(),r.delete(h),h.removeEventListener("dispose",f)}n={count:s,texture:_,size:new Z(c,m)},r.set(h,n),h.addEventListener("dispose",f)}let a=0;for(let t=0;t<u.length;t++)a+=u[t];const l=h.morphTargetsRelative?1:1-a;m.getUniforms().setValue(t,"morphTargetBaseInfluence",l),m.getUniforms().setValue(t,"morphTargetInfluences",u),m.getUniforms().setValue(t,"morphTargetsTexture",n.texture,i),m.getUniforms().setValue(t,"morphTargetsTextureSize",n.size)}else{const e=void 0===u?0:u.length;let i=s[h.id];if(void 0===i||i.length!==e){i=[];for(let t=0;t<e;t++)i[t]=[t,0];s[h.id]=i}for(let t=0;t<e;t++){const e=i[t];e[0]=t,e[1]=u[t]}i.sort(ds);for(let t=0;t<8;t++)t<e&&i[t][1]?(a[t][0]=i[t][0],a[t][1]=i[t][1]):(a[t][0]=Number.MAX_SAFE_INTEGER,a[t][1]=0);a.sort(_s);const r=h.morphAttributes.position,o=h.morphAttributes.normal;let l=0;for(let t=0;t<8;t++){const e=a[t],i=e[0],s=e[1];i!==Number.MAX_SAFE_INTEGER&&s?(r&&h.getAttribute("morphTarget"+t)!==r[i]&&h.setAttribute("morphTarget"+t,r[i]),o&&h.getAttribute("morphNormal"+t)!==o[i]&&h.setAttribute("morphNormal"+t,o[i]),n[t]=s,l+=s):(r&&!0===h.hasAttribute("morphTarget"+t)&&h.deleteAttribute("morphTarget"+t),o&&!0===h.hasAttribute("morphNormal"+t)&&h.deleteAttribute("morphNormal"+t),n[t]=0)}const c=h.morphTargetsRelative?1:1-l;m.getUniforms().setValue(t,"morphTargetBaseInfluence",c),m.getUniforms().setValue(t,"morphTargetInfluences",n)}}}}function ys(t,e,i,s){let n=new WeakMap;function r(t){const e=t.target;e.removeEventListener("dispose",r),i.remove(e.instanceMatrix),null!==e.instanceColor&&i.remove(e.instanceColor)}return{update:function(t){const o=s.render.frame,a=t.geometry,l=e.get(t,a);return n.get(l)!==o&&(e.update(l),n.set(l,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",r)&&t.addEventListener("dispose",r),i.update(t.instanceMatrix,34962),null!==t.instanceColor&&i.update(t.instanceColor,34962)),l},dispose:function(){n=new WeakMap}}}us.prototype.isDataTexture2DArray=!0;class gs extends ht{constructor(t=null,e=1,i=1,s=1){super(null),this.image={data:t,width:e,height:i,depth:s},this.magFilter=l,this.minFilter=l,this.wrapR=o,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}gs.prototype.isDataTexture3D=!0;const xs=new ht,vs=new us,Ss=new gs,ws=new vi,bs=[],Cs=[],As=new Float32Array(16),Bs=new Float32Array(9),Ms=new Float32Array(4);function Vs(t,e,i){const s=t[0];if(s<=0||s>0)return t;const n=e*i;let r=bs[n];if(void 0===r&&(r=new Float32Array(n),bs[n]=r),0!==e){s.toArray(r,0);for(let s=1,n=0;s!==e;++s)n+=i,t[s].toArray(r,n)}return r}function Ts(t,e){if(t.length!==e.length)return!1;for(let i=0,s=t.length;i<s;i++)if(t[i]!==e[i])return!1;return!0}function Ps(t,e){for(let i=0,s=e.length;i<s;i++)t[i]=e[i]}function Ds(t,e){let i=Cs[e];void 0===i&&(i=new Int32Array(e),Cs[e]=i);for(let s=0;s!==e;++s)i[s]=t.allocateTextureUnit();return i}function Is(t,e){const i=this.cache;i[0]!==e&&(t.uniform1f(this.addr,e),i[0]=e)}function Es(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Ts(i,e))return;t.uniform2fv(this.addr,e),Ps(i,e)}}function Rs(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(void 0!==e.r)i[0]===e.r&&i[1]===e.g&&i[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(Ts(i,e))return;t.uniform3fv(this.addr,e),Ps(i,e)}}function Ls(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Ts(i,e))return;t.uniform4fv(this.addr,e),Ps(i,e)}}function Gs(t,e){const i=this.cache,s=e.elements;if(void 0===s){if(Ts(i,e))return;t.uniformMatrix2fv(this.addr,!1,e),Ps(i,e)}else{if(Ts(i,s))return;Ms.set(s),t.uniformMatrix2fv(this.addr,!1,Ms),Ps(i,s)}}function Fs(t,e){const i=this.cache,s=e.elements;if(void 0===s){if(Ts(i,e))return;t.uniformMatrix3fv(this.addr,!1,e),Ps(i,e)}else{if(Ts(i,s))return;Bs.set(s),t.uniformMatrix3fv(this.addr,!1,Bs),Ps(i,s)}}function ks(t,e){const i=this.cache,s=e.elements;if(void 0===s){if(Ts(i,e))return;t.uniformMatrix4fv(this.addr,!1,e),Ps(i,e)}else{if(Ts(i,s))return;As.set(s),t.uniformMatrix4fv(this.addr,!1,As),Ps(i,s)}}function zs(t,e){const i=this.cache;i[0]!==e&&(t.uniform1i(this.addr,e),i[0]=e)}function Os(t,e){const i=this.cache;Ts(i,e)||(t.uniform2iv(this.addr,e),Ps(i,e))}function Ns(t,e){const i=this.cache;Ts(i,e)||(t.uniform3iv(this.addr,e),Ps(i,e))}function Us(t,e){const i=this.cache;Ts(i,e)||(t.uniform4iv(this.addr,e),Ps(i,e))}function Ws(t,e){const i=this.cache;i[0]!==e&&(t.uniform1ui(this.addr,e),i[0]=e)}function js(t,e){const i=this.cache;Ts(i,e)||(t.uniform2uiv(this.addr,e),Ps(i,e))}function Hs(t,e){const i=this.cache;Ts(i,e)||(t.uniform3uiv(this.addr,e),Ps(i,e))}function qs(t,e){const i=this.cache;Ts(i,e)||(t.uniform4uiv(this.addr,e),Ps(i,e))}function Xs(t,e,i){const s=this.cache,n=i.allocateTextureUnit();s[0]!==n&&(t.uniform1i(this.addr,n),s[0]=n),i.safeSetTexture2D(e||xs,n)}function Js(t,e,i){const s=this.cache,n=i.allocateTextureUnit();s[0]!==n&&(t.uniform1i(this.addr,n),s[0]=n),i.setTexture3D(e||Ss,n)}function Zs(t,e,i){const s=this.cache,n=i.allocateTextureUnit();s[0]!==n&&(t.uniform1i(this.addr,n),s[0]=n),i.safeSetTextureCube(e||ws,n)}function Ys(t,e,i){const s=this.cache,n=i.allocateTextureUnit();s[0]!==n&&(t.uniform1i(this.addr,n),s[0]=n),i.setTexture2DArray(e||vs,n)}function Qs(t,e){t.uniform1fv(this.addr,e)}function Ks(t,e){const i=Vs(e,this.size,2);t.uniform2fv(this.addr,i)}function $s(t,e){const i=Vs(e,this.size,3);t.uniform3fv(this.addr,i)}function tn(t,e){const i=Vs(e,this.size,4);t.uniform4fv(this.addr,i)}function en(t,e){const i=Vs(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,i)}function sn(t,e){const i=Vs(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,i)}function nn(t,e){const i=Vs(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,i)}function rn(t,e){t.uniform1iv(this.addr,e)}function on(t,e){t.uniform2iv(this.addr,e)}function an(t,e){t.uniform3iv(this.addr,e)}function ln(t,e){t.uniform4iv(this.addr,e)}function hn(t,e){t.uniform1uiv(this.addr,e)}function cn(t,e){t.uniform2uiv(this.addr,e)}function mn(t,e){t.uniform3uiv(this.addr,e)}function un(t,e){t.uniform4uiv(this.addr,e)}function _n(t,e,i){const s=e.length,n=Ds(i,s);t.uniform1iv(this.addr,n);for(let t=0;t!==s;++t)i.safeSetTexture2D(e[t]||xs,n[t])}function dn(t,e,i){const s=e.length,n=Ds(i,s);t.uniform1iv(this.addr,n);for(let t=0;t!==s;++t)i.setTexture3D(e[t]||Ss,n[t])}function pn(t,e,i){const s=e.length,n=Ds(i,s);t.uniform1iv(this.addr,n);for(let t=0;t!==s;++t)i.safeSetTextureCube(e[t]||ws,n[t])}function fn(t,e,i){const s=e.length,n=Ds(i,s);t.uniform1iv(this.addr,n);for(let t=0;t!==s;++t)i.setTexture2DArray(e[t]||vs,n[t])}function yn(t,e,i){this.id=t,this.addr=i,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Is;case 35664:return Es;case 35665:return Rs;case 35666:return Ls;case 35674:return Gs;case 35675:return Fs;case 35676:return ks;case 5124:case 35670:return zs;case 35667:case 35671:return Os;case 35668:case 35672:return Ns;case 35669:case 35673:return Us;case 5125:return Ws;case 36294:return js;case 36295:return Hs;case 36296:return qs;case 35678:case 36198:case 36298:case 36306:case 35682:return Xs;case 35679:case 36299:case 36307:return Js;case 35680:case 36300:case 36308:case 36293:return Zs;case 36289:case 36303:case 36311:case 36292:return Ys}}(e.type)}function gn(t,e,i){this.id=t,this.addr=i,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Qs;case 35664:return Ks;case 35665:return $s;case 35666:return tn;case 35674:return en;case 35675:return sn;case 35676:return nn;case 5124:case 35670:return rn;case 35667:case 35671:return on;case 35668:case 35672:return an;case 35669:case 35673:return ln;case 5125:return hn;case 36294:return cn;case 36295:return mn;case 36296:return un;case 35678:case 36198:case 36298:case 36306:case 35682:return _n;case 35679:case 36299:case 36307:return dn;case 35680:case 36300:case 36308:case 36293:return pn;case 36289:case 36303:case 36311:case 36292:return fn}}(e.type)}function xn(t){this.id=t,this.seq=[],this.map={}}gn.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),Ps(e,t)},xn.prototype.setValue=function(t,e,i){const s=this.seq;for(let n=0,r=s.length;n!==r;++n){const r=s[n];r.setValue(t,e[r.id],i)}};const vn=/(\w+)(\])?(\[|\.)?/g;function Sn(t,e){t.seq.push(e),t.map[e.id]=e}function wn(t,e,i){const s=t.name,n=s.length;for(vn.lastIndex=0;;){const r=vn.exec(s),o=vn.lastIndex;let a=r[1];const l="]"===r[2],h=r[3];if(l&&(a|=0),void 0===h||"["===h&&o+2===n){Sn(i,void 0===h?new yn(a,t,e):new gn(a,t,e));break}{let t=i.map[a];void 0===t&&(t=new xn(a),Sn(i,t)),i=t}}}function bn(t,e){this.seq=[],this.map={};const i=t.getProgramParameter(e,35718);for(let s=0;s<i;++s){const i=t.getActiveUniform(e,s);wn(i,t.getUniformLocation(e,i.name),this)}}function Cn(t,e,i){const s=t.createShader(e);return t.shaderSource(s,i),t.compileShader(s),s}bn.prototype.setValue=function(t,e,i,s){const n=this.map[e];void 0!==n&&n.setValue(t,i,s)},bn.prototype.setOptional=function(t,e,i){const s=e[i];void 0!==s&&this.setValue(t,i,s)},bn.upload=function(t,e,i,s){for(let n=0,r=e.length;n!==r;++n){const r=e[n],o=i[r.id];!1!==o.needsUpdate&&r.setValue(t,o.value,s)}},bn.seqWithValue=function(t,e){const i=[];for(let s=0,n=t.length;s!==n;++s){const n=t[s];n.id in e&&i.push(n)}return i};let An=0;function Bn(t,e,i){const s=t.getShaderParameter(e,35713),n=t.getShaderInfoLog(e).trim();return s&&""===n?"":i.toUpperCase()+"\n\n"+n+"\n\n"+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function Mn(t,e){const i=function(t){switch(t){case P:return["Linear","( value )"];case D:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+i[0]+i[1]+"; }"}function Vn(t,e){let i;switch(e){case 1:i="Linear";break;case 2:i="Reinhard";break;case 3:i="OptimizedCineon";break;case 4:i="ACESFilmic";break;case 5:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),i="Linear"}return"vec3 "+t+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}function Tn(t){return""!==t}function Pn(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Dn(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const In=/^[ \t]*#include +<([\w\d./]+)>/gm;function En(t){return t.replace(In,Rn)}function Rn(t,e){const i=Ii[e];if(void 0===i)throw new Error("Can not resolve #include <"+e+">");return En(i)}const Ln=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Gn=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Fn(t){return t.replace(Gn,zn).replace(Ln,kn)}function kn(t,e,i,s){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),zn(0,e,i,s)}function zn(t,e,i,s){let n="";for(let t=parseInt(e);t<parseInt(i);t++)n+=s.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return n}function On(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Nn(t,i,r,o){const a=t.getContext(),l=r.defines;let h=r.vertexShader,c=r.fragmentShader;const m=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(r),u=function(t){let i="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case e:case s:i="ENVMAP_TYPE_CUBE";break;case n:case 307:i="ENVMAP_TYPE_CUBE_UV"}return i}(r),_=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case s:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(r),d=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(r),p=r.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Tn).join("\n")}(r),f=function(t){const e=[];for(const i in t){const s=t[i];!1!==s&&e.push("#define "+i+" "+s)}return e.join("\n")}(l),y=a.createProgram();let g,x,v=r.glslVersion?"#version "+r.glslVersion+"\n":"";r.isRawShaderMaterial?(g=[f].filter(Tn).join("\n"),g.length>0&&(g+="\n"),x=[p,f].filter(Tn).join("\n"),x.length>0&&(x+="\n")):(g=[On(r),"#define SHADER_NAME "+r.shaderName,f,r.instancing?"#define USE_INSTANCING":"",r.instancingColor?"#define USE_INSTANCING_COLOR":"",r.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+r.maxBones,r.useFog&&r.fog?"#define USE_FOG":"",r.useFog&&r.fogExp2?"#define FOG_EXP2":"",r.map?"#define USE_MAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+_:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.normalMap&&r.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",r.normalMap&&r.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",r.clearcoatMap?"#define USE_CLEARCOATMAP":"",r.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",r.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",r.displacementMap&&r.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",r.specularColorMap?"#define USE_SPECULARCOLORMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.transmission?"#define USE_TRANSMISSION":"",r.transmissionMap?"#define USE_TRANSMISSIONMAP":"",r.thicknessMap?"#define USE_THICKNESSMAP":"",r.sheenColorMap?"#define USE_SHEENCOLORMAP":"",r.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",r.vertexTangents?"#define USE_TANGENT":"",r.vertexColors?"#define USE_COLOR":"",r.vertexAlphas?"#define USE_COLOR_ALPHA":"",r.vertexUvs?"#define USE_UV":"",r.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",r.flatShading?"#define FLAT_SHADED":"",r.skinning?"#define USE_SKINNING":"",r.useVertexTexture?"#define BONE_TEXTURE":"",r.morphTargets?"#define USE_MORPHTARGETS":"",r.morphNormals&&!1===r.flatShading?"#define USE_MORPHNORMALS":"",r.morphTargets&&r.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",r.morphTargets&&r.isWebGL2?"#define MORPHTARGETS_COUNT "+r.morphTargetsCount:"",r.doubleSided?"#define DOUBLE_SIDED":"",r.flipSided?"#define FLIP_SIDED":"",r.shadowMapEnabled?"#define USE_SHADOWMAP":"",r.shadowMapEnabled?"#define "+m:"",r.sizeAttenuation?"#define USE_SIZEATTENUATION":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&r.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Tn).join("\n"),x=[p,On(r),"#define SHADER_NAME "+r.shaderName,f,r.useFog&&r.fog?"#define USE_FOG":"",r.useFog&&r.fogExp2?"#define FOG_EXP2":"",r.map?"#define USE_MAP":"",r.matcap?"#define USE_MATCAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+u:"",r.envMap?"#define "+_:"",r.envMap?"#define "+d:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.normalMap&&r.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",r.normalMap&&r.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",r.clearcoat?"#define USE_CLEARCOAT":"",r.clearcoatMap?"#define USE_CLEARCOATMAP":"",r.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",r.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",r.specularColorMap?"#define USE_SPECULARCOLORMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.alphaTest?"#define USE_ALPHATEST":"",r.sheen?"#define USE_SHEEN":"",r.sheenColorMap?"#define USE_SHEENCOLORMAP":"",r.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",r.transmission?"#define USE_TRANSMISSION":"",r.transmissionMap?"#define USE_TRANSMISSIONMAP":"",r.thicknessMap?"#define USE_THICKNESSMAP":"",r.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",r.vertexTangents?"#define USE_TANGENT":"",r.vertexColors||r.instancingColor?"#define USE_COLOR":"",r.vertexAlphas?"#define USE_COLOR_ALPHA":"",r.vertexUvs?"#define USE_UV":"",r.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",r.gradientMap?"#define USE_GRADIENTMAP":"",r.flatShading?"#define FLAT_SHADED":"",r.doubleSided?"#define DOUBLE_SIDED":"",r.flipSided?"#define FLIP_SIDED":"",r.shadowMapEnabled?"#define USE_SHADOWMAP":"",r.shadowMapEnabled?"#define "+m:"",r.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",r.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&r.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(r.extensionShaderTextureLOD||r.envMap)&&r.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==r.toneMapping?"#define TONE_MAPPING":"",0!==r.toneMapping?Ii.tonemapping_pars_fragment:"",0!==r.toneMapping?Vn("toneMapping",r.toneMapping):"",r.dithering?"#define DITHERING":"",r.transparent?"":"#define OPAQUE",Ii.encodings_pars_fragment,Mn("linearToOutputTexel",r.outputEncoding),r.depthPacking?"#define DEPTH_PACKING "+r.depthPacking:"","\n"].filter(Tn).join("\n")),h=En(h),h=Pn(h,r),h=Dn(h,r),c=En(c),c=Pn(c,r),c=Dn(c,r),h=Fn(h),c=Fn(c),r.isWebGL2&&!0!==r.isRawShaderMaterial&&(v="#version 300 es\n",g=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,x=["#define varying in",r.glslVersion===L?"":"layout(location = 0) out highp vec4 pc_fragColor;",r.glslVersion===L?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+x);const S=v+x+c,w=Cn(a,35633,v+g+h),b=Cn(a,35632,S);if(a.attachShader(y,w),a.attachShader(y,b),void 0!==r.index0AttributeName?a.bindAttribLocation(y,0,r.index0AttributeName):!0===r.morphTargets&&a.bindAttribLocation(y,0,"position"),a.linkProgram(y),t.debug.checkShaderErrors){const t=a.getProgramInfoLog(y).trim(),e=a.getShaderInfoLog(w).trim(),i=a.getShaderInfoLog(b).trim();let s=!0,n=!0;if(!1===a.getProgramParameter(y,35714)){s=!1;const e=Bn(a,w,"vertex"),i=Bn(a,b,"fragment");console.error("THREE.WebGLProgram: Shader Error "+a.getError()+" - VALIDATE_STATUS "+a.getProgramParameter(y,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+i)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==i||(n=!1);n&&(this.diagnostics={runnable:s,programLog:t,vertexShader:{log:e,prefix:g},fragmentShader:{log:i,prefix:x}})}let C,A;return a.deleteShader(w),a.deleteShader(b),this.getUniforms=function(){return void 0===C&&(C=new bn(a,y)),C},this.getAttributes=function(){return void 0===A&&(A=function(t,e){const i={},s=t.getProgramParameter(e,35721);for(let n=0;n<s;n++){const s=t.getActiveAttrib(e,n),r=s.name;let o=1;35674===s.type&&(o=2),35675===s.type&&(o=3),35676===s.type&&(o=4),i[r]={type:s.type,location:t.getAttribLocation(e,r),locationSize:o}}return i}(a,y)),A},this.destroy=function(){o.releaseStatesOfProgram(this),a.deleteProgram(y),this.program=void 0},this.name=r.shaderName,this.id=An++,this.cacheKey=i,this.usedTimes=1,this.program=y,this.vertexShader=w,this.fragmentShader=b,this}let Un=0;class Wn{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,s=this._getShaderStage(e),n=this._getShaderStage(i),r=this._getShaderCacheForMaterial(t);return!1===r.has(s)&&(r.add(s),s.usedTimes++),!1===r.has(n)&&(r.add(n),n.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return!1===e.has(t)&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(!1===e.has(t)){const i=new jn;e.set(t,i)}return e.get(t)}}class jn{constructor(){this.id=Un++,this.usedTimes=0}}function Hn(t,e,i,s,r,o,a){const l=new se,h=new Wn,c=[],m=r.isWebGL2,u=r.logarithmicDepthBuffer,_=r.floatVertexTextures,d=r.maxVertexUniforms,p=r.vertexTextures;let f=r.precision;const y={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(o,l,c,g,x){const v=g.fog,S=o.isMeshStandardMaterial?g.environment:null,w=(o.isMeshStandardMaterial?i:e).get(o.envMap||S),b=y[o.type],C=x.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(_)return 1024;{const t=d,i=Math.floor((t-20)/4),s=Math.min(i,e.length);return s<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+s+"."),0):s}}(x):0;let A,B,M,V;if(null!==o.precision&&(f=r.getMaxPrecision(o.precision),f!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",f,"instead.")),b){const t=Ri[b];A=t.vertexShader,B=t.fragmentShader}else A=o.vertexShader,B=o.fragmentShader,h.update(o),M=h.getVertexShaderID(o),V=h.getFragmentShaderID(o);const T=t.getRenderTarget(),I=o.alphaTest>0,E=o.clearcoat>0;return{isWebGL2:m,shaderID:b,shaderName:o.type,vertexShader:A,fragmentShader:B,defines:o.defines,customVertexShaderID:M,customFragmentShaderID:V,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:f,instancing:!0===x.isInstancedMesh,instancingColor:!0===x.isInstancedMesh&&null!==x.instanceColor,supportsVertexTextures:p,outputEncoding:null===T?t.outputEncoding:!0===T.isXRRenderTarget?T.texture.encoding:P,map:!!o.map,matcap:!!o.matcap,envMap:!!w,envMapMode:w&&w.mapping,envMapCubeUV:!!w&&(w.mapping===n||307===w.mapping),lightMap:!!o.lightMap,aoMap:!!o.aoMap,emissiveMap:!!o.emissiveMap,bumpMap:!!o.bumpMap,normalMap:!!o.normalMap,objectSpaceNormalMap:1===o.normalMapType,tangentSpaceNormalMap:0===o.normalMapType,decodeVideoTexture:!!o.map&&!0===o.map.isVideoTexture&&o.map.encoding===D,clearcoat:E,clearcoatMap:E&&!!o.clearcoatMap,clearcoatRoughnessMap:E&&!!o.clearcoatRoughnessMap,clearcoatNormalMap:E&&!!o.clearcoatNormalMap,displacementMap:!!o.displacementMap,roughnessMap:!!o.roughnessMap,metalnessMap:!!o.metalnessMap,specularMap:!!o.specularMap,specularIntensityMap:!!o.specularIntensityMap,specularColorMap:!!o.specularColorMap,transparent:o.transparent,alphaMap:!!o.alphaMap,alphaTest:I,gradientMap:!!o.gradientMap,sheen:o.sheen>0,sheenColorMap:!!o.sheenColorMap,sheenRoughnessMap:!!o.sheenRoughnessMap,transmission:o.transmission>0,transmissionMap:!!o.transmissionMap,thicknessMap:!!o.thicknessMap,combine:o.combine,vertexTangents:!!o.normalMap&&!!x.geometry&&!!x.geometry.attributes.tangent,vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&!!x.geometry&&!!x.geometry.attributes.color&&4===x.geometry.attributes.color.itemSize,vertexUvs:!!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatMap||o.clearcoatRoughnessMap||o.clearcoatNormalMap||o.displacementMap||o.transmissionMap||o.thicknessMap||o.specularIntensityMap||o.specularColorMap||o.sheenColorMap||o.sheenRoughnessMap),uvsVertexOnly:!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatNormalMap||o.transmission>0||o.transmissionMap||o.thicknessMap||o.specularIntensityMap||o.specularColorMap||o.sheen>0||o.sheenColorMap||o.sheenRoughnessMap||!o.displacementMap),fog:!!v,useFog:o.fog,fogExp2:v&&v.isFogExp2,flatShading:!!o.flatShading,sizeAttenuation:o.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===x.isSkinnedMesh&&C>0,maxBones:C,useVertexTexture:_,morphTargets:!!x.geometry&&!!x.geometry.morphAttributes.position,morphNormals:!!x.geometry&&!!x.geometry.morphAttributes.normal,morphTargetsCount:x.geometry&&x.geometry.morphAttributes.position?x.geometry.morphAttributes.position.length:0,numDirLights:l.directional.length,numPointLights:l.point.length,numSpotLights:l.spot.length,numRectAreaLights:l.rectArea.length,numHemiLights:l.hemi.length,numDirLightShadows:l.directionalShadowMap.length,numPointLightShadows:l.pointShadowMap.length,numSpotLightShadows:l.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:o.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:o.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:o.premultipliedAlpha,doubleSided:2===o.side,flipSided:1===o.side,depthPacking:void 0!==o.depthPacking&&o.depthPacking,index0AttributeName:o.index0AttributeName,extensionDerivatives:o.extensions&&o.extensions.derivatives,extensionFragDepth:o.extensions&&o.extensions.fragDepth,extensionDrawBuffers:o.extensions&&o.extensions.drawBuffers,extensionShaderTextureLOD:o.extensions&&o.extensions.shaderTextureLOD,rendererExtensionFragDepth:m||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:m||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:m||s.has("EXT_shader_texture_lod"),customProgramCacheKey:o.customProgramCacheKey()}},getProgramCacheKey:function(e){const i=[];if(e.shaderID?i.push(e.shaderID):(i.push(e.customVertexShaderID),i.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)i.push(t),i.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputEncoding),t.push(e.envMapMode),t.push(e.combine),t.push(e.vertexUvs),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.maxBones),t.push(e.morphTargetsCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection)}(i,e),function(t,e){l.disableAll(),e.isWebGL2&&l.enable(0),e.supportsVertexTextures&&l.enable(1),e.instancing&&l.enable(2),e.instancingColor&&l.enable(3),e.map&&l.enable(4),e.matcap&&l.enable(5),e.envMap&&l.enable(6),e.envMapCubeUV&&l.enable(7),e.lightMap&&l.enable(8),e.aoMap&&l.enable(9),e.emissiveMap&&l.enable(10),e.bumpMap&&l.enable(11),e.normalMap&&l.enable(12),e.objectSpaceNormalMap&&l.enable(13),e.tangentSpaceNormalMap&&l.enable(14),e.clearcoat&&l.enable(15),e.clearcoatMap&&l.enable(16),e.clearcoatRoughnessMap&&l.enable(17),e.clearcoatNormalMap&&l.enable(18),e.displacementMap&&l.enable(19),e.specularMap&&l.enable(20),e.roughnessMap&&l.enable(21),e.metalnessMap&&l.enable(22),e.gradientMap&&l.enable(23),e.alphaMap&&l.enable(24),e.alphaTest&&l.enable(25),e.vertexColors&&l.enable(26),e.vertexAlphas&&l.enable(27),e.vertexUvs&&l.enable(28),e.vertexTangents&&l.enable(29),e.uvsVertexOnly&&l.enable(30),e.fog&&l.enable(31),t.push(l.mask),l.disableAll(),e.useFog&&l.enable(0),e.flatShading&&l.enable(1),e.logarithmicDepthBuffer&&l.enable(2),e.skinning&&l.enable(3),e.useVertexTexture&&l.enable(4),e.morphTargets&&l.enable(5),e.morphNormals&&l.enable(6),e.premultipliedAlpha&&l.enable(7),e.shadowMapEnabled&&l.enable(8),e.physicallyCorrectLights&&l.enable(9),e.doubleSided&&l.enable(10),e.flipSided&&l.enable(11),e.depthPacking&&l.enable(12),e.dithering&&l.enable(13),e.specularIntensityMap&&l.enable(14),e.specularColorMap&&l.enable(15),e.transmission&&l.enable(16),e.transmissionMap&&l.enable(17),e.thicknessMap&&l.enable(18),e.sheen&&l.enable(19),e.sheenColorMap&&l.enable(20),e.sheenRoughnessMap&&l.enable(21),e.decodeVideoTexture&&l.enable(22),e.transparent&&l.enable(23),t.push(l.mask)}(i,e),i.push(t.outputEncoding)),i.push(e.customProgramCacheKey),i.join()},getUniforms:function(t){const e=y[t.type];let i;if(e){const t=Ri[e];i=di.clone(t.uniforms)}else i=t.uniforms;return i},acquireProgram:function(e,i){let s;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.cacheKey===i){s=e,++s.usedTimes;break}}return void 0===s&&(s=new Nn(t,i,e,o),c.push(s)),s},releaseProgram:function(t){if(0==--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){h.remove(t)},programs:c,dispose:function(){h.dispose()}}}function qn(){let t=new WeakMap;return{get:function(e){let i=t.get(e);return void 0===i&&(i={},t.set(e,i)),i},remove:function(e){t.delete(e)},update:function(e,i,s){t.get(e)[i]=s},dispose:function(){t=new WeakMap}}}function Xn(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Jn(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Zn(){const t=[];let e=0;const i=[],s=[],n=[];function r(i,s,n,r,o,a){let l=t[e];return void 0===l?(l={id:i.id,object:i,geometry:s,material:n,groupOrder:r,renderOrder:i.renderOrder,z:o,group:a},t[e]=l):(l.id=i.id,l.object=i,l.geometry=s,l.material=n,l.groupOrder=r,l.renderOrder=i.renderOrder,l.z=o,l.group=a),e++,l}return{opaque:i,transmissive:s,transparent:n,init:function(){e=0,i.length=0,s.length=0,n.length=0},push:function(t,e,o,a,l,h){const c=r(t,e,o,a,l,h);o.transmission>0?s.push(c):!0===o.transparent?n.push(c):i.push(c)},unshift:function(t,e,o,a,l,h){const c=r(t,e,o,a,l,h);o.transmission>0?s.unshift(c):!0===o.transparent?n.unshift(c):i.unshift(c)},finish:function(){for(let i=e,s=t.length;i<s;i++){const e=t[i];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Xn),s.length>1&&s.sort(e||Jn),n.length>1&&n.sort(e||Jn)}}}function Yn(){let t=new WeakMap;return{get:function(e,i){let s;return!1===t.has(e)?(s=new Zn,t.set(e,[s])):i>=t.get(e).length?(s=new Zn,t.get(e).push(s)):s=t.get(e)[i],s},dispose:function(){t=new WeakMap}}}function Qn(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":i={direction:new pt,color:new rt};break;case"SpotLight":i={position:new pt,direction:new pt,color:new rt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new pt,color:new rt,distance:0,decay:0};break;case"HemisphereLight":i={direction:new pt,skyColor:new rt,groundColor:new rt};break;case"RectAreaLight":i={color:new rt,position:new pt,halfWidth:new pt,halfHeight:new pt}}return t[e.id]=i,i}}}let Kn=0;function $n(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function tr(t,e){const i=new Qn,s=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Z};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Z,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=i,i}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)n.probe.push(new pt);const r=new pt,o=new qt,a=new qt;return{setup:function(r,o){let a=0,l=0,h=0;for(let t=0;t<9;t++)n.probe[t].set(0,0,0);let c=0,m=0,u=0,_=0,d=0,p=0,f=0,y=0;r.sort($n);const g=!0!==o?Math.PI:1;for(let t=0,e=r.length;t<e;t++){const e=r[t],o=e.color,x=e.intensity,v=e.distance,S=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)a+=o.r*x*g,l+=o.g*x*g,h+=o.b*x*g;else if(e.isLightProbe)for(let t=0;t<9;t++)n.probe[t].addScaledVector(e.sh.coefficients[t],x);else if(e.isDirectionalLight){const t=i.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*g),e.castShadow){const t=e.shadow,i=s.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,n.directionalShadow[c]=i,n.directionalShadowMap[c]=S,n.directionalShadowMatrix[c]=e.shadow.matrix,p++}n.directional[c]=t,c++}else if(e.isSpotLight){const t=i.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(o).multiplyScalar(x*g),t.distance=v,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,i=s.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,n.spotShadow[u]=i,n.spotShadowMap[u]=S,n.spotShadowMatrix[u]=e.shadow.matrix,y++}n.spot[u]=t,u++}else if(e.isRectAreaLight){const t=i.get(e);t.color.copy(o).multiplyScalar(x),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),n.rectArea[_]=t,_++}else if(e.isPointLight){const t=i.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*g),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,i=s.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,i.shadowCameraNear=t.camera.near,i.shadowCameraFar=t.camera.far,n.pointShadow[m]=i,n.pointShadowMap[m]=S,n.pointShadowMatrix[m]=e.shadow.matrix,f++}n.point[m]=t,m++}else if(e.isHemisphereLight){const t=i.get(e);t.skyColor.copy(e.color).multiplyScalar(x*g),t.groundColor.copy(e.groundColor).multiplyScalar(x*g),n.hemi[d]=t,d++}}_>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(n.rectAreaLTC1=Ei.LTC_FLOAT_1,n.rectAreaLTC2=Ei.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(n.rectAreaLTC1=Ei.LTC_HALF_1,n.rectAreaLTC2=Ei.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=a,n.ambient[1]=l,n.ambient[2]=h;const x=n.hash;x.directionalLength===c&&x.pointLength===m&&x.spotLength===u&&x.rectAreaLength===_&&x.hemiLength===d&&x.numDirectionalShadows===p&&x.numPointShadows===f&&x.numSpotShadows===y||(n.directional.length=c,n.spot.length=u,n.rectArea.length=_,n.point.length=m,n.hemi.length=d,n.directionalShadow.length=p,n.directionalShadowMap.length=p,n.pointShadow.length=f,n.pointShadowMap.length=f,n.spotShadow.length=y,n.spotShadowMap.length=y,n.directionalShadowMatrix.length=p,n.pointShadowMatrix.length=f,n.spotShadowMatrix.length=y,x.directionalLength=c,x.pointLength=m,x.spotLength=u,x.rectAreaLength=_,x.hemiLength=d,x.numDirectionalShadows=p,x.numPointShadows=f,x.numSpotShadows=y,n.version=Kn++)},setupView:function(t,e){let i=0,s=0,l=0,h=0,c=0;const m=e.matrixWorldInverse;for(let e=0,u=t.length;e<u;e++){const u=t[e];if(u.isDirectionalLight){const t=n.directional[i];t.direction.setFromMatrixPosition(u.matrixWorld),r.setFromMatrixPosition(u.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(m),i++}else if(u.isSpotLight){const t=n.spot[l];t.position.setFromMatrixPosition(u.matrixWorld),t.position.applyMatrix4(m),t.direction.setFromMatrixPosition(u.matrixWorld),r.setFromMatrixPosition(u.target.matrixWorld),t.direction.sub(r),t.direction.transformDirection(m),l++}else if(u.isRectAreaLight){const t=n.rectArea[h];t.position.setFromMatrixPosition(u.matrixWorld),t.position.applyMatrix4(m),a.identity(),o.copy(u.matrixWorld),o.premultiply(m),a.extractRotation(o),t.halfWidth.set(.5*u.width,0,0),t.halfHeight.set(0,.5*u.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),h++}else if(u.isPointLight){const t=n.point[s];t.position.setFromMatrixPosition(u.matrixWorld),t.position.applyMatrix4(m),s++}else if(u.isHemisphereLight){const t=n.hemi[c];t.direction.setFromMatrixPosition(u.matrixWorld),t.direction.transformDirection(m),t.direction.normalize(),c++}}},state:n}}function er(t,e){const i=new tr(t,e),s=[],n=[];return{init:function(){s.length=0,n.length=0},state:{lightsArray:s,shadowsArray:n,lights:i},setupLights:function(t){i.setup(s,t)},setupLightsView:function(t){i.setupView(s,t)},pushLight:function(t){s.push(t)},pushShadow:function(t){n.push(t)}}}function ir(t,e){let i=new WeakMap;return{get:function(s,n=0){let r;return!1===i.has(s)?(r=new er(t,e),i.set(s,[r])):n>=i.get(s).length?(r=new er(t,e),i.get(s).push(r)):r=i.get(s)[n],r},dispose:function(){i=new WeakMap}}}class sr extends Pe{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}sr.prototype.isMeshDepthMaterial=!0;class nr extends Pe{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new pt,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function rr(t,e,i){let s=new Vi;const n=new Z,r=new Z,o=new mt,a=new sr({depthPacking:3201}),c=new nr,m={},u=i.maxTextureSize,_={0:1,1:0,2:2},d=new pi({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Z},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new He;f.setAttribute("position",new Re(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new hi(f,d),x=this;function v(i,s){const n=e.update(g);d.defines.VSM_SAMPLES!==i.blurSamples&&(d.defines.VSM_SAMPLES=i.blurSamples,p.defines.VSM_SAMPLES=i.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=i.map.texture,d.uniforms.resolution.value=i.mapSize,d.uniforms.radius.value=i.radius,t.setRenderTarget(i.mapPass),t.clear(),t.renderBufferDirect(s,null,n,d,g,null),p.uniforms.shadow_pass.value=i.mapPass.texture,p.uniforms.resolution.value=i.mapSize,p.uniforms.radius.value=i.radius,t.setRenderTarget(i.map),t.clear(),t.renderBufferDirect(s,null,n,p,g,null)}function S(e,i,s,n,r,o,l){let h=null;const u=!0===n.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(h=void 0!==u?u:!0===n.isPointLight?c:a,t.localClippingEnabled&&!0===s.clipShadows&&0!==s.clippingPlanes.length||s.displacementMap&&0!==s.displacementScale||s.alphaMap&&s.alphaTest>0){const t=h.uuid,e=s.uuid;let i=m[t];void 0===i&&(i={},m[t]=i);let n=i[e];void 0===n&&(n=h.clone(),i[e]=n),h=n}return h.visible=s.visible,h.wireframe=s.wireframe,h.side=3===l?null!==s.shadowSide?s.shadowSide:s.side:null!==s.shadowSide?s.shadowSide:_[s.side],h.alphaMap=s.alphaMap,h.alphaTest=s.alphaTest,h.clipShadows=s.clipShadows,h.clippingPlanes=s.clippingPlanes,h.clipIntersection=s.clipIntersection,h.displacementMap=s.displacementMap,h.displacementScale=s.displacementScale,h.displacementBias=s.displacementBias,h.wireframeLinewidth=s.wireframeLinewidth,h.linewidth=s.linewidth,!0===n.isPointLight&&!0===h.isMeshDistanceMaterial&&(h.referencePosition.setFromMatrixPosition(n.matrixWorld),h.nearDistance=r,h.farDistance=o),h}function w(i,n,r,o,a){if(!1===i.visible)return;if(i.layers.test(n.layers)&&(i.isMesh||i.isLine||i.isPoints)&&(i.castShadow||i.receiveShadow&&3===a)&&(!i.frustumCulled||s.intersectsObject(i))){i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,i.matrixWorld);const s=e.update(i),n=i.material;if(Array.isArray(n)){const e=s.groups;for(let l=0,h=e.length;l<h;l++){const h=e[l],c=n[h.materialIndex];if(c&&c.visible){const e=S(i,0,c,o,r.near,r.far,a);t.renderBufferDirect(r,null,s,e,i,h)}}}else if(n.visible){const e=S(i,0,n,o,r.near,r.far,a);t.renderBufferDirect(r,null,s,e,i,null)}}const l=i.children;for(let t=0,e=l.length;t<e;t++)w(l[t],n,r,o,a)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(e,i,a){if(!1===x.enabled)return;if(!1===x.autoUpdate&&!1===x.needsUpdate)return;if(0===e.length)return;const c=t.getRenderTarget(),m=t.getActiveCubeFace(),_=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let c=0,m=e.length;c<m;c++){const m=e[c],_=m.shadow;if(void 0===_){console.warn("THREE.WebGLShadowMap:",m,"has no shadow.");continue}if(!1===_.autoUpdate&&!1===_.needsUpdate)continue;n.copy(_.mapSize);const p=_.getFrameExtents();if(n.multiply(p),r.copy(_.mapSize),(n.x>u||n.y>u)&&(n.x>u&&(r.x=Math.floor(u/p.x),n.x=r.x*p.x,_.mapSize.x=r.x),n.y>u&&(r.y=Math.floor(u/p.y),n.y=r.y*p.y,_.mapSize.y=r.y)),null===_.map&&!_.isPointLightShadow&&3===this.type){const t={minFilter:h,magFilter:h,format:y};_.map=new ut(n.x,n.y,t),_.map.texture.name=m.name+".shadowMap",_.mapPass=new ut(n.x,n.y,t),_.camera.updateProjectionMatrix()}if(null===_.map){const t={minFilter:l,magFilter:l,format:y};_.map=new ut(n.x,n.y,t),_.map.texture.name=m.name+".shadowMap",_.camera.updateProjectionMatrix()}t.setRenderTarget(_.map),t.clear();const f=_.getViewportCount();for(let t=0;t<f;t++){const e=_.getViewport(t);o.set(r.x*e.x,r.y*e.y,r.x*e.z,r.y*e.w),d.viewport(o),_.updateMatrices(m,t),s=_.getFrustum(),w(i,a,_.camera,m,this.type)}_.isPointLightShadow||3!==this.type||v(_,a),_.needsUpdate=!1}x.needsUpdate=!1,t.setRenderTarget(c,m,_)}}function or(e,i,s){const n=s.isWebGL2,r=new function(){let t=!1;const i=new mt;let s=null;const n=new mt(0,0,0,0);return{setMask:function(i){s===i||t||(e.colorMask(i,i,i,i),s=i)},setLocked:function(e){t=e},setClear:function(t,s,r,o,a){!0===a&&(t*=o,s*=o,r*=o),i.set(t,s,r,o),!1===n.equals(i)&&(e.clearColor(t,s,r,o),n.copy(i))},reset:function(){t=!1,s=null,n.set(-1,0,0,0)}}},o=new function(){let t=!1,i=null,s=null,n=null;return{setTest:function(t){t?z(2929):O(2929)},setMask:function(s){i===s||t||(e.depthMask(s),i=s)},setFunc:function(t){if(s!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:default:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517)}else e.depthFunc(515);s=t}},setLocked:function(e){t=e},setClear:function(t){n!==t&&(e.clearDepth(t),n=t)},reset:function(){t=!1,i=null,s=null,n=null}}},a=new function(){let t=!1,i=null,s=null,n=null,r=null,o=null,a=null,l=null,h=null;return{setTest:function(e){t||(e?z(2960):O(2960))},setMask:function(s){i===s||t||(e.stencilMask(s),i=s)},setFunc:function(t,i,o){s===t&&n===i&&r===o||(e.stencilFunc(t,i,o),s=t,n=i,r=o)},setOp:function(t,i,s){o===t&&a===i&&l===s||(e.stencilOp(t,i,s),o=t,a=i,l=s)},setLocked:function(e){t=e},setClear:function(t){h!==t&&(e.clearStencil(t),h=t)},reset:function(){t=!1,i=null,s=null,n=null,r=null,o=null,a=null,l=null,h=null}}};let l={},h={},c=new WeakMap,m=[],u=null,_=!1,d=null,p=null,f=null,y=null,g=null,x=null,v=null,S=!1,w=null,b=null,C=null,A=null,B=null;const M=e.getParameter(35661);let V=!1,T=0;const P=e.getParameter(7938);-1!==P.indexOf("WebGL")?(T=parseFloat(/^WebGL (\d)/.exec(P)[1]),V=T>=1):-1!==P.indexOf("OpenGL ES")&&(T=parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),V=T>=2);let D=null,I={};const E=e.getParameter(3088),R=e.getParameter(2978),L=(new mt).fromArray(E),G=(new mt).fromArray(R);function F(t,i,s){const n=new Uint8Array(4),r=e.createTexture();e.bindTexture(t,r),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<s;t++)e.texImage2D(i+t,0,6408,1,1,0,6408,5121,n);return r}const k={};function z(t){!0!==l[t]&&(e.enable(t),l[t]=!0)}function O(t){!1!==l[t]&&(e.disable(t),l[t]=!1)}k[3553]=F(3553,3553,1),k[34067]=F(34067,34069,6),r.setClear(0,0,0,1),o.setClear(1),a.setClear(0),z(2929),o.setFunc(3),j(!1),H(1),z(2884),W(0);const N={[t]:32774,101:32778,102:32779};if(n)N[103]=32775,N[104]=32776;else{const t=i.get("EXT_blend_minmax");null!==t&&(N[103]=t.MIN_EXT,N[104]=t.MAX_EXT)}const U={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function W(i,s,n,r,o,a,l,h){if(0!==i){if(!1===_&&(z(3042),_=!0),5===i)o=o||s,a=a||n,l=l||r,s===p&&o===g||(e.blendEquationSeparate(N[s],N[o]),p=s,g=o),n===f&&r===y&&a===x&&l===v||(e.blendFuncSeparate(U[n],U[r],U[a],U[l]),f=n,y=r,x=a,v=l),d=i,S=null;else if(i!==d||h!==S){if(p===t&&g===t||(e.blendEquation(32774),p=t,g=t),h)switch(i){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",i)}else switch(i){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",i)}f=null,y=null,x=null,v=null,d=i,S=h}}else!0===_&&(O(3042),_=!1)}function j(t){w!==t&&(t?e.frontFace(2304):e.frontFace(2305),w=t)}function H(t){0!==t?(z(2884),t!==b&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):O(2884),b=t}function q(t,i,s){t?(z(32823),A===i&&B===s||(e.polygonOffset(i,s),A=i,B=s)):O(32823)}function X(t){void 0===t&&(t=33984+M-1),D!==t&&(e.activeTexture(t),D=t)}return{buffers:{color:r,depth:o,stencil:a},enable:z,disable:O,bindFramebuffer:function(t,i){return h[t]!==i&&(e.bindFramebuffer(t,i),h[t]=i,n&&(36009===t&&(h[36160]=i),36160===t&&(h[36009]=i)),!0)},drawBuffers:function(t,n){let r=m,o=!1;if(t)if(r=c.get(n),void 0===r&&(r=[],c.set(n,r)),t.isWebGLMultipleRenderTargets){const e=t.texture;if(r.length!==e.length||36064!==r[0]){for(let t=0,i=e.length;t<i;t++)r[t]=36064+t;r.length=e.length,o=!0}}else 36064!==r[0]&&(r[0]=36064,o=!0);else 1029!==r[0]&&(r[0]=1029,o=!0);o&&(s.isWebGL2?e.drawBuffers(r):i.get("WEBGL_draw_buffers").drawBuffersWEBGL(r))},useProgram:function(t){return u!==t&&(e.useProgram(t),u=t,!0)},setBlending:W,setMaterial:function(t,e){2===t.side?O(2884):z(2884);let i=1===t.side;e&&(i=!i),j(i),1===t.blending&&!1===t.transparent?W(0):W(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),o.setFunc(t.depthFunc),o.setTest(t.depthTest),o.setMask(t.depthWrite),r.setMask(t.colorWrite);const s=t.stencilWrite;a.setTest(s),s&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),q(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?z(32926):O(32926)},setFlipSided:j,setCullFace:H,setLineWidth:function(t){t!==C&&(V&&e.lineWidth(t),C=t)},setPolygonOffset:q,setScissorTest:function(t){t?z(3089):O(3089)},activeTexture:X,bindTexture:function(t,i){null===D&&X();let s=I[D];void 0===s&&(s={type:void 0,texture:void 0},I[D]=s),s.type===t&&s.texture===i||(e.bindTexture(t,i||k[t]),s.type=t,s.texture=i)},unbindTexture:function(){const t=I[D];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage2D:function(){try{e.texStorage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{e.texStorage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{e.texSubImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{e.texSubImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(t){!1===L.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),L.copy(t))},viewport:function(t){!1===G.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),G.copy(t))},reset:function(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),!0===n&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},D=null,I={},h={},c=new WeakMap,m=[],u=null,_=!1,d=null,p=null,f=null,y=null,g=null,x=null,v=null,S=!1,w=null,b=null,C=null,A=null,B=null,L.set(0,0,e.canvas.width,e.canvas.height),G.set(0,0,e.canvas.width,e.canvas.height),r.reset(),o.reset(),a.reset()}}}function ar(t,e,i,s,n,v,S){const w=n.isWebGL2,b=n.maxTextures,C=n.maxCubemapSize,A=n.maxTextureSize,B=n.maxSamples,M=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,V=new WeakMap;let T,I=!1;try{I="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function E(t,e){return I?new OffscreenCanvas(t,e):K("canvas")}function R(t,e,i,s){let n=1;if((t.width>s||t.height>s)&&(n=s/Math.max(t.width,t.height)),n<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const s=e?X:Math.floor,r=s(n*t.width),o=s(n*t.height);void 0===T&&(T=E(r,o));const a=i?E(r,o):T;return a.width=r,a.height=o,a.getContext("2d").drawImage(t,0,0,r,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+r+"x"+o+")."),a}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function L(t){return q(t.width)&&q(t.height)}function F(t,e){return t.generateMipmaps&&e&&t.minFilter!==l&&t.minFilter!==h}function k(e){t.generateMipmap(e)}function z(i,s,n,r,o=!1){if(!1===w)return s;if(null!==i){if(void 0!==t[i])return t[i];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let a=s;return 6403===s&&(5126===n&&(a=33326),5131===n&&(a=33325),5121===n&&(a=33321)),33319===s&&(5126===n&&(a=33328),5131===n&&(a=33327),5121===n&&(a=33323)),6408===s&&(5126===n&&(a=34836),5131===n&&(a=34842),5121===n&&(a=r===D&&!1===o?35907:32856),32819===n&&(a=32854),32820===n&&(a=32855)),33325!==a&&33326!==a&&33327!==a&&33328!==a&&34842!==a&&34836!==a||e.get("EXT_color_buffer_float"),a}function O(t,e,i){return!0===F(t,i)||t.isFramebufferTexture&&t.minFilter!==l&&t.minFilter!==h?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function N(t){return t===l||1004===t||1005===t?9728:9729}function U(e){const i=e.target;i.removeEventListener("dispose",U),function(e){const i=s.get(e);void 0!==i.__webglInit&&(t.deleteTexture(i.__webglTexture),s.remove(e))}(i),i.isVideoTexture&&V.delete(i),S.memory.textures--}function W(e){const i=e.target;i.removeEventListener("dispose",W),function(e){const i=e.texture,n=s.get(e),r=s.get(i);if(e){if(void 0!==r.__webglTexture&&(t.deleteTexture(r.__webglTexture),S.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&t.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,n=i.length;e<n;e++){const n=s.get(i[e]);n.__webglTexture&&(t.deleteTexture(n.__webglTexture),S.memory.textures--),s.remove(i[e])}s.remove(i),s.remove(e)}}(i)}let j=0;function H(t,e){const n=s.get(t);if(t.isVideoTexture&&function(t){const e=S.render.frame;V.get(t)!==e&&(V.set(t,e),t.update())}(t),t.version>0&&n.__version!==t.version){const i=t.image;if(void 0===i)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==i.complete)return void tt(n,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}i.activeTexture(33984+e),i.bindTexture(3553,n.__webglTexture)}function J(e,n){const r=s.get(e);e.version>0&&r.__version!==e.version?function(e,s,n){if(6!==s.image.length)return;$(e,s),i.activeTexture(33984+n),i.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,s.flipY),t.pixelStorei(37441,s.premultiplyAlpha),t.pixelStorei(3317,s.unpackAlignment),t.pixelStorei(37443,0);const r=s&&(s.isCompressedTexture||s.image[0].isCompressedTexture),o=s.image[0]&&s.image[0].isDataTexture,a=[];for(let t=0;t<6;t++)a[t]=r||o?o?s.image[t].image:s.image[t]:R(s.image[t],!1,!0,C),a[t]=rt(s,a[t]);const l=a[0],h=L(l)||w,c=v.convert(s.format,s.encoding),m=v.convert(s.type),u=z(s.internalFormat,c,m,s.encoding),_=w&&!0!==s.isVideoTexture,d=void 0===e.__version;let p,f=O(s,l,h);if(Q(34067,s,h),r){_&&d&&i.texStorage2D(34067,f,u,l.width,l.height);for(let t=0;t<6;t++){p=a[t].mipmaps;for(let e=0;e<p.length;e++){const n=p[e];s.format!==y?null!==c?_?i.compressedTexSubImage2D(34069+t,e,0,0,n.width,n.height,c,n.data):i.compressedTexImage2D(34069+t,e,u,n.width,n.height,0,n.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):_?i.texSubImage2D(34069+t,e,0,0,n.width,n.height,c,m,n.data):i.texImage2D(34069+t,e,u,n.width,n.height,0,c,m,n.data)}}}else{p=s.mipmaps,_&&d&&(p.length>0&&f++,i.texStorage2D(34067,f,u,a[0].width,a[0].height));for(let t=0;t<6;t++)if(o){_?i.texSubImage2D(34069+t,0,0,0,a[t].width,a[t].height,c,m,a[t].data):i.texImage2D(34069+t,0,u,a[t].width,a[t].height,0,c,m,a[t].data);for(let e=0;e<p.length;e++){const s=p[e].image[t].image;_?i.texSubImage2D(34069+t,e+1,0,0,s.width,s.height,c,m,s.data):i.texImage2D(34069+t,e+1,u,s.width,s.height,0,c,m,s.data)}}else{_?i.texSubImage2D(34069+t,0,0,0,c,m,a[t]):i.texImage2D(34069+t,0,u,c,m,a[t]);for(let e=0;e<p.length;e++){const s=p[e];_?i.texSubImage2D(34069+t,e+1,0,0,c,m,s.image[t]):i.texImage2D(34069+t,e+1,u,c,m,s.image[t])}}}F(s,h)&&k(34067),e.__version=s.version,s.onUpdate&&s.onUpdate(s)}(r,e,n):(i.activeTexture(33984+n),i.bindTexture(34067,r.__webglTexture))}const Z={[r]:10497,[o]:33071,[a]:33648},Y={[l]:9728,1004:9984,1005:9986,[h]:9729,1007:9985,[c]:9987};function Q(i,r,a){if(a?(t.texParameteri(i,10242,Z[r.wrapS]),t.texParameteri(i,10243,Z[r.wrapT]),32879!==i&&35866!==i||t.texParameteri(i,32882,Z[r.wrapR]),t.texParameteri(i,10240,Y[r.magFilter]),t.texParameteri(i,10241,Y[r.minFilter])):(t.texParameteri(i,10242,33071),t.texParameteri(i,10243,33071),32879!==i&&35866!==i||t.texParameteri(i,32882,33071),r.wrapS===o&&r.wrapT===o||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(i,10240,N(r.magFilter)),t.texParameteri(i,10241,N(r.minFilter)),r.minFilter!==l&&r.minFilter!==h&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const o=e.get("EXT_texture_filter_anisotropic");if(r.type===d&&!1===e.has("OES_texture_float_linear"))return;if(!1===w&&r.type===p&&!1===e.has("OES_texture_half_float_linear"))return;(r.anisotropy>1||s.get(r).__currentAnisotropy)&&(t.texParameterf(i,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,n.getMaxAnisotropy())),s.get(r).__currentAnisotropy=r.anisotropy)}}function $(e,i){void 0===e.__webglInit&&(e.__webglInit=!0,i.addEventListener("dispose",U),e.__webglTexture=t.createTexture(),S.memory.textures++)}function tt(e,s,n){let r=3553;s.isDataTexture2DArray&&(r=35866),s.isDataTexture3D&&(r=32879),$(e,s),i.activeTexture(33984+n),i.bindTexture(r,e.__webglTexture),t.pixelStorei(37440,s.flipY),t.pixelStorei(37441,s.premultiplyAlpha),t.pixelStorei(3317,s.unpackAlignment),t.pixelStorei(37443,0);const a=function(t){return!w&&(t.wrapS!==o||t.wrapT!==o||t.minFilter!==l&&t.minFilter!==h)}(s)&&!1===L(s.image);let c=R(s.image,a,!1,A);c=rt(s,c);const m=L(c)||w,p=v.convert(s.format,s.encoding);let S,b=v.convert(s.type),C=z(s.internalFormat,p,b,s.encoding,s.isVideoTexture);Q(r,s,m);const B=s.mipmaps,M=w&&!0!==s.isVideoTexture,V=void 0===e.__version,T=O(s,c,m);if(s.isDepthTexture)C=6402,w?C=s.type===d?36012:s.type===_?33190:s.type===f?35056:33189:s.type===d&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),s.format===g&&6402===C&&s.type!==u&&s.type!==_&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),s.type=u,b=v.convert(s.type)),s.format===x&&6402===C&&(C=34041,s.type!==f&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),s.type=f,b=v.convert(s.type))),M&&V?i.texStorage2D(3553,1,C,c.width,c.height):i.texImage2D(3553,0,C,c.width,c.height,0,p,b,null);else if(s.isDataTexture)if(B.length>0&&m){M&&V&&i.texStorage2D(3553,T,C,B[0].width,B[0].height);for(let t=0,e=B.length;t<e;t++)S=B[t],M?i.texSubImage2D(3553,0,0,0,S.width,S.height,p,b,S.data):i.texImage2D(3553,t,C,S.width,S.height,0,p,b,S.data);s.generateMipmaps=!1}else M?(V&&i.texStorage2D(3553,T,C,c.width,c.height),i.texSubImage2D(3553,0,0,0,c.width,c.height,p,b,c.data)):i.texImage2D(3553,0,C,c.width,c.height,0,p,b,c.data);else if(s.isCompressedTexture){M&&V&&i.texStorage2D(3553,T,C,B[0].width,B[0].height);for(let t=0,e=B.length;t<e;t++)S=B[t],s.format!==y?null!==p?M?i.compressedTexSubImage2D(3553,t,0,0,S.width,S.height,p,S.data):i.compressedTexImage2D(3553,t,C,S.width,S.height,0,S.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):M?i.texSubImage2D(3553,t,0,0,S.width,S.height,p,b,S.data):i.texImage2D(3553,t,C,S.width,S.height,0,p,b,S.data)}else if(s.isDataTexture2DArray)M?(V&&i.texStorage3D(35866,T,C,c.width,c.height,c.depth),i.texSubImage3D(35866,0,0,0,0,c.width,c.height,c.depth,p,b,c.data)):i.texImage3D(35866,0,C,c.width,c.height,c.depth,0,p,b,c.data);else if(s.isDataTexture3D)M?(V&&i.texStorage3D(32879,T,C,c.width,c.height,c.depth),i.texSubImage3D(32879,0,0,0,0,c.width,c.height,c.depth,p,b,c.data)):i.texImage3D(32879,0,C,c.width,c.height,c.depth,0,p,b,c.data);else if(s.isFramebufferTexture)M&&V?i.texStorage2D(3553,T,C,c.width,c.height):i.texImage2D(3553,0,C,c.width,c.height,0,p,b,null);else if(B.length>0&&m){M&&V&&i.texStorage2D(3553,T,C,B[0].width,B[0].height);for(let t=0,e=B.length;t<e;t++)S=B[t],M?i.texSubImage2D(3553,t,0,0,p,b,S):i.texImage2D(3553,t,C,p,b,S);s.generateMipmaps=!1}else M?(V&&i.texStorage2D(3553,T,C,c.width,c.height),i.texSubImage2D(3553,0,0,0,p,b,c)):i.texImage2D(3553,0,C,p,b,c);F(s,m)&&k(r),e.__version=s.version,s.onUpdate&&s.onUpdate(s)}function et(e,n,r,o,a){const l=v.convert(r.format,r.encoding),h=v.convert(r.type),c=z(r.internalFormat,l,h,r.encoding);s.get(n).__hasExternalTextures||(32879===a||35866===a?i.texImage3D(a,0,c,n.width,n.height,n.depth,0,l,h,null):i.texImage2D(a,0,c,n.width,n.height,0,l,h,null)),i.bindFramebuffer(36160,e),n.useRenderToTexture?M.framebufferTexture2DMultisampleEXT(36160,o,a,s.get(r).__webglTexture,0,nt(n)):t.framebufferTexture2D(36160,o,a,s.get(r).__webglTexture,0),i.bindFramebuffer(36160,null)}function it(e,i,s){if(t.bindRenderbuffer(36161,e),i.depthBuffer&&!i.stencilBuffer){let n=33189;if(s||i.useRenderToTexture){const e=i.depthTexture;e&&e.isDepthTexture&&(e.type===d?n=36012:e.type===_&&(n=33190));const s=nt(i);i.useRenderToTexture?M.renderbufferStorageMultisampleEXT(36161,s,n,i.width,i.height):t.renderbufferStorageMultisample(36161,s,n,i.width,i.height)}else t.renderbufferStorage(36161,n,i.width,i.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(i.depthBuffer&&i.stencilBuffer){const n=nt(i);s&&i.useRenderbuffer?t.renderbufferStorageMultisample(36161,n,35056,i.width,i.height):i.useRenderToTexture?M.renderbufferStorageMultisampleEXT(36161,n,35056,i.width,i.height):t.renderbufferStorage(36161,34041,i.width,i.height),t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===i.isWebGLMultipleRenderTargets?i.texture[0]:i.texture,n=v.convert(e.format,e.encoding),r=v.convert(e.type),o=z(e.internalFormat,n,r,e.encoding),a=nt(i);s&&i.useRenderbuffer?t.renderbufferStorageMultisample(36161,a,o,i.width,i.height):i.useRenderToTexture?M.renderbufferStorageMultisampleEXT(36161,a,o,i.width,i.height):t.renderbufferStorage(36161,o,i.width,i.height)}t.bindRenderbuffer(36161,null)}function st(e){const n=s.get(e),r=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!n.__autoAllocateDepthBuffer){if(r)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(36160,e),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");s.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),H(n.depthTexture,0);const r=s.get(n.depthTexture).__webglTexture,o=nt(n);if(n.depthTexture.format===g)n.useRenderToTexture?M.framebufferTexture2DMultisampleEXT(36160,36096,3553,r,0,o):t.framebufferTexture2D(36160,36096,3553,r,0);else{if(n.depthTexture.format!==x)throw new Error("Unknown depthTexture format");n.useRenderToTexture?M.framebufferTexture2DMultisampleEXT(36160,33306,3553,r,0,o):t.framebufferTexture2D(36160,33306,3553,r,0)}}(n.__webglFramebuffer,e)}else if(r){n.__webglDepthbuffer=[];for(let s=0;s<6;s++)i.bindFramebuffer(36160,n.__webglFramebuffer[s]),n.__webglDepthbuffer[s]=t.createRenderbuffer(),it(n.__webglDepthbuffer[s],e,!1)}else i.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=t.createRenderbuffer(),it(n.__webglDepthbuffer,e,!1);i.bindFramebuffer(36160,null)}function nt(t){return w&&(t.useRenderbuffer||t.useRenderToTexture)?Math.min(B,t.samples):0}function rt(t,i){const s=t.encoding,n=t.format,r=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||t.format===G||s!==P&&(s===D?!1===w?!0===e.has("EXT_sRGB")&&n===y?(t.format=G,t.minFilter=h,t.generateMipmaps=!1):i=at.sRGBToLinear(i):n===y&&r===m||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",s)),i}let ot=!1,lt=!1;this.allocateTextureUnit=function(){const t=j;return t>=b&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+b),j+=1,t},this.resetTextureUnits=function(){j=0},this.setTexture2D=H,this.setTexture2DArray=function(t,e){const n=s.get(t);t.version>0&&n.__version!==t.version?tt(n,t,e):(i.activeTexture(33984+e),i.bindTexture(35866,n.__webglTexture))},this.setTexture3D=function(t,e){const n=s.get(t);t.version>0&&n.__version!==t.version?tt(n,t,e):(i.activeTexture(33984+e),i.bindTexture(32879,n.__webglTexture))},this.setTextureCube=J,this.rebindTextures=function(t,e,i){const n=s.get(t);void 0!==e&&et(n.__webglFramebuffer,t,t.texture,36064,3553),void 0!==i&&st(t)},this.setupRenderTarget=function(e){const r=e.texture,o=s.get(e),a=s.get(r);e.addEventListener("dispose",W),!0!==e.isWebGLMultipleRenderTargets&&(void 0===a.__webglTexture&&(a.__webglTexture=t.createTexture()),a.__version=r.version,S.memory.textures++);const l=!0===e.isWebGLCubeRenderTarget,h=!0===e.isWebGLMultipleRenderTargets,c=r.isDataTexture3D||r.isDataTexture2DArray,m=L(e)||w;if(l){o.__webglFramebuffer=[];for(let e=0;e<6;e++)o.__webglFramebuffer[e]=t.createFramebuffer()}else if(o.__webglFramebuffer=t.createFramebuffer(),h)if(n.drawBuffers){const i=e.texture;for(let e=0,n=i.length;e<n;e++){const n=s.get(i[e]);void 0===n.__webglTexture&&(n.__webglTexture=t.createTexture(),S.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(e.useRenderbuffer)if(w){o.__webglMultisampledFramebuffer=t.createFramebuffer(),o.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,o.__webglColorRenderbuffer);const s=v.convert(r.format,r.encoding),n=v.convert(r.type),a=z(r.internalFormat,s,n,r.encoding),l=nt(e);t.renderbufferStorageMultisample(36161,l,a,e.width,e.height),i.bindFramebuffer(36160,o.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,o.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(o.__webglDepthRenderbuffer=t.createRenderbuffer(),it(o.__webglDepthRenderbuffer,e,!0)),i.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(l){i.bindTexture(34067,a.__webglTexture),Q(34067,r,m);for(let t=0;t<6;t++)et(o.__webglFramebuffer[t],e,r,36064,34069+t);F(r,m)&&k(34067),i.unbindTexture()}else if(h){const t=e.texture;for(let n=0,r=t.length;n<r;n++){const r=t[n],a=s.get(r);i.bindTexture(3553,a.__webglTexture),Q(3553,r,m),et(o.__webglFramebuffer,e,r,36064+n,3553),F(r,m)&&k(3553)}i.unbindTexture()}else{let t=3553;c&&(w?t=r.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),i.bindTexture(t,a.__webglTexture),Q(t,r,m),et(o.__webglFramebuffer,e,r,36064,t),F(r,m)&&k(t),i.unbindTexture()}e.depthBuffer&&st(e)},this.updateRenderTargetMipmap=function(t){const e=L(t)||w,n=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let r=0,o=n.length;r<o;r++){const o=n[r];if(F(o,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,n=s.get(o).__webglTexture;i.bindTexture(e,n),k(e),i.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.useRenderbuffer)if(w){const n=e.width,r=e.height;let o=16384;const a=[36064],l=e.stencilBuffer?33306:36096;e.depthBuffer&&a.push(l),e.ignoreDepthForMultisampleCopy||(e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024));const h=s.get(e);i.bindFramebuffer(36008,h.__webglMultisampledFramebuffer),i.bindFramebuffer(36009,h.__webglFramebuffer),e.ignoreDepthForMultisampleCopy&&(t.invalidateFramebuffer(36008,[l]),t.invalidateFramebuffer(36009,[l])),t.blitFramebuffer(0,0,n,r,0,0,n,r,o,9728),t.invalidateFramebuffer(36008,a),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,h.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.setupDepthRenderbuffer=st,this.setupFrameBufferTexture=et,this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===ot&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ot=!0),t=t.texture),H(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===lt&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),lt=!0),t=t.texture),J(t,e)}}function lr(t,e,i){const s=i.isWebGL2;return{convert:function(t,i=null){let n;if(t===m)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1010===t)return 5120;if(1011===t)return 5122;if(t===u)return 5123;if(1013===t)return 5124;if(t===_)return 5125;if(t===d)return 5126;if(t===p)return s?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(1021===t)return 6406;if(t===y)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(t===g)return 6402;if(t===x)return 34041;if(1028===t)return 6403;if(1022===t)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(t===G)return n=e.get("EXT_sRGB"),null!==n?n.SRGB_ALPHA_EXT:null;if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1033===t)return 36249;if(t===v||t===S||t===w||t===b)if(i===D){if(n=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===n)return null;if(t===v)return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===S)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===w)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===b)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(t===v)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===S)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===w)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===b)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(35840===t)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if(37492===t||37496===t){if(n=e.get("WEBGL_compressed_texture_etc"),null===n)return null;if(37492===t)return i===D?n.COMPRESSED_SRGB8_ETC2:n.COMPRESSED_RGB8_ETC2;if(37496===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:n.COMPRESSED_RGBA8_ETC2_EAC}if(37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t){if(n=e.get("WEBGL_compressed_texture_astc"),null===n)return null;if(37808===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:n.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:n.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:n.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:n.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:n.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:n.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:n.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:n.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:n.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:n.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:n.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:n.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:n.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===t)return i===D?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:n.COMPRESSED_RGBA_ASTC_12x12_KHR}if(36492===t){if(n=e.get("EXT_texture_compression_bptc"),null===n)return null;if(36492===t)return i===D?n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:n.COMPRESSED_RGBA_BPTC_UNORM_EXT}return t===f?s?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}nr.prototype.isMeshDistanceMaterial=!0;class hr extends yi{constructor(t=[]){super(),this.cameras=t}}hr.prototype.isArrayCamera=!0;class cr extends ye{constructor(){super(),this.type="Group"}}cr.prototype.isGroup=!0;const mr={type:"move"};class ur{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new cr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new cr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new pt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new pt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new cr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new pt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new pt),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,i){let s=null,n=null,r=null;const o=this._targetRay,a=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==o&&(s=e.getPose(t.targetRaySpace,i),null!==s&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(mr))),l&&t.hand){r=!0;for(const s of t.hand.values()){const t=e.getJointPose(s,i);if(void 0===l.joints[s.jointName]){const t=new cr;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[s.jointName]=t,l.add(t)}const n=l.joints[s.jointName];null!==t&&(n.matrix.fromArray(t.transform.matrix),n.matrix.decompose(n.position,n.rotation,n.scale),n.jointRadius=t.radius),n.visible=null!==t}const s=l.joints["index-finger-tip"],n=l.joints["thumb-tip"],o=s.position.distanceTo(n.position),a=.02,h=.005;l.inputState.pinching&&o>a+h?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&o<=a-h&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&(n=e.getPose(t.gripSpace,i),null!==n&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),n.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(n.linearVelocity)):a.hasLinearVelocity=!1,n.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(n.angularVelocity)):a.hasAngularVelocity=!1));return null!==o&&(o.visible=null!==s),null!==a&&(a.visible=null!==n),null!==l&&(l.visible=null!==r),this}}class _r extends ht{constructor(t,e,i,s,n,r,o,a,h,c){if((c=void 0!==c?c:g)!==g&&c!==x)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&c===g&&(i=u),void 0===i&&c===x&&(i=f),super(null,s,n,r,o,a,c,i,h),this.image={width:t,height:e},this.magFilter=void 0!==o?o:l,this.minFilter=void 0!==a?a:l,this.flipY=!1,this.generateMipmaps=!1}}_r.prototype.isDepthTexture=!0;class dr extends F{constructor(t,e){super();const i=this;let s=null,n=1,r=null,o="local-floor";const a=t.extensions.has("WEBGL_multisampled_render_to_texture");let l=null,h=null,c=null,_=null,d=!1,p=null;const v=e.getContextAttributes();let S=null,w=null;const b=[],C=new Map,A=new yi;A.layers.enable(1),A.viewport=new mt;const B=new yi;B.layers.enable(2),B.viewport=new mt;const M=[A,B],V=new hr;V.layers.enable(1),V.layers.enable(2);let T=null,P=null;function I(t){const e=C.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function E(){C.forEach((function(t,e){t.disconnect(e)})),C.clear(),T=null,P=null,t.setRenderTarget(S),_=null,c=null,h=null,s=null,w=null,z.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function R(t){const e=s.inputSources;for(let t=0;t<b.length;t++)C.set(e[t],b[t]);for(let e=0;e<t.removed.length;e++){const i=t.removed[e],s=C.get(i);s&&(s.dispatchEvent({type:"disconnected",data:i}),C.delete(i))}for(let e=0;e<t.added.length;e++){const i=t.added[e],s=C.get(i);s&&s.dispatchEvent({type:"connected",data:i})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=b[t];return void 0===e&&(e=new ur,b[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=b[t];return void 0===e&&(e=new ur,b[t]=e),e.getGripSpace()},this.getHand=function(t){let e=b[t];return void 0===e&&(e=new ur,b[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){n=t,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){o=t,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return r},this.getBaseLayer=function(){return null!==c?c:_},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return s},this.setSession=async function(l){if(s=l,null!==s){if(S=t.getRenderTarget(),s.addEventListener("select",I),s.addEventListener("selectstart",I),s.addEventListener("selectend",I),s.addEventListener("squeeze",I),s.addEventListener("squeezestart",I),s.addEventListener("squeezeend",I),s.addEventListener("end",E),s.addEventListener("inputsourceschange",R),!0!==v.xrCompatible&&await e.makeXRCompatible(),void 0===s.renderState.layers||!1===t.capabilities.isWebGL2){const i={antialias:void 0!==s.renderState.layers||v.antialias,alpha:v.alpha,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:n};_=new XRWebGLLayer(s,e,i),s.updateRenderState({baseLayer:_}),w=new ut(_.framebufferWidth,_.framebufferHeight,{format:y,type:m,encoding:t.outputEncoding})}else{d=v.antialias;let i=null,r=null,o=null;v.depth&&(o=v.stencil?35056:33190,i=v.stencil?x:g,r=v.stencil?f:u);const l={colorFormat:t.outputEncoding===D?35907:32856,depthFormat:o,scaleFactor:n};h=new XRWebGLBinding(s,e),c=h.createProjectionLayer(l),s.updateRenderState({layers:[c]}),w=d?new _t(c.textureWidth,c.textureHeight,{format:y,type:m,depthTexture:new _r(c.textureWidth,c.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:v.stencil,ignoreDepth:c.ignoreDepthValues,useRenderToTexture:a,encoding:t.outputEncoding}):new ut(c.textureWidth,c.textureHeight,{format:y,type:m,depthTexture:new _r(c.textureWidth,c.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:v.stencil,ignoreDepth:c.ignoreDepthValues,encoding:t.outputEncoding})}w.isXRRenderTarget=!0,this.setFoveation(1),r=await s.requestReferenceSpace(o),z.setContext(s),z.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};const L=new pt,G=new pt;function F(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===s)return;V.near=B.near=A.near=t.near,V.far=B.far=A.far=t.far,T===V.near&&P===V.far||(s.updateRenderState({depthNear:V.near,depthFar:V.far}),T=V.near,P=V.far);const e=t.parent,i=V.cameras;F(V,e);for(let t=0;t<i.length;t++)F(i[t],e);V.matrixWorld.decompose(V.position,V.quaternion,V.scale),t.position.copy(V.position),t.quaternion.copy(V.quaternion),t.scale.copy(V.scale),t.matrix.copy(V.matrix),t.matrixWorld.copy(V.matrixWorld);const n=t.children;for(let t=0,e=n.length;t<e;t++)n[t].updateMatrixWorld(!0);2===i.length?function(t,e,i){L.setFromMatrixPosition(e.matrixWorld),G.setFromMatrixPosition(i.matrixWorld);const s=L.distanceTo(G),n=e.projectionMatrix.elements,r=i.projectionMatrix.elements,o=n[14]/(n[10]-1),a=n[14]/(n[10]+1),l=(n[9]+1)/n[5],h=(n[9]-1)/n[5],c=(n[8]-1)/n[0],m=(r[8]+1)/r[0],u=o*c,_=o*m,d=s/(-c+m),p=d*-c;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(p),t.translateZ(d),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const f=o+d,y=a+d,g=u-p,x=_+(s-p),v=l*a/y*f,S=h*a/y*f;t.projectionMatrix.makePerspective(g,x,v,S,f,y)}(V,A,B):V.projectionMatrix.copy(A.projectionMatrix)},this.getCamera=function(){return V},this.getFoveation=function(){return null!==c?c.fixedFoveation:null!==_?_.fixedFoveation:void 0},this.setFoveation=function(t){null!==c&&(c.fixedFoveation=t),null!==_&&void 0!==_.fixedFoveation&&(_.fixedFoveation=t)};let k=null;const z=new Ti;z.setAnimationLoop((function(e,i){if(l=i.getViewerPose(r),p=i,null!==l){const e=l.views;null!==_&&(t.setRenderTargetFramebuffer(w,_.framebuffer),t.setRenderTarget(w));let i=!1;e.length!==V.cameras.length&&(V.cameras.length=0,i=!0);for(let s=0;s<e.length;s++){const n=e[s];let r=null;if(null!==_)r=_.getViewport(n);else{const e=h.getViewSubImage(c,n);r=e.viewport,0===s&&(t.setRenderTargetTextures(w,e.colorTexture,c.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(w))}const o=M[s];o.matrix.fromArray(n.transform.matrix),o.projectionMatrix.fromArray(n.projectionMatrix),o.viewport.set(r.x,r.y,r.width,r.height),0===s&&V.matrix.copy(o.matrix),!0===i&&V.cameras.push(o)}}const n=s.inputSources;for(let t=0;t<b.length;t++){const e=b[t],s=n[t];e.update(s,i,r)}k&&k(e,i),p=null})),this.setAnimationLoop=function(t){k=t},this.dispose=function(){}}}function pr(t){function e(e,i){e.opacity.value=i.opacity,i.color&&e.diffuse.value.copy(i.color),i.emissive&&e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(e.map.value=i.map),i.alphaMap&&(e.alphaMap.value=i.alphaMap),i.specularMap&&(e.specularMap.value=i.specularMap),i.alphaTest>0&&(e.alphaTest.value=i.alphaTest);const s=t.get(i).envMap;let n,r;s&&(e.envMap.value=s,e.flipEnvMap.value=s.isCubeTexture&&!1===s.isRenderTargetTexture?-1:1,e.reflectivity.value=i.reflectivity,e.ior.value=i.ior,e.refractionRatio.value=i.refractionRatio),i.lightMap&&(e.lightMap.value=i.lightMap,e.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(e.aoMap.value=i.aoMap,e.aoMapIntensity.value=i.aoMapIntensity),i.map?n=i.map:i.specularMap?n=i.specularMap:i.displacementMap?n=i.displacementMap:i.normalMap?n=i.normalMap:i.bumpMap?n=i.bumpMap:i.roughnessMap?n=i.roughnessMap:i.metalnessMap?n=i.metalnessMap:i.alphaMap?n=i.alphaMap:i.emissiveMap?n=i.emissiveMap:i.clearcoatMap?n=i.clearcoatMap:i.clearcoatNormalMap?n=i.clearcoatNormalMap:i.clearcoatRoughnessMap?n=i.clearcoatRoughnessMap:i.specularIntensityMap?n=i.specularIntensityMap:i.specularColorMap?n=i.specularColorMap:i.transmissionMap?n=i.transmissionMap:i.thicknessMap?n=i.thicknessMap:i.sheenColorMap?n=i.sheenColorMap:i.sheenRoughnessMap&&(n=i.sheenRoughnessMap),void 0!==n&&(n.isWebGLRenderTarget&&(n=n.texture),!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix)),i.aoMap?r=i.aoMap:i.lightMap&&(r=i.lightMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uv2Transform.value.copy(r.matrix))}function i(e,i){e.roughness.value=i.roughness,e.metalness.value=i.metalness,i.roughnessMap&&(e.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(e.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(e.emissiveMap.value=i.emissiveMap),i.bumpMap&&(e.bumpMap.value=i.bumpMap,e.bumpScale.value=i.bumpScale,1===i.side&&(e.bumpScale.value*=-1)),i.normalMap&&(e.normalMap.value=i.normalMap,e.normalScale.value.copy(i.normalScale),1===i.side&&e.normalScale.value.negate()),i.displacementMap&&(e.displacementMap.value=i.displacementMap,e.displacementScale.value=i.displacementScale,e.displacementBias.value=i.displacementBias),t.get(i).envMap&&(e.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,s,n,r,o){s.isMeshBasicMaterial?e(t,s):s.isMeshLambertMaterial?(e(t,s),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,s)):s.isMeshToonMaterial?(e(t,s),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,s)):s.isMeshPhongMaterial?(e(t,s),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,s)):s.isMeshStandardMaterial?(e(t,s),s.isMeshPhysicalMaterial?function(t,e,s){i(t,e),t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap)),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,1===e.side&&t.clearcoatNormalScale.value.negate())),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=s.texture,t.transmissionSamplerSize.value.set(s.width,s.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap)}(t,s,o):i(t,s)):s.isMeshMatcapMaterial?(e(t,s),function(t,e){e.matcap&&(t.matcap.value=e.matcap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,s)):s.isMeshDepthMaterial?(e(t,s),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,s)):s.isMeshDistanceMaterial?(e(t,s),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,s)):s.isMeshNormalMaterial?(e(t,s),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,1===e.side&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),1===e.side&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,s)):s.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,s),s.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,s)):s.isPointsMaterial?function(t,e,i,s){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*i,t.scale.value=.5*s,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,s,n,r):s.isSpriteMaterial?function(t,e){let i;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?i=e.map:e.alphaMap&&(i=e.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}(t,s):s.isShadowMaterial?(t.color.value.copy(s.color),t.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function fr(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=K("canvas");return t.style.display="block",t}(),i=void 0!==t.context?t.context:null,s=void 0!==t.alpha&&t.alpha,n=void 0===t.depth||t.depth,r=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,h=void 0===t.premultipliedAlpha||t.premultipliedAlpha,u=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,_=void 0!==t.powerPreference?t.powerPreference:"default",f=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let g=null,x=null;const v=[],S=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=P,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const w=this;let b=!1,C=0,A=0,B=null,M=-1,V=null;const T=new mt,D=new mt;let I=null,E=e.width,R=e.height,L=1,G=null,F=null;const k=new mt(0,0,E,R),z=new mt(0,0,E,R);let O=!1;const N=new Vi;let U=!1,W=!1,j=null;const H=new qt,q=new pt,X={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function J(){return null===B?L:1}let Z,Y,Q,$,tt,et,it,st,nt,rt,ot,at,lt,ht,ct,dt,ft,yt,gt,xt,vt,St,wt,bt=i;function Ct(t,i){for(let s=0;s<t.length;s++){const n=t[s],r=e.getContext(n,i);if(null!==r)return r}return null}try{const t={alpha:!0,depth:n,stencil:r,antialias:a,premultipliedAlpha:h,preserveDrawingBuffer:u,powerPreference:_,failIfMajorPerformanceCaveat:f};if("setAttribute"in e&&e.setAttribute("data-engine","three.js r137"),e.addEventListener("webglcontextlost",Mt,!1),e.addEventListener("webglcontextrestored",Vt,!1),null===bt){const e=["webgl2","webgl","experimental-webgl"];if(!0===w.isWebGL1Renderer&&e.shift(),bt=Ct(e,t),null===bt)throw Ct(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===bt.getShaderPrecisionFormat&&(bt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function At(){Z=new ls(bt),Y=new ki(bt,Z,t),Z.init(Y),St=new lr(bt,Z,Y),Q=new or(bt,Z,Y),$=new ms(bt),tt=new qn,et=new ar(bt,Z,Q,tt,Y,St,$),it=new Oi(w),st=new as(w),nt=new Pi(bt,Y),wt=new Gi(bt,Z,nt,Y),rt=new hs(bt,nt,$,wt),ot=new ys(bt,rt,nt,$),gt=new fs(bt,Y,et),dt=new zi(tt),at=new Hn(w,it,st,Z,Y,wt,dt),lt=new pr(tt),ht=new Yn,ct=new ir(Z,Y),yt=new Li(w,it,Q,ot,s,h),ft=new rr(w,ot,Y),xt=new Fi(bt,Z,$,Y),vt=new cs(bt,Z,$,Y),$.programs=at.programs,w.capabilities=Y,w.extensions=Z,w.properties=tt,w.renderLists=ht,w.shadowMap=ft,w.state=Q,w.info=$}At();const Bt=new dr(w,bt);function Mt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function Vt(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const t=$.autoReset,e=ft.enabled,i=ft.autoUpdate,s=ft.needsUpdate,n=ft.type;At(),$.autoReset=t,ft.enabled=e,ft.autoUpdate=i,ft.needsUpdate=s,ft.type=n}function Tt(t){const e=t.target;e.removeEventListener("dispose",Tt),function(t){(function(t){const e=tt.get(t).programs;void 0!==e&&(e.forEach((function(t){at.releaseProgram(t)})),t.isShaderMaterial&&at.releaseShaderCache(t))})(t),tt.remove(t)}(e)}this.xr=Bt,this.getContext=function(){return bt},this.getContextAttributes=function(){return bt.getContextAttributes()},this.forceContextLoss=function(){const t=Z.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=Z.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(t){void 0!==t&&(L=t,this.setSize(E,R,!1))},this.getSize=function(t){return t.set(E,R)},this.setSize=function(t,i,s){Bt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(E=t,R=i,e.width=Math.floor(t*L),e.height=Math.floor(i*L),!1!==s&&(e.style.width=t+"px",e.style.height=i+"px"),this.setViewport(0,0,t,i))},this.getDrawingBufferSize=function(t){return t.set(E*L,R*L).floor()},this.setDrawingBufferSize=function(t,i,s){E=t,R=i,L=s,e.width=Math.floor(t*s),e.height=Math.floor(i*s),this.setViewport(0,0,t,i)},this.getCurrentViewport=function(t){return t.copy(T)},this.getViewport=function(t){return t.copy(k)},this.setViewport=function(t,e,i,s){t.isVector4?k.set(t.x,t.y,t.z,t.w):k.set(t,e,i,s),Q.viewport(T.copy(k).multiplyScalar(L).floor())},this.getScissor=function(t){return t.copy(z)},this.setScissor=function(t,e,i,s){t.isVector4?z.set(t.x,t.y,t.z,t.w):z.set(t,e,i,s),Q.scissor(D.copy(z).multiplyScalar(L).floor())},this.getScissorTest=function(){return O},this.setScissorTest=function(t){Q.setScissorTest(O=t)},this.setOpaqueSort=function(t){G=t},this.setTransparentSort=function(t){F=t},this.getClearColor=function(t){return t.copy(yt.getClearColor())},this.setClearColor=function(){yt.setClearColor.apply(yt,arguments)},this.getClearAlpha=function(){return yt.getClearAlpha()},this.setClearAlpha=function(){yt.setClearAlpha.apply(yt,arguments)},this.clear=function(t,e,i){let s=0;(void 0===t||t)&&(s|=16384),(void 0===e||e)&&(s|=256),(void 0===i||i)&&(s|=1024),bt.clear(s)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Mt,!1),e.removeEventListener("webglcontextrestored",Vt,!1),ht.dispose(),ct.dispose(),tt.dispose(),it.dispose(),st.dispose(),ot.dispose(),wt.dispose(),at.dispose(),Bt.dispose(),Bt.removeEventListener("sessionstart",Dt),Bt.removeEventListener("sessionend",It),j&&(j.dispose(),j=null),Et.stop()},this.renderBufferDirect=function(t,e,i,s,n,r){null===e&&(e=X);const o=n.isMesh&&n.matrixWorld.determinant()<0,a=function(t,e,i,s,n){!0!==e.isScene&&(e=X),et.resetTextureUnits();const r=e.fog,o=s.isMeshStandardMaterial?e.environment:null,a=null===B?w.outputEncoding:!0===B.isXRRenderTarget?B.texture.encoding:P,l=(s.isMeshStandardMaterial?st:it).get(s.envMap||o),h=!0===s.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,c=!!s.normalMap&&!!i.attributes.tangent,m=!!i.morphAttributes.position,u=!!i.morphAttributes.normal,_=i.morphAttributes.position?i.morphAttributes.position.length:0,d=s.toneMapped?w.toneMapping:0,p=tt.get(s),f=x.state.lights;if(!0===U&&(!0===W||t!==V)){const e=t===V&&s.id===M;dt.setState(s,t,e)}let y=!1;s.version===p.__version?p.needsLights&&p.lightsStateVersion!==f.state.version||p.outputEncoding!==a||n.isInstancedMesh&&!1===p.instancing?y=!0:n.isInstancedMesh||!0!==p.instancing?n.isSkinnedMesh&&!1===p.skinning?y=!0:n.isSkinnedMesh||!0!==p.skinning?p.envMap!==l||s.fog&&p.fog!==r?y=!0:void 0===p.numClippingPlanes||p.numClippingPlanes===dt.numPlanes&&p.numIntersection===dt.numIntersection?(p.vertexAlphas!==h||p.vertexTangents!==c||p.morphTargets!==m||p.morphNormals!==u||p.toneMapping!==d||!0===Y.isWebGL2&&p.morphTargetsCount!==_)&&(y=!0):y=!0:y=!0:y=!0:(y=!0,p.__version=s.version);let g=p.currentProgram;!0===y&&(g=kt(s,e,n));let v=!1,S=!1,b=!1;const C=g.getUniforms(),A=p.uniforms;if(Q.useProgram(g.program)&&(v=!0,S=!0,b=!0),s.id!==M&&(M=s.id,S=!0),v||V!==t){if(C.setValue(bt,"projectionMatrix",t.projectionMatrix),Y.logarithmicDepthBuffer&&C.setValue(bt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),V!==t&&(V=t,S=!0,b=!0),s.isShaderMaterial||s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshStandardMaterial||s.envMap){const e=C.map.cameraPosition;void 0!==e&&e.setValue(bt,q.setFromMatrixPosition(t.matrixWorld))}(s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshLambertMaterial||s.isMeshBasicMaterial||s.isMeshStandardMaterial||s.isShaderMaterial)&&C.setValue(bt,"isOrthographic",!0===t.isOrthographicCamera),(s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshLambertMaterial||s.isMeshBasicMaterial||s.isMeshStandardMaterial||s.isShaderMaterial||s.isShadowMaterial||n.isSkinnedMesh)&&C.setValue(bt,"viewMatrix",t.matrixWorldInverse)}if(n.isSkinnedMesh){C.setOptional(bt,n,"bindMatrix"),C.setOptional(bt,n,"bindMatrixInverse");const t=n.skeleton;t&&(Y.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),C.setValue(bt,"boneTexture",t.boneTexture,et),C.setValue(bt,"boneTextureSize",t.boneTextureSize)):C.setOptional(bt,t,"boneMatrices"))}var T,D;return!i||void 0===i.morphAttributes.position&&void 0===i.morphAttributes.normal||gt.update(n,i,s,g),(S||p.receiveShadow!==n.receiveShadow)&&(p.receiveShadow=n.receiveShadow,C.setValue(bt,"receiveShadow",n.receiveShadow)),S&&(C.setValue(bt,"toneMappingExposure",w.toneMappingExposure),p.needsLights&&(D=b,(T=A).ambientLightColor.needsUpdate=D,T.lightProbe.needsUpdate=D,T.directionalLights.needsUpdate=D,T.directionalLightShadows.needsUpdate=D,T.pointLights.needsUpdate=D,T.pointLightShadows.needsUpdate=D,T.spotLights.needsUpdate=D,T.spotLightShadows.needsUpdate=D,T.rectAreaLights.needsUpdate=D,T.hemisphereLights.needsUpdate=D),r&&s.fog&&lt.refreshFogUniforms(A,r),lt.refreshMaterialUniforms(A,s,L,R,j),bn.upload(bt,p.uniformsList,A,et)),s.isShaderMaterial&&!0===s.uniformsNeedUpdate&&(bn.upload(bt,p.uniformsList,A,et),s.uniformsNeedUpdate=!1),s.isSpriteMaterial&&C.setValue(bt,"center",n.center),C.setValue(bt,"modelViewMatrix",n.modelViewMatrix),C.setValue(bt,"normalMatrix",n.normalMatrix),C.setValue(bt,"modelMatrix",n.matrixWorld),g}(t,e,i,s,n);Q.setMaterial(s,o);let l=i.index;const h=i.attributes.position;if(null===l){if(void 0===h||0===h.count)return}else if(0===l.count)return;let c,m=1;!0===s.wireframe&&(l=rt.getWireframeAttribute(i),m=2),wt.setup(n,s,a,i,l);let u=xt;null!==l&&(c=nt.get(l),u=vt,u.setIndex(c));const _=null!==l?l.count:h.count,d=i.drawRange.start*m,p=i.drawRange.count*m,f=null!==r?r.start*m:0,y=null!==r?r.count*m:1/0,g=Math.max(d,f),v=Math.min(_,d+p,f+y)-1,S=Math.max(0,v-g+1);if(0!==S){if(n.isMesh)!0===s.wireframe?(Q.setLineWidth(s.wireframeLinewidth*J()),u.setMode(1)):u.setMode(4);else if(n.isLine){let t=s.linewidth;void 0===t&&(t=1),Q.setLineWidth(t*J()),n.isLineSegments?u.setMode(1):n.isLineLoop?u.setMode(2):u.setMode(3)}else n.isPoints?u.setMode(0):n.isSprite&&u.setMode(4);if(n.isInstancedMesh)u.renderInstances(g,S,n.count);else if(i.isInstancedBufferGeometry){const t=Math.min(i.instanceCount,i._maxInstanceCount);u.renderInstances(g,S,t)}else u.render(g,S)}},this.compile=function(t,e){x=ct.get(t),x.init(),S.push(x),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))})),x.setupLights(w.physicallyCorrectLights),t.traverse((function(e){const i=e.material;if(i)if(Array.isArray(i))for(let s=0;s<i.length;s++)kt(i[s],t,e);else kt(i,t,e)})),S.pop(),x=null};let Pt=null;function Dt(){Et.stop()}function It(){Et.start()}const Et=new Ti;function Rt(t,e,i,s){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)i=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)x.pushLight(t),t.castShadow&&x.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||N.intersectsSprite(t)){s&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);const e=ot.update(t),n=t.material;n.visible&&g.push(t,e,n,i,q.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==$.render.frame&&(t.skeleton.update(),t.skeleton.frame=$.render.frame),!t.frustumCulled||N.intersectsObject(t))){s&&q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);const e=ot.update(t),n=t.material;if(Array.isArray(n)){const s=e.groups;for(let r=0,o=s.length;r<o;r++){const o=s[r],a=n[o.materialIndex];a&&a.visible&&g.push(t,e,a,i,q.z,o)}}else n.visible&&g.push(t,e,n,i,q.z,null)}const n=t.children;for(let t=0,r=n.length;t<r;t++)Rt(n[t],e,i,s)}function Lt(t,e,i,s){const n=t.opaque,r=t.transmissive,h=t.transparent;x.setupLightsView(i),r.length>0&&function(t,e,i){if(null===j){const t=!0===a&&!0===Y.isWebGL2;j=new(t?_t:ut)(1024,1024,{generateMipmaps:!0,type:null!==St.convert(p)?p:m,minFilter:c,magFilter:l,wrapS:o,wrapT:o,useRenderToTexture:Z.has("WEBGL_multisampled_render_to_texture")})}const s=w.getRenderTarget();w.setRenderTarget(j),w.clear();const n=w.toneMapping;w.toneMapping=0,Gt(t,e,i),w.toneMapping=n,et.updateMultisampleRenderTarget(j),et.updateRenderTargetMipmap(j),w.setRenderTarget(s)}(n,e,i),s&&Q.viewport(T.copy(s)),n.length>0&&Gt(n,e,i),r.length>0&&Gt(r,e,i),h.length>0&&Gt(h,e,i)}function Gt(t,e,i){const s=!0===e.isScene?e.overrideMaterial:null;for(let n=0,r=t.length;n<r;n++){const r=t[n],o=r.object,a=r.geometry,l=null===s?r.material:s,h=r.group;o.layers.test(i.layers)&&Ft(o,e,i,a,l,h)}}function Ft(t,e,i,s,n,r){t.onBeforeRender(w,e,i,s,n,r),t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),n.onBeforeRender(w,e,i,s,t,r),!0===n.transparent&&2===n.side?(n.side=1,n.needsUpdate=!0,w.renderBufferDirect(i,e,s,n,t,r),n.side=0,n.needsUpdate=!0,w.renderBufferDirect(i,e,s,n,t,r),n.side=2):w.renderBufferDirect(i,e,s,n,t,r),t.onAfterRender(w,e,i,s,n,r)}function kt(t,e,i){!0!==e.isScene&&(e=X);const s=tt.get(t),n=x.state.lights,r=x.state.shadowsArray,o=n.state.version,a=at.getParameters(t,n.state,r,e,i),l=at.getProgramCacheKey(a);let h=s.programs;s.environment=t.isMeshStandardMaterial?e.environment:null,s.fog=e.fog,s.envMap=(t.isMeshStandardMaterial?st:it).get(t.envMap||s.environment),void 0===h&&(t.addEventListener("dispose",Tt),h=new Map,s.programs=h);let c=h.get(l);if(void 0!==c){if(s.currentProgram===c&&s.lightsStateVersion===o)return zt(t,a),c}else a.uniforms=at.getUniforms(t),t.onBuild(i,a,w),t.onBeforeCompile(a,w),c=at.acquireProgram(a,l),h.set(l,c),s.uniforms=a.uniforms;const m=s.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(m.clippingPlanes=dt.uniform),zt(t,a),s.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),s.lightsStateVersion=o,s.needsLights&&(m.ambientLightColor.value=n.state.ambient,m.lightProbe.value=n.state.probe,m.directionalLights.value=n.state.directional,m.directionalLightShadows.value=n.state.directionalShadow,m.spotLights.value=n.state.spot,m.spotLightShadows.value=n.state.spotShadow,m.rectAreaLights.value=n.state.rectArea,m.ltc_1.value=n.state.rectAreaLTC1,m.ltc_2.value=n.state.rectAreaLTC2,m.pointLights.value=n.state.point,m.pointLightShadows.value=n.state.pointShadow,m.hemisphereLights.value=n.state.hemi,m.directionalShadowMap.value=n.state.directionalShadowMap,m.directionalShadowMatrix.value=n.state.directionalShadowMatrix,m.spotShadowMap.value=n.state.spotShadowMap,m.spotShadowMatrix.value=n.state.spotShadowMatrix,m.pointShadowMap.value=n.state.pointShadowMap,m.pointShadowMatrix.value=n.state.pointShadowMatrix);const u=c.getUniforms(),_=bn.seqWithValue(u.seq,m);return s.currentProgram=c,s.uniformsList=_,c}function zt(t,e){const i=tt.get(t);i.outputEncoding=e.outputEncoding,i.instancing=e.instancing,i.skinning=e.skinning,i.morphTargets=e.morphTargets,i.morphNormals=e.morphNormals,i.morphTargetsCount=e.morphTargetsCount,i.numClippingPlanes=e.numClippingPlanes,i.numIntersection=e.numClipIntersection,i.vertexAlphas=e.vertexAlphas,i.vertexTangents=e.vertexTangents,i.toneMapping=e.toneMapping}Et.setAnimationLoop((function(t){Pt&&Pt(t)})),"undefined"!=typeof window&&Et.setContext(window),this.setAnimationLoop=function(t){Pt=t,Bt.setAnimationLoop(t),null===t?Et.stop():Et.start()},Bt.addEventListener("sessionstart",Dt),Bt.addEventListener("sessionend",It),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===b)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===Bt.enabled&&!0===Bt.isPresenting&&(!0===Bt.cameraAutoUpdate&&Bt.updateCamera(e),e=Bt.getCamera()),!0===t.isScene&&t.onBeforeRender(w,t,e,B),x=ct.get(t,S.length),x.init(),S.push(x),H.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),N.setFromProjectionMatrix(H),W=this.localClippingEnabled,U=dt.init(this.clippingPlanes,W,e),g=ht.get(t,v.length),g.init(),v.push(g),Rt(t,e,0,w.sortObjects),g.finish(),!0===w.sortObjects&&g.sort(G,F),!0===U&&dt.beginShadows();const i=x.state.shadowsArray;if(ft.render(i,t,e),!0===U&&dt.endShadows(),!0===this.info.autoReset&&this.info.reset(),yt.render(g,t),x.setupLights(w.physicallyCorrectLights),e.isArrayCamera){const i=e.cameras;for(let e=0,s=i.length;e<s;e++){const s=i[e];Lt(g,t,s,s.viewport)}}else Lt(g,t,e);null!==B&&(et.updateMultisampleRenderTarget(B),et.updateRenderTargetMipmap(B)),!0===t.isScene&&t.onAfterRender(w,t,e),Q.buffers.depth.setTest(!0),Q.buffers.depth.setMask(!0),Q.buffers.color.setMask(!0),Q.setPolygonOffset(!1),wt.resetDefaultState(),M=-1,V=null,S.pop(),x=S.length>0?S[S.length-1]:null,v.pop(),g=v.length>0?v[v.length-1]:null},this.getActiveCubeFace=function(){return C},this.getActiveMipmapLevel=function(){return A},this.getRenderTarget=function(){return B},this.setRenderTargetTextures=function(t,e,i){tt.get(t.texture).__webglTexture=e,tt.get(t.depthTexture).__webglTexture=i;const s=tt.get(t);s.__hasExternalTextures=!0,s.__hasExternalTextures&&(s.__autoAllocateDepthBuffer=void 0===i,s.__autoAllocateDepthBuffer||t.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),t.useRenderToTexture=!1,t.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(t,e){const i=tt.get(t);i.__webglFramebuffer=e,i.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,i=0){B=t,C=e,A=i;let s=!0;if(t){const e=tt.get(t);void 0!==e.__useDefaultFramebuffer?(Q.bindFramebuffer(36160,null),s=!1):void 0===e.__webglFramebuffer?et.setupRenderTarget(t):e.__hasExternalTextures&&et.rebindTextures(t,tt.get(t.texture).__webglTexture,tt.get(t.depthTexture).__webglTexture)}let n=null,r=!1,o=!1;if(t){const i=t.texture;(i.isDataTexture3D||i.isDataTexture2DArray)&&(o=!0);const s=tt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(n=s[e],r=!0):n=t.useRenderbuffer?tt.get(t).__webglMultisampledFramebuffer:s,T.copy(t.viewport),D.copy(t.scissor),I=t.scissorTest}else T.copy(k).multiplyScalar(L).floor(),D.copy(z).multiplyScalar(L).floor(),I=O;if(Q.bindFramebuffer(36160,n)&&Y.drawBuffers&&s&&Q.drawBuffers(t,n),Q.viewport(T),Q.scissor(D),Q.setScissorTest(I),r){const s=tt.get(t.texture);bt.framebufferTexture2D(36160,36064,34069+e,s.__webglTexture,i)}else if(o){const s=tt.get(t.texture),n=e||0;bt.framebufferTextureLayer(36160,36064,s.__webglTexture,i||0,n)}M=-1},this.readRenderTargetPixels=function(t,e,i,s,n,r,o){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let a=tt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(a=a[o]),a){Q.bindFramebuffer(36160,a);try{const o=t.texture,a=o.format,l=o.type;if(a!==y&&St.convert(a)!==bt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const h=l===p&&(Z.has("EXT_color_buffer_half_float")||Y.isWebGL2&&Z.has("EXT_color_buffer_float"));if(!(l===m||St.convert(l)===bt.getParameter(35738)||l===d&&(Y.isWebGL2||Z.has("OES_texture_float")||Z.has("WEBGL_color_buffer_float"))||h))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===bt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-s&&i>=0&&i<=t.height-n&&bt.readPixels(e,i,s,n,St.convert(a),St.convert(l),r):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==B?tt.get(B).__webglFramebuffer:null;Q.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,i=0){if(!0!==e.isFramebufferTexture)return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");const s=Math.pow(2,-i),n=Math.floor(e.image.width*s),r=Math.floor(e.image.height*s);et.setTexture2D(e,0),bt.copyTexSubImage2D(3553,i,0,0,t.x,t.y,n,r),Q.unbindTexture()},this.copyTextureToTexture=function(t,e,i,s=0){const n=e.image.width,r=e.image.height,o=St.convert(i.format),a=St.convert(i.type);et.setTexture2D(i,0),bt.pixelStorei(37440,i.flipY),bt.pixelStorei(37441,i.premultiplyAlpha),bt.pixelStorei(3317,i.unpackAlignment),e.isDataTexture?bt.texSubImage2D(3553,s,t.x,t.y,n,r,o,a,e.image.data):e.isCompressedTexture?bt.compressedTexSubImage2D(3553,s,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,o,e.mipmaps[0].data):bt.texSubImage2D(3553,s,t.x,t.y,o,a,e.image),0===s&&i.generateMipmaps&&bt.generateMipmap(3553),Q.unbindTexture()},this.copyTextureToTexture3D=function(t,e,i,s,n=0){if(w.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const r=t.max.x-t.min.x+1,o=t.max.y-t.min.y+1,a=t.max.z-t.min.z+1,l=St.convert(s.format),h=St.convert(s.type);let c;if(s.isDataTexture3D)et.setTexture3D(s,0),c=32879;else{if(!s.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");et.setTexture2DArray(s,0),c=35866}bt.pixelStorei(37440,s.flipY),bt.pixelStorei(37441,s.premultiplyAlpha),bt.pixelStorei(3317,s.unpackAlignment);const m=bt.getParameter(3314),u=bt.getParameter(32878),_=bt.getParameter(3316),d=bt.getParameter(3315),p=bt.getParameter(32877),f=i.isCompressedTexture?i.mipmaps[0]:i.image;bt.pixelStorei(3314,f.width),bt.pixelStorei(32878,f.height),bt.pixelStorei(3316,t.min.x),bt.pixelStorei(3315,t.min.y),bt.pixelStorei(32877,t.min.z),i.isDataTexture||i.isDataTexture3D?bt.texSubImage3D(c,n,e.x,e.y,e.z,r,o,a,l,h,f.data):i.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),bt.compressedTexSubImage3D(c,n,e.x,e.y,e.z,r,o,a,l,f.data)):bt.texSubImage3D(c,n,e.x,e.y,e.z,r,o,a,l,h,f),bt.pixelStorei(3314,m),bt.pixelStorei(32878,u),bt.pixelStorei(3316,_),bt.pixelStorei(3315,d),bt.pixelStorei(32877,p),0===n&&s.generateMipmaps&&bt.generateMipmap(c),Q.unbindTexture()},this.initTexture=function(t){et.setTexture2D(t,0),Q.unbindTexture()},this.resetState=function(){C=0,A=0,B=null,Q.reset(),wt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}fr.prototype.isWebGLRenderer=!0,class extends fr{}.prototype.isWebGL1Renderer=!0;class yr{constructor(t,e=25e-5){this.name="",this.color=new rt(t),this.density=e}clone(){return new yr(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}yr.prototype.isFogExp2=!0;class gr{constructor(t,e=1,i=1e3){this.name="",this.color=new rt(t),this.near=e,this.far=i}clone(){return new gr(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}gr.prototype.isFog=!0;class xr extends ye{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}xr.prototype.isScene=!0;class vr{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=E,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=U()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,n=this.stride;s<n;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=U()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=U()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}vr.prototype.isInterleavedBuffer=!0;const Sr=new pt;class wr{constructor(t,e,i,s=!1){this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=!0===s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)Sr.x=this.getX(e),Sr.y=this.getY(e),Sr.z=this.getZ(e),Sr.applyMatrix4(t),this.setXYZ(e,Sr.x,Sr.y,Sr.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Sr.x=this.getX(e),Sr.y=this.getY(e),Sr.z=this.getZ(e),Sr.applyNormalMatrix(t),this.setXYZ(e,Sr.x,Sr.y,Sr.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Sr.x=this.getX(e),Sr.y=this.getY(e),Sr.z=this.getZ(e),Sr.transformDirection(t),this.setXYZ(e,Sr.x,Sr.y,Sr.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=n,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return new Re(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new wr(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}wr.prototype.isInterleavedBufferAttribute=!0;class br extends Pe{constructor(t){super(),this.type="SpriteMaterial",this.color=new rt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}let Cr;br.prototype.isSpriteMaterial=!0;const Ar=new pt,Br=new pt,Mr=new pt,Vr=new Z,Tr=new Z,Pr=new qt,Dr=new pt,Ir=new pt,Er=new pt,Rr=new Z,Lr=new Z,Gr=new Z;function Fr(t,e,i,s,n,r){Vr.subVectors(t,i).addScalar(.5).multiply(s),void 0!==n?(Tr.x=r*Vr.x-n*Vr.y,Tr.y=n*Vr.x+r*Vr.y):Tr.copy(Vr),t.copy(e),t.x+=Tr.x,t.y+=Tr.y,t.applyMatrix4(Pr)}(class extends ye{constructor(t){if(super(),this.type="Sprite",void 0===Cr){Cr=new He;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new vr(t,5);Cr.setIndex([0,1,2,0,2,3]),Cr.setAttribute("position",new wr(e,3,0,!1)),Cr.setAttribute("uv",new wr(e,2,3,!1))}this.geometry=Cr,this.material=void 0!==t?t:new br,this.center=new Z(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Br.setFromMatrixScale(this.matrixWorld),Pr.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Mr.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Br.multiplyScalar(-Mr.z);const i=this.material.rotation;let s,n;0!==i&&(n=Math.cos(i),s=Math.sin(i));const r=this.center;Fr(Dr.set(-.5,-.5,0),Mr,r,Br,s,n),Fr(Ir.set(.5,-.5,0),Mr,r,Br,s,n),Fr(Er.set(.5,.5,0),Mr,r,Br,s,n),Rr.set(0,0),Lr.set(1,0),Gr.set(1,1);let o=t.ray.intersectTriangle(Dr,Ir,Er,!1,Ar);if(null===o&&(Fr(Ir.set(-.5,.5,0),Mr,r,Br,s,n),Lr.set(0,1),o=t.ray.intersectTriangle(Dr,Er,Ir,!1,Ar),null===o))return;const a=t.ray.origin.distanceTo(Ar);a<t.near||a>t.far||e.push({distance:a,point:Ar.clone(),uv:Ve.getUV(Ar,Dr,Ir,Er,Rr,Lr,Gr,new Z),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}).prototype.isSprite=!0;const kr=new pt,zr=new mt,Or=new mt,Nr=new pt,Ur=new qt;class Wr extends hi{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new qt,this.bindMatrixInverse=new qt}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new mt,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.x=e.getX(i),t.y=e.getY(i),t.z=e.getZ(i),t.w=e.getW(i);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const i=this.skeleton,s=this.geometry;zr.fromBufferAttribute(s.attributes.skinIndex,t),Or.fromBufferAttribute(s.attributes.skinWeight,t),kr.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const s=Or.getComponent(t);if(0!==s){const n=zr.getComponent(t);Ur.multiplyMatrices(i.bones[n].matrixWorld,i.boneInverses[n]),e.addScaledVector(Nr.copy(kr).applyMatrix4(Ur),s)}}return e.applyMatrix4(this.bindMatrixInverse)}}Wr.prototype.isSkinnedMesh=!0;(class extends ye{constructor(){super(),this.type="Bone"}}).prototype.isBone=!0;(class extends ht{constructor(t=null,e=1,i=1,s,n,r,o,a,l=1003,h=1003,c,m){super(null,r,o,a,l,h,s,n,c,m),this.image={data:t,width:e,height:i},this.magFilter=l,this.minFilter=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}).prototype.isDataTexture=!0;class jr extends Re{constructor(t,e,i,s=1){"number"==typeof i&&(s=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,i),this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}jr.prototype.isInstancedBufferAttribute=!0;const Hr=new qt,qr=new qt,Xr=[],Jr=new hi;(class extends hi{constructor(t,e,i){super(t,e),this.instanceMatrix=new jr(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const i=this.matrixWorld,s=this.count;if(Jr.geometry=this.geometry,Jr.material=this.material,void 0!==Jr.material)for(let n=0;n<s;n++){this.getMatrixAt(n,Hr),qr.multiplyMatrices(i,Hr),Jr.matrixWorld=qr,Jr.raycast(t,Xr);for(let t=0,i=Xr.length;t<i;t++){const i=Xr[t];i.instanceId=n,i.object=this,e.push(i)}Xr.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new jr(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;class Zr extends Pe{constructor(t){super(),this.type="LineBasicMaterial",this.color=new rt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}Zr.prototype.isLineBasicMaterial=!0;const Yr=new pt,Qr=new pt,Kr=new qt,$r=new Ht,to=new Ft;class eo extends ye{constructor(t=new He,e=new Zr){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,i=[0];for(let t=1,s=e.count;t<s;t++)Yr.fromBufferAttribute(e,t-1),Qr.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=Yr.distanceTo(Qr);t.setAttribute("lineDistance",new Fe(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Line.threshold,r=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),to.copy(i.boundingSphere),to.applyMatrix4(s),to.radius+=n,!1===t.ray.intersectsSphere(to))return;Kr.copy(s).invert(),$r.copy(t.ray).applyMatrix4(Kr);const o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=new pt,h=new pt,c=new pt,m=new pt,u=this.isLineSegments?2:1;if(i.isBufferGeometry){const s=i.index,n=i.attributes.position;if(null!==s)for(let i=Math.max(0,r.start),o=Math.min(s.count,r.start+r.count)-1;i<o;i+=u){const r=s.getX(i),o=s.getX(i+1);if(l.fromBufferAttribute(n,r),h.fromBufferAttribute(n,o),$r.distanceSqToSegment(l,h,m,c)>a)continue;m.applyMatrix4(this.matrixWorld);const u=t.ray.origin.distanceTo(m);u<t.near||u>t.far||e.push({distance:u,point:c.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}else for(let i=Math.max(0,r.start),s=Math.min(n.count,r.start+r.count)-1;i<s;i+=u){if(l.fromBufferAttribute(n,i),h.fromBufferAttribute(n,i+1),$r.distanceSqToSegment(l,h,m,c)>a)continue;m.applyMatrix4(this.matrixWorld);const s=t.ray.origin.distanceTo(m);s<t.near||s>t.far||e.push({distance:s,point:c.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}else i.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){const i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}eo.prototype.isLine=!0;const io=new pt,so=new pt;class no extends eo{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,i=[];for(let t=0,s=e.count;t<s;t+=2)io.fromBufferAttribute(e,t),so.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+io.distanceTo(so);t.setAttribute("lineDistance",new Fe(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}no.prototype.isLineSegments=!0;(class extends eo{constructor(t,e){super(t,e),this.type="LineLoop"}}).prototype.isLineLoop=!0;class ro extends Pe{constructor(t){super(),this.type="PointsMaterial",this.color=new rt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}ro.prototype.isPointsMaterial=!0;const oo=new qt,ao=new Ht,lo=new Ft,ho=new pt;function co(t,e,i,s,n,r,o){const a=ao.distanceSqToPoint(t);if(a<i){const i=new pt;ao.closestPointToPoint(t,i),i.applyMatrix4(s);const l=n.ray.origin.distanceTo(i);if(l<n.near||l>n.far)return;r.push({distance:l,distanceToRay:Math.sqrt(a),point:i,index:e,face:null,object:o})}}(class extends ye{constructor(t=new He,e=new ro){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Points.threshold,r=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),lo.copy(i.boundingSphere),lo.applyMatrix4(s),lo.radius+=n,!1===t.ray.intersectsSphere(lo))return;oo.copy(s).invert(),ao.copy(t.ray).applyMatrix4(oo);const o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o;if(i.isBufferGeometry){const n=i.index,o=i.attributes.position;if(null!==n)for(let i=Math.max(0,r.start),l=Math.min(n.count,r.start+r.count);i<l;i++){const r=n.getX(i);ho.fromBufferAttribute(o,r),co(ho,r,a,s,t,e,this)}else for(let i=Math.max(0,r.start),n=Math.min(o.count,r.start+r.count);i<n;i++)ho.fromBufferAttribute(o,i),co(ho,i,a,s,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){const i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}).prototype.isPoints=!0,class extends ht{constructor(t,e,i,s,n,r,o,a,l){super(t,e,i,s,n,r,o,a,l),this.minFilter=void 0!==r?r:h,this.magFilter=void 0!==n?n:h,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}.prototype.isVideoTexture=!0,class extends ht{constructor(t,e,i){super({width:t,height:e}),this.format=i,this.magFilter=l,this.minFilter=l,this.generateMipmaps=!1,this.needsUpdate=!0}}.prototype.isFramebufferTexture=!0;(class extends ht{constructor(t,e,i,s,n,r,o,a,l,h,c,m){super(null,r,o,a,l,h,s,n,c,m),this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0,class extends ht{constructor(t,e,i,s,n,r,o,a,l){super(t,e,i,s,n,r,o,a,l),this.needsUpdate=!0}}.prototype.isCanvasTexture=!0,new pt,new pt,new pt,new Ve;class mo{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),n=0;e.push(0);for(let r=1;r<=t;r++)i=this.getPoint(r/t),n+=i.distanceTo(s),e.push(n),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const n=i.length;let r;r=e||t*i[n-1];let o,a=0,l=n-1;for(;a<=l;)if(s=Math.floor(a+(l-a)/2),o=i[s]-r,o<0)a=s+1;else{if(!(o>0)){l=s;break}l=s-1}if(s=l,i[s]===r)return s/(n-1);const h=i[s];return(s+(r-h)/(i[s+1]-h))/(n-1)}getTangent(t,e){const i=1e-4;let s=t-i,n=t+i;s<0&&(s=0),n>1&&(n=1);const r=this.getPoint(s),o=this.getPoint(n),a=e||(r.isVector2?new Z:new pt);return a.copy(o).sub(r).normalize(),a}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new pt,s=[],n=[],r=[],o=new pt,a=new qt;for(let e=0;e<=t;e++){const i=e/t;s[e]=this.getTangentAt(i,new pt)}n[0]=new pt,r[0]=new pt;let l=Number.MAX_VALUE;const h=Math.abs(s[0].x),c=Math.abs(s[0].y),m=Math.abs(s[0].z);h<=l&&(l=h,i.set(1,0,0)),c<=l&&(l=c,i.set(0,1,0)),m<=l&&i.set(0,0,1),o.crossVectors(s[0],i).normalize(),n[0].crossVectors(s[0],o),r[0].crossVectors(s[0],n[0]);for(let e=1;e<=t;e++){if(n[e]=n[e-1].clone(),r[e]=r[e-1].clone(),o.crossVectors(s[e-1],s[e]),o.length()>Number.EPSILON){o.normalize();const t=Math.acos(W(s[e-1].dot(s[e]),-1,1));n[e].applyMatrix4(a.makeRotationAxis(o,t))}r[e].crossVectors(s[e],n[e])}if(!0===e){let e=Math.acos(W(n[0].dot(n[t]),-1,1));e/=t,s[0].dot(o.crossVectors(n[0],n[t]))>0&&(e=-e);for(let i=1;i<=t;i++)n[i].applyMatrix4(a.makeRotationAxis(s[i],e*i)),r[i].crossVectors(s[i],n[i])}return{tangents:s,normals:n,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class uo extends mo{constructor(t=0,e=0,i=1,s=1,n=0,r=2*Math.PI,o=!1,a=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=s,this.aStartAngle=n,this.aEndAngle=r,this.aClockwise=o,this.aRotation=a}getPoint(t,e){const i=e||new Z,s=2*Math.PI;let n=this.aEndAngle-this.aStartAngle;const r=Math.abs(n)<Number.EPSILON;for(;n<0;)n+=s;for(;n>s;)n-=s;n<Number.EPSILON&&(n=r?0:s),!0!==this.aClockwise||r||(n===s?n=-s:n-=s);const o=this.aStartAngle+t*n;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),i=a-this.aX,s=l-this.aY;a=i*t-s*e+this.aX,l=i*e+s*t+this.aY}return i.set(a,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}uo.prototype.isEllipseCurve=!0;class _o extends uo{constructor(t,e,i,s,n,r){super(t,e,i,i,s,n,r),this.type="ArcCurve"}}function po(){let t=0,e=0,i=0,s=0;function n(n,r,o,a){t=n,e=o,i=-3*n+3*r-2*o-a,s=2*n-2*r+o+a}return{initCatmullRom:function(t,e,i,s,r){n(e,i,r*(i-t),r*(s-e))},initNonuniformCatmullRom:function(t,e,i,s,r,o,a){let l=(e-t)/r-(i-t)/(r+o)+(i-e)/o,h=(i-e)/o-(s-e)/(o+a)+(s-i)/a;l*=o,h*=o,n(e,i,l,h)},calc:function(n){const r=n*n;return t+e*n+i*r+s*(r*n)}}}_o.prototype.isArcCurve=!0;const fo=new pt,yo=new po,go=new po,xo=new po;class vo extends mo{constructor(t=[],e=!1,i="centripetal",s=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=s}getPoint(t,e=new pt){const i=e,s=this.points,n=s.length,r=(n-(this.closed?0:1))*t;let o,a,l=Math.floor(r),h=r-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/n)+1)*n:0===h&&l===n-1&&(l=n-2,h=1),this.closed||l>0?o=s[(l-1)%n]:(fo.subVectors(s[0],s[1]).add(s[0]),o=fo);const c=s[l%n],m=s[(l+1)%n];if(this.closed||l+2<n?a=s[(l+2)%n]:(fo.subVectors(s[n-1],s[n-2]).add(s[n-1]),a=fo),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(o.distanceToSquared(c),t),i=Math.pow(c.distanceToSquared(m),t),s=Math.pow(m.distanceToSquared(a),t);i<1e-4&&(i=1),e<1e-4&&(e=i),s<1e-4&&(s=i),yo.initNonuniformCatmullRom(o.x,c.x,m.x,a.x,e,i,s),go.initNonuniformCatmullRom(o.y,c.y,m.y,a.y,e,i,s),xo.initNonuniformCatmullRom(o.z,c.z,m.z,a.z,e,i,s)}else"catmullrom"===this.curveType&&(yo.initCatmullRom(o.x,c.x,m.x,a.x,this.tension),go.initCatmullRom(o.y,c.y,m.y,a.y,this.tension),xo.initCatmullRom(o.z,c.z,m.z,a.z,this.tension));return i.set(yo.calc(h),go.calc(h),xo.calc(h)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new pt).fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function So(t,e,i,s,n){const r=.5*(s-e),o=.5*(n-i),a=t*t;return(2*i-2*s+r+o)*(t*a)+(-3*i+3*s-2*r-o)*a+r*t+i}function wo(t,e,i,s){return function(t,e){const i=1-t;return i*i*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,i)+function(t,e){return t*t*e}(t,s)}function bo(t,e,i,s,n){return function(t,e){const i=1-t;return i*i*i*e}(t,e)+function(t,e){const i=1-t;return 3*i*i*t*e}(t,i)+function(t,e){return 3*(1-t)*t*t*e}(t,s)+function(t,e){return t*t*t*e}(t,n)}vo.prototype.isCatmullRomCurve3=!0;class Co extends mo{constructor(t=new Z,e=new Z,i=new Z,s=new Z){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new Z){const i=e,s=this.v0,n=this.v1,r=this.v2,o=this.v3;return i.set(bo(t,s.x,n.x,r.x,o.x),bo(t,s.y,n.y,r.y,o.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Co.prototype.isCubicBezierCurve=!0;class Ao extends mo{constructor(t=new pt,e=new pt,i=new pt,s=new pt){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new pt){const i=e,s=this.v0,n=this.v1,r=this.v2,o=this.v3;return i.set(bo(t,s.x,n.x,r.x,o.x),bo(t,s.y,n.y,r.y,o.y),bo(t,s.z,n.z,r.z,o.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Ao.prototype.isCubicBezierCurve3=!0;class Bo extends mo{constructor(t=new Z,e=new Z){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Z){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const i=e||new Z;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Bo.prototype.isLineCurve=!0;class Mo extends mo{constructor(t=new Z,e=new Z,i=new Z){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new Z){const i=e,s=this.v0,n=this.v1,r=this.v2;return i.set(wo(t,s.x,n.x,r.x),wo(t,s.y,n.y,r.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Mo.prototype.isQuadraticBezierCurve=!0;class Vo extends mo{constructor(t=new pt,e=new pt,i=new pt){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new pt){const i=e,s=this.v0,n=this.v1,r=this.v2;return i.set(wo(t,s.x,n.x,r.x),wo(t,s.y,n.y,r.y),wo(t,s.z,n.z,r.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Vo.prototype.isQuadraticBezierCurve3=!0;class To extends mo{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new Z){const i=e,s=this.points,n=(s.length-1)*t,r=Math.floor(n),o=n-r,a=s[0===r?r:r-1],l=s[r],h=s[r>s.length-2?s.length-1:r+1],c=s[r>s.length-3?s.length-1:r+2];return i.set(So(o,a.x,l.x,h.x,c.x),So(o,a.y,l.y,h.y,c.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new Z).fromArray(i))}return this}}To.prototype.isSplineCurve=!0;var Po=Object.freeze({__proto__:null,ArcCurve:_o,CatmullRomCurve3:vo,CubicBezierCurve:Co,CubicBezierCurve3:Ao,EllipseCurve:uo,LineCurve:Bo,LineCurve3:class extends mo{constructor(t=new pt,e=new pt){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new pt){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}},QuadraticBezierCurve:Mo,QuadraticBezierCurve3:Vo,SplineCurve:To});class Do extends mo{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Bo(e,t))}getPoint(t,e){const i=t*this.getLength(),s=this.getCurveLengths();let n=0;for(;n<s.length;){if(s[n]>=i){const t=s[n]-i,r=this.curves[n],o=r.getLength(),a=0===o?0:1-t/o;return r.getPointAt(a,e)}n++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,s=this.curves.length;i<s;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let s=0,n=this.curves;s<n.length;s++){const r=n[s],o=r&&r.isEllipseCurve?2*t:r&&(r.isLineCurve||r.isLineCurve3)?1:r&&r.isSplineCurve?t*r.points.length:t,a=r.getPoints(o);for(let t=0;t<a.length;t++){const s=a[t];i&&i.equals(s)||(e.push(s),i=s)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push((new Po[i.type]).fromJSON(i))}return this}}class Io extends Do{constructor(t){super(),this.type="Path",this.currentPoint=new Z,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new Bo(this.currentPoint.clone(),new Z(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,s){const n=new Mo(this.currentPoint.clone(),new Z(t,e),new Z(i,s));return this.curves.push(n),this.currentPoint.set(i,s),this}bezierCurveTo(t,e,i,s,n,r){const o=new Co(this.currentPoint.clone(),new Z(t,e),new Z(i,s),new Z(n,r));return this.curves.push(o),this.currentPoint.set(n,r),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new To(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,s,n,r){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,i,s,n,r),this}absarc(t,e,i,s,n,r){return this.absellipse(t,e,i,i,s,n,r),this}ellipse(t,e,i,s,n,r,o,a){const l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+l,e+h,i,s,n,r,o,a),this}absellipse(t,e,i,s,n,r,o,a){const l=new uo(t,e,i,s,n,r,o,a);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Eo extends Io{constructor(t){super(t),this.uuid=U(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,s=this.holes.length;i<s;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push((new Io).fromJSON(i))}return this}}function Ro(t,e,i,s,n){let r,o;if(n===function(t,e,i,s){let n=0;for(let r=e,o=i-s;r<i;r+=s)n+=(t[o]-t[r])*(t[r+1]+t[o+1]),o=r;return n}(t,e,i,s)>0)for(r=e;r<i;r+=s)o=ea(r,t[r],t[r+1],o);else for(r=i-s;r>=e;r-=s)o=ea(r,t[r],t[r+1],o);return o&&Zo(o,o.next)&&(ia(o),o=o.next),o}function Lo(t,e){if(!t)return t;e||(e=t);let i,s=t;do{if(i=!1,s.steiner||!Zo(s,s.next)&&0!==Jo(s.prev,s,s.next))s=s.next;else{if(ia(s),s=e=s.prev,s===s.next)break;i=!0}}while(i||s!==e);return e}function Go(t,e,i,s,n,r,o){if(!t)return;!o&&r&&function(t,e,i,s){let n=t;do{null===n.z&&(n.z=jo(n.x,n.y,e,i,s)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==t);n.prevZ.nextZ=null,n.prevZ=null,function(t){let e,i,s,n,r,o,a,l,h=1;do{for(i=t,t=null,r=null,o=0;i;){for(o++,s=i,a=0,e=0;e<h&&(a++,s=s.nextZ,s);e++);for(l=h;a>0||l>0&&s;)0!==a&&(0===l||!s||i.z<=s.z)?(n=i,i=i.nextZ,a--):(n=s,s=s.nextZ,l--),r?r.nextZ=n:t=n,n.prevZ=r,r=n;i=s}r.nextZ=null,h*=2}while(o>1)}(n)}(t,s,n,r);let a,l,h=t;for(;t.prev!==t.next;)if(a=t.prev,l=t.next,r?ko(t,s,n,r):Fo(t))e.push(a.i/i),e.push(t.i/i),e.push(l.i/i),ia(t),t=l.next,h=l.next;else if((t=l)===h){o?1===o?Go(t=zo(Lo(t),e,i),e,i,s,n,r,2):2===o&&Oo(t,e,i,s,n,r):Go(Lo(t),e,i,s,n,r,1);break}}function Fo(t){const e=t.prev,i=t,s=t.next;if(Jo(e,i,s)>=0)return!1;let n=t.next.next;for(;n!==t.prev;){if(qo(e.x,e.y,i.x,i.y,s.x,s.y,n.x,n.y)&&Jo(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}function ko(t,e,i,s){const n=t.prev,r=t,o=t.next;if(Jo(n,r,o)>=0)return!1;const a=n.x<r.x?n.x<o.x?n.x:o.x:r.x<o.x?r.x:o.x,l=n.y<r.y?n.y<o.y?n.y:o.y:r.y<o.y?r.y:o.y,h=n.x>r.x?n.x>o.x?n.x:o.x:r.x>o.x?r.x:o.x,c=n.y>r.y?n.y>o.y?n.y:o.y:r.y>o.y?r.y:o.y,m=jo(a,l,e,i,s),u=jo(h,c,e,i,s);let _=t.prevZ,d=t.nextZ;for(;_&&_.z>=m&&d&&d.z<=u;){if(_!==t.prev&&_!==t.next&&qo(n.x,n.y,r.x,r.y,o.x,o.y,_.x,_.y)&&Jo(_.prev,_,_.next)>=0)return!1;if(_=_.prevZ,d!==t.prev&&d!==t.next&&qo(n.x,n.y,r.x,r.y,o.x,o.y,d.x,d.y)&&Jo(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;_&&_.z>=m;){if(_!==t.prev&&_!==t.next&&qo(n.x,n.y,r.x,r.y,o.x,o.y,_.x,_.y)&&Jo(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;d&&d.z<=u;){if(d!==t.prev&&d!==t.next&&qo(n.x,n.y,r.x,r.y,o.x,o.y,d.x,d.y)&&Jo(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function zo(t,e,i){let s=t;do{const n=s.prev,r=s.next.next;!Zo(n,r)&&Yo(n,s,s.next,r)&&$o(n,r)&&$o(r,n)&&(e.push(n.i/i),e.push(s.i/i),e.push(r.i/i),ia(s),ia(s.next),s=t=r),s=s.next}while(s!==t);return Lo(s)}function Oo(t,e,i,s,n,r){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&Xo(o,t)){let a=ta(o,t);return o=Lo(o,o.next),a=Lo(a,a.next),Go(o,e,i,s,n,r),void Go(a,e,i,s,n,r)}t=t.next}o=o.next}while(o!==t)}function No(t,e){return t.x-e.x}function Uo(t,e){if(e=function(t,e){let i=e;const s=t.x,n=t.y;let r,o=-1/0;do{if(n<=i.y&&n>=i.next.y&&i.next.y!==i.y){const t=i.x+(n-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(t<=s&&t>o){if(o=t,t===s){if(n===i.y)return i;if(n===i.next.y)return i.next}r=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e);if(!r)return null;if(s===o)return r;const a=r,l=r.x,h=r.y;let c,m=1/0;i=r;do{s>=i.x&&i.x>=l&&s!==i.x&&qo(n<h?s:o,n,l,h,n<h?o:s,n,i.x,i.y)&&(c=Math.abs(n-i.y)/(s-i.x),$o(i,t)&&(c<m||c===m&&(i.x>r.x||i.x===r.x&&Wo(r,i)))&&(r=i,m=c)),i=i.next}while(i!==a);return r}(t,e),e){const i=ta(e,t);Lo(e,e.next),Lo(i,i.next)}}function Wo(t,e){return Jo(t.prev,t,e.prev)<0&&Jo(e.next,t,t.next)<0}function jo(t,e,i,s,n){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*n)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*n)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ho(t){let e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function qo(t,e,i,s,n,r,o,a){return(n-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(s-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(n-o)*(s-a)>=0}function Xo(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&Yo(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&($o(t,e)&&$o(e,t)&&function(t,e){let i=t,s=!1;const n=(t.x+e.x)/2,r=(t.y+e.y)/2;do{i.y>r!=i.next.y>r&&i.next.y!==i.y&&n<(i.next.x-i.x)*(r-i.y)/(i.next.y-i.y)+i.x&&(s=!s),i=i.next}while(i!==t);return s}(t,e)&&(Jo(t.prev,t,e.prev)||Jo(t,e.prev,e))||Zo(t,e)&&Jo(t.prev,t,t.next)>0&&Jo(e.prev,e,e.next)>0)}function Jo(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function Zo(t,e){return t.x===e.x&&t.y===e.y}function Yo(t,e,i,s){const n=Ko(Jo(t,e,i)),r=Ko(Jo(t,e,s)),o=Ko(Jo(i,s,t)),a=Ko(Jo(i,s,e));return n!==r&&o!==a||!(0!==n||!Qo(t,i,e))||!(0!==r||!Qo(t,s,e))||!(0!==o||!Qo(i,t,s))||!(0!==a||!Qo(i,e,s))}function Qo(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function Ko(t){return t>0?1:t<0?-1:0}function $o(t,e){return Jo(t.prev,t,t.next)<0?Jo(t,e,t.next)>=0&&Jo(t,t.prev,e)>=0:Jo(t,e,t.prev)<0||Jo(t,t.next,e)<0}function ta(t,e){const i=new sa(t.i,t.x,t.y),s=new sa(e.i,e.x,e.y),n=t.next,r=e.prev;return t.next=e,e.prev=t,i.next=n,n.prev=i,s.next=i,i.prev=s,r.next=s,s.prev=r,s}function ea(t,e,i,s){const n=new sa(t,e,i);return s?(n.next=s.next,n.prev=s,s.next.prev=n,s.next=n):(n.prev=n,n.next=n),n}function ia(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function sa(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class na{static area(t){const e=t.length;let i=0;for(let s=e-1,n=0;n<e;s=n++)i+=t[s].x*t[n].y-t[n].x*t[s].y;return.5*i}static isClockWise(t){return na.area(t)<0}static triangulateShape(t,e){const i=[],s=[],n=[];ra(t),oa(i,t);let r=t.length;e.forEach(ra);for(let t=0;t<e.length;t++)s.push(r),r+=e[t].length,oa(i,e[t]);const o=function(t,e,i=2){const s=e&&e.length,n=s?e[0]*i:t.length;let r=Ro(t,0,n,i,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,h,c,m,u,_;if(s&&(r=function(t,e,i,s){const n=[];let r,o,a,l,h;for(r=0,o=e.length;r<o;r++)a=e[r]*s,l=r<o-1?e[r+1]*s:t.length,h=Ro(t,a,l,s,!1),h===h.next&&(h.steiner=!0),n.push(Ho(h));for(n.sort(No),r=0;r<n.length;r++)Uo(n[r],i),i=Lo(i,i.next);return i}(t,e,r,i)),t.length>80*i){a=h=t[0],l=c=t[1];for(let e=i;e<n;e+=i)m=t[e],u=t[e+1],m<a&&(a=m),u<l&&(l=u),m>h&&(h=m),u>c&&(c=u);_=Math.max(h-a,c-l),_=0!==_?1/_:0}return Go(r,o,i,a,l,_),o}(i,s);for(let t=0;t<o.length;t+=3)n.push(o.slice(t,t+3));return n}}function ra(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function oa(t,e){for(let i=0;i<e.length;i++)t.push(e[i].x),t.push(e[i].y)}class aa extends He{constructor(t=new Eo([new Z(.5,.5),new Z(-.5,.5),new Z(-.5,-.5),new Z(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,s=[],n=[];for(let e=0,i=t.length;e<i;e++)r(t[e]);function r(t){const r=[],o=void 0!==e.curveSegments?e.curveSegments:12,a=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:1,h=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:.2,m=void 0!==e.bevelSize?e.bevelSize:c-.1,u=void 0!==e.bevelOffset?e.bevelOffset:0,_=void 0!==e.bevelSegments?e.bevelSegments:3;const d=e.extrudePath,p=void 0!==e.UVGenerator?e.UVGenerator:la;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let f,y,g,x,v,S=!1;d&&(f=d.getSpacedPoints(a),S=!0,h=!1,y=d.computeFrenetFrames(a,!1),g=new pt,x=new pt,v=new pt),h||(_=0,c=0,m=0,u=0);const w=t.extractPoints(o);let b=w.shape;const C=w.holes;if(!na.isClockWise(b)){b=b.reverse();for(let t=0,e=C.length;t<e;t++){const e=C[t];na.isClockWise(e)&&(C[t]=e.reverse())}}const A=na.triangulateShape(b,C),B=b;for(let t=0,e=C.length;t<e;t++){const e=C[t];b=b.concat(e)}function M(t,e,i){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(i).add(t)}const V=b.length,T=A.length;function P(t,e,i){let s,n,r;const o=t.x-e.x,a=t.y-e.y,l=i.x-t.x,h=i.y-t.y,c=o*o+a*a,m=o*h-a*l;if(Math.abs(m)>Number.EPSILON){const m=Math.sqrt(c),u=Math.sqrt(l*l+h*h),_=e.x-a/m,d=e.y+o/m,p=((i.x-h/u-_)*h-(i.y+l/u-d)*l)/(o*h-a*l);s=_+o*p-t.x,n=d+a*p-t.y;const f=s*s+n*n;if(f<=2)return new Z(s,n);r=Math.sqrt(f/2)}else{let t=!1;o>Number.EPSILON?l>Number.EPSILON&&(t=!0):o<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(h)&&(t=!0),t?(s=-a,n=o,r=Math.sqrt(c)):(s=o,n=a,r=Math.sqrt(c/2))}return new Z(s/r,n/r)}const D=[];for(let t=0,e=B.length,i=e-1,s=t+1;t<e;t++,i++,s++)i===e&&(i=0),s===e&&(s=0),D[t]=P(B[t],B[i],B[s]);const I=[];let E,R=D.concat();for(let t=0,e=C.length;t<e;t++){const e=C[t];E=[];for(let t=0,i=e.length,s=i-1,n=t+1;t<i;t++,s++,n++)s===i&&(s=0),n===i&&(n=0),E[t]=P(e[t],e[s],e[n]);I.push(E),R=R.concat(E)}for(let t=0;t<_;t++){const e=t/_,i=c*Math.cos(e*Math.PI/2),s=m*Math.sin(e*Math.PI/2)+u;for(let t=0,e=B.length;t<e;t++){const e=M(B[t],D[t],s);F(e.x,e.y,-i)}for(let t=0,e=C.length;t<e;t++){const e=C[t];E=I[t];for(let t=0,n=e.length;t<n;t++){const n=M(e[t],E[t],s);F(n.x,n.y,-i)}}}const L=m+u;for(let t=0;t<V;t++){const e=h?M(b[t],R[t],L):b[t];S?(x.copy(y.normals[0]).multiplyScalar(e.x),g.copy(y.binormals[0]).multiplyScalar(e.y),v.copy(f[0]).add(x).add(g),F(v.x,v.y,v.z)):F(e.x,e.y,0)}for(let t=1;t<=a;t++)for(let e=0;e<V;e++){const i=h?M(b[e],R[e],L):b[e];S?(x.copy(y.normals[t]).multiplyScalar(i.x),g.copy(y.binormals[t]).multiplyScalar(i.y),v.copy(f[t]).add(x).add(g),F(v.x,v.y,v.z)):F(i.x,i.y,l/a*t)}for(let t=_-1;t>=0;t--){const e=t/_,i=c*Math.cos(e*Math.PI/2),s=m*Math.sin(e*Math.PI/2)+u;for(let t=0,e=B.length;t<e;t++){const e=M(B[t],D[t],s);F(e.x,e.y,l+i)}for(let t=0,e=C.length;t<e;t++){const e=C[t];E=I[t];for(let t=0,n=e.length;t<n;t++){const n=M(e[t],E[t],s);S?F(n.x,n.y+f[a-1].y,f[a-1].x+i):F(n.x,n.y,l+i)}}}function G(t,e){let i=t.length;for(;--i>=0;){const s=i;let n=i-1;n<0&&(n=t.length-1);for(let t=0,i=a+2*_;t<i;t++){const i=V*t,r=V*(t+1);z(e+s+i,e+n+i,e+n+r,e+s+r)}}}function F(t,e,i){r.push(t),r.push(e),r.push(i)}function k(t,e,n){O(t),O(e),O(n);const r=s.length/3,o=p.generateTopUV(i,s,r-3,r-2,r-1);N(o[0]),N(o[1]),N(o[2])}function z(t,e,n,r){O(t),O(e),O(r),O(e),O(n),O(r);const o=s.length/3,a=p.generateSideWallUV(i,s,o-6,o-3,o-2,o-1);N(a[0]),N(a[1]),N(a[3]),N(a[1]),N(a[2]),N(a[3])}function O(t){s.push(r[3*t+0]),s.push(r[3*t+1]),s.push(r[3*t+2])}function N(t){n.push(t.x),n.push(t.y)}!function(){const t=s.length/3;if(h){let t=0,e=V*t;for(let t=0;t<T;t++){const i=A[t];k(i[2]+e,i[1]+e,i[0]+e)}t=a+2*_,e=V*t;for(let t=0;t<T;t++){const i=A[t];k(i[0]+e,i[1]+e,i[2]+e)}}else{for(let t=0;t<T;t++){const e=A[t];k(e[2],e[1],e[0])}for(let t=0;t<T;t++){const e=A[t];k(e[0]+V*a,e[1]+V*a,e[2]+V*a)}}i.addGroup(t,s.length/3-t,0)}(),function(){const t=s.length/3;let e=0;G(B,e),e+=B.length;for(let t=0,i=C.length;t<i;t++){const i=C[t];G(i,e),e+=i.length}i.addGroup(t,s.length/3-t,1)}()}this.setAttribute("position",new Fe(s,3)),this.setAttribute("uv",new Fe(n,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,i){if(i.shapes=[],Array.isArray(t))for(let e=0,s=t.length;e<s;e++){const s=t[e];i.shapes.push(s.uuid)}else i.shapes.push(t.uuid);return void 0!==e.extrudePath&&(i.options.extrudePath=e.extrudePath.toJSON()),i}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const i=[];for(let s=0,n=t.shapes.length;s<n;s++){const n=e[t.shapes[s]];i.push(n)}const s=t.options.extrudePath;return void 0!==s&&(t.options.extrudePath=(new Po[s.type]).fromJSON(s)),new aa(i,t.options)}}const la={generateTopUV:function(t,e,i,s,n){const r=e[3*i],o=e[3*i+1],a=e[3*s],l=e[3*s+1],h=e[3*n],c=e[3*n+1];return[new Z(r,o),new Z(a,l),new Z(h,c)]},generateSideWallUV:function(t,e,i,s,n,r){const o=e[3*i],a=e[3*i+1],l=e[3*i+2],h=e[3*s],c=e[3*s+1],m=e[3*s+2],u=e[3*n],_=e[3*n+1],d=e[3*n+2],p=e[3*r],f=e[3*r+1],y=e[3*r+2];return Math.abs(a-c)<Math.abs(o-h)?[new Z(o,1-l),new Z(h,1-m),new Z(u,1-d),new Z(p,1-y)]:[new Z(a,1-l),new Z(c,1-m),new Z(_,1-d),new Z(f,1-y)]}};class ha extends He{constructor(t=new Eo([new Z(0,.5),new Z(-.5,-.5),new Z(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],s=[],n=[],r=[];let o=0,a=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(o,a,e),o+=a,a=0;function l(t){const o=s.length/3,l=t.extractPoints(e);let h=l.shape;const c=l.holes;!1===na.isClockWise(h)&&(h=h.reverse());for(let t=0,e=c.length;t<e;t++){const e=c[t];!0===na.isClockWise(e)&&(c[t]=e.reverse())}const m=na.triangulateShape(h,c);for(let t=0,e=c.length;t<e;t++){const e=c[t];h=h.concat(e)}for(let t=0,e=h.length;t<e;t++){const e=h[t];s.push(e.x,e.y,0),n.push(0,0,1),r.push(e.x,e.y)}for(let t=0,e=m.length;t<e;t++){const e=m[t],s=e[0]+o,n=e[1]+o,r=e[2]+o;i.push(s,n,r),a+=3}}this.setIndex(i),this.setAttribute("position",new Fe(s,3)),this.setAttribute("normal",new Fe(n,3)),this.setAttribute("uv",new Fe(r,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let i=0,s=t.length;i<s;i++){const s=t[i];e.shapes.push(s.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const i=[];for(let s=0,n=t.shapes.length;s<n;s++){const n=e[t.shapes[s]];i.push(n)}return new ha(i,t.curveSegments)}}(class extends Pe{constructor(t){super(),this.type="ShadowMaterial",this.color=new rt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}).prototype.isShadowMaterial=!0;class ca extends Pe{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new rt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Z(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}ca.prototype.isMeshStandardMaterial=!0;(class extends ca{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Z(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return W(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new rt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new rt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new rt(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}).prototype.isMeshPhysicalMaterial=!0;(class extends Pe{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new rt(16777215),this.specular=new rt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Z(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}).prototype.isMeshPhongMaterial=!0;(class extends Pe{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new rt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Z(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshToonMaterial=!0;(class extends Pe{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Z(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}).prototype.isMeshNormalMaterial=!0;(class extends Pe{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new rt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new rt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshLambertMaterial=!0;(class extends Pe{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new rt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Z(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}).prototype.isMeshMatcapMaterial=!0;(class extends Zr{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}).prototype.isLineDashedMaterial=!0;const ma={arraySlice:function(t,e,i){return ma.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==i?i:t.length)):t.slice(e,i)},convertArray:function(t,e,i){return!t||!i&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,i=new Array(e);for(let t=0;t!==e;++t)i[t]=t;return i.sort((function(e,i){return t[e]-t[i]})),i},sortedArray:function(t,e,i){const s=t.length,n=new t.constructor(s);for(let r=0,o=0;o!==s;++r){const s=i[r]*e;for(let i=0;i!==e;++i)n[o++]=t[s+i]}return n},flattenJSON:function(t,e,i,s){let n=1,r=t[0];for(;void 0!==r&&void 0===r[s];)r=t[n++];if(void 0===r)return;let o=r[s];if(void 0!==o)if(Array.isArray(o))do{o=r[s],void 0!==o&&(e.push(r.time),i.push.apply(i,o)),r=t[n++]}while(void 0!==r);else if(void 0!==o.toArray)do{o=r[s],void 0!==o&&(e.push(r.time),o.toArray(i,i.length)),r=t[n++]}while(void 0!==r);else do{o=r[s],void 0!==o&&(e.push(r.time),i.push(o)),r=t[n++]}while(void 0!==r)},subclip:function(t,e,i,s,n=30){const r=t.clone();r.name=e;const o=[];for(let t=0;t<r.tracks.length;++t){const e=r.tracks[t],a=e.getValueSize(),l=[],h=[];for(let t=0;t<e.times.length;++t){const r=e.times[t]*n;if(!(r<i||r>=s)){l.push(e.times[t]);for(let i=0;i<a;++i)h.push(e.values[t*a+i])}}0!==l.length&&(e.times=ma.convertArray(l,e.times.constructor),e.values=ma.convertArray(h,e.values.constructor),o.push(e))}r.tracks=o;let a=1/0;for(let t=0;t<r.tracks.length;++t)a>r.tracks[t].times[0]&&(a=r.tracks[t].times[0]);for(let t=0;t<r.tracks.length;++t)r.tracks[t].shift(-1*a);return r.resetDuration(),r},makeClipAdditive:function(t,e=0,i=t,s=30){s<=0&&(s=30);const n=i.tracks.length,r=e/s;for(let e=0;e<n;++e){const s=i.tracks[e],n=s.ValueTypeName;if("bool"===n||"string"===n)continue;const o=t.tracks.find((function(t){return t.name===s.name&&t.ValueTypeName===n}));if(void 0===o)continue;let a=0;const l=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(a=l/3);let h=0;const c=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=c/3);const m=s.times.length-1;let u;if(r<=s.times[0]){const t=a,e=l-a;u=ma.arraySlice(s.values,t,e)}else if(r>=s.times[m]){const t=m*l+a,e=t+l-a;u=ma.arraySlice(s.values,t,e)}else{const t=s.createInterpolant(),e=a,i=l-a;t.evaluate(r),u=ma.arraySlice(t.resultBuffer,e,i)}"quaternion"===n&&(new dt).fromArray(u).normalize().conjugate().toArray(u);const _=o.times.length;for(let t=0;t<_;++t){const e=t*c+h;if("quaternion"===n)dt.multiplyQuaternionsFlat(o.values,e,u,0,o.values,e);else{const t=c-2*h;for(let i=0;i<t;++i)o.values[e+i]-=u[i]}}}return t.blendMode=2501,t}};class ua{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==s?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],n=e[i-1];t:{e:{let r;i:{s:if(!(t<s)){for(let r=i+2;;){if(void 0===s){if(t<n)break s;return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,t,n)}if(i===r)break;if(n=s,s=e[++i],t<s)break e}r=e.length;break i}if(t>=n)break t;{const o=e[1];t<o&&(i=2,n=o);for(let r=i-2;;){if(void 0===n)return this._cachedIndex=0,this.beforeStart_(0,t,s);if(i===r)break;if(s=n,n=e[--i-1],t>=n)break e}r=i,i=0}}for(;i<r;){const s=i+r>>>1;t<e[s]?r=s:i=s+1}if(s=e[i],n=e[i-1],void 0===n)return this._cachedIndex=0,this.beforeStart_(0,t,s);if(void 0===s)return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,n,t)}this._cachedIndex=i,this.intervalChanged_(i,n,s)}return this.interpolate_(i,n,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s;for(let t=0;t!==s;++t)e[t]=i[n+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}ua.prototype.beforeStart_=ua.prototype.copySampleValue_,ua.prototype.afterEnd_=ua.prototype.copySampleValue_;class _a extends ua{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:M,endingEnd:M}}intervalChanged_(t,e,i){const s=this.parameterPositions;let n=t-2,r=t+1,o=s[n],a=s[r];if(void 0===o)switch(this.getSettings_().endingStart){case V:n=t,o=2*e-i;break;case T:n=s.length-2,o=e+s[n]-s[n+1];break;default:n=t,o=i}if(void 0===a)switch(this.getSettings_().endingEnd){case V:r=t,a=2*i-e;break;case T:r=1,a=i+s[1]-s[0];break;default:r=t-1,a=e}const l=.5*(i-e),h=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-i),this._offsetPrev=n*h,this._offsetNext=r*h}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,h=this._offsetPrev,c=this._offsetNext,m=this._weightPrev,u=this._weightNext,_=(i-e)/(s-e),d=_*_,p=d*_,f=-m*p+2*m*d-m*_,y=(1+m)*p+(-1.5-2*m)*d+(-.5+m)*_+1,g=(-1-u)*p+(1.5+u)*d+.5*_,x=u*p-u*d;for(let t=0;t!==o;++t)n[t]=f*r[h+t]+y*r[l+t]+g*r[a+t]+x*r[c+t];return n}}class da extends ua{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=t*o,l=a-o,h=(i-e)/(s-e),c=1-h;for(let t=0;t!==o;++t)n[t]=r[l+t]*c+r[a+t]*h;return n}}class pa extends ua{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class fa{constructor(t,e,i,s){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=ma.convertArray(e,this.TimeBufferType),this.values=ma.convertArray(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:ma.convertArray(t.times,Array),values:ma.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(i.interpolation=e)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new pa(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new da(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new _a(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case C:e=this.InterpolantFactoryMethodDiscrete;break;case A:e=this.InterpolantFactoryMethodLinear;break;case B:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return C;case this.InterpolantFactoryMethodLinear:return A;case this.InterpolantFactoryMethodSmooth:return B}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let n=0,r=s-1;for(;n!==s&&i[n]<t;)++n;for(;-1!==r&&i[r]>e;)--r;if(++r,0!==n||r!==s){n>=r&&(r=Math.max(r,1),n=r-1);const t=this.getValueSize();this.times=ma.arraySlice(i,n,r),this.values=ma.arraySlice(this.values,n*t,r*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,n=i.length;0===n&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let e=0;e!==n;e++){const s=i[e];if("number"==typeof s&&isNaN(s)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,s),t=!1;break}if(null!==r&&r>s){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,s,r),t=!1;break}r=s}if(void 0!==s&&ma.isTypedArray(s))for(let e=0,i=s.length;e!==i;++e){const i=s[e];if(isNaN(i)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,i),t=!1;break}}return t}optimize(){const t=ma.arraySlice(this.times),e=ma.arraySlice(this.values),i=this.getValueSize(),s=this.getInterpolation()===B,n=t.length-1;let r=1;for(let o=1;o<n;++o){let n=!1;const a=t[o];if(a!==t[o+1]&&(1!==o||a!==t[0]))if(s)n=!0;else{const t=o*i,s=t-i,r=t+i;for(let o=0;o!==i;++o){const i=e[t+o];if(i!==e[s+o]||i!==e[r+o]){n=!0;break}}}if(n){if(o!==r){t[r]=t[o];const s=o*i,n=r*i;for(let t=0;t!==i;++t)e[n+t]=e[s+t]}++r}}if(n>0){t[r]=t[n];for(let t=n*i,s=r*i,o=0;o!==i;++o)e[s+o]=e[t+o];++r}return r!==t.length?(this.times=ma.arraySlice(t,0,r),this.values=ma.arraySlice(e,0,r*i)):(this.times=t,this.values=e),this}clone(){const t=ma.arraySlice(this.times,0),e=ma.arraySlice(this.values,0),i=new(0,this.constructor)(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}fa.prototype.TimeBufferType=Float32Array,fa.prototype.ValueBufferType=Float32Array,fa.prototype.DefaultInterpolation=A;class ya extends fa{}ya.prototype.ValueTypeName="bool",ya.prototype.ValueBufferType=Array,ya.prototype.DefaultInterpolation=C,ya.prototype.InterpolantFactoryMethodLinear=void 0,ya.prototype.InterpolantFactoryMethodSmooth=void 0;class ga extends fa{}ga.prototype.ValueTypeName="color";class xa extends fa{}xa.prototype.ValueTypeName="number";class va extends ua{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=(i-e)/(s-e);let l=t*o;for(let t=l+o;l!==t;l+=4)dt.slerpFlat(n,0,r,l-o,r,l,a);return n}}class Sa extends fa{InterpolantFactoryMethodLinear(t){return new va(this.times,this.values,this.getValueSize(),t)}}Sa.prototype.ValueTypeName="quaternion",Sa.prototype.DefaultInterpolation=A,Sa.prototype.InterpolantFactoryMethodSmooth=void 0;class wa extends fa{}wa.prototype.ValueTypeName="string",wa.prototype.ValueBufferType=Array,wa.prototype.DefaultInterpolation=C,wa.prototype.InterpolantFactoryMethodLinear=void 0,wa.prototype.InterpolantFactoryMethodSmooth=void 0;class ba extends fa{}ba.prototype.ValueTypeName="vector";class Ca{constructor(t,e=-1,i,s=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=U(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let t=0,n=i.length;t!==n;++t)e.push(Aa(i[t]).scale(s));const n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,s=i.length;t!==s;++t)e.push(fa.toJSON(i[t]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const n=e.length,r=[];for(let t=0;t<n;t++){let o=[],a=[];o.push((t+n-1)%n,t,(t+1)%n),a.push(0,1,0);const l=ma.getKeyframeOrder(o);o=ma.sortedArray(o,1,l),a=ma.sortedArray(a,1,l),s||0!==o[0]||(o.push(n),a.push(a[0])),r.push(new xa(".morphTargetInfluences["+e[t].name+"]",o,a).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const e=t;i=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<i.length;t++)if(i[t].name===e)return i[t];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},n=/^([\w-]*?)([\d]+)$/;for(let e=0,i=t.length;e<i;e++){const i=t[e],r=i.name.match(n);if(r&&r.length>1){const t=r[1];let e=s[t];e||(s[t]=e=[]),e.push(i)}}const r=[];for(const t in s)r.push(this.CreateFromMorphTargetSequence(t,s[t],e,i));return r}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(t,e,i,s,n){if(0!==i.length){const r=[],o=[];ma.flattenJSON(i,r,o,s),0!==r.length&&n.push(new t(e,r,o))}},s=[],n=t.name||"default",r=t.fps||30,o=t.blendMode;let a=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const n=l[t].keys;if(n&&0!==n.length)if(n[0].morphTargets){const t={};let e;for(e=0;e<n.length;e++)if(n[e].morphTargets)for(let i=0;i<n[e].morphTargets.length;i++)t[n[e].morphTargets[i]]=-1;for(const i in t){const t=[],r=[];for(let s=0;s!==n[e].morphTargets.length;++s){const s=n[e];t.push(s.time),r.push(s.morphTarget===i?1:0)}s.push(new xa(".morphTargetInfluence["+i+"]",t,r))}a=t.length*(r||1)}else{const r=".bones["+e[t].name+"]";i(ba,r+".position",n,"pos",s),i(Sa,r+".quaternion",n,"rot",s),i(ba,r+".scale",n,"scl",s)}}return 0===s.length?null:new this(n,a,s,o)}resetDuration(){let t=0;for(let e=0,i=this.tracks.length;e!==i;++e){const i=this.tracks[e];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Aa(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return xa;case"vector":case"vector2":case"vector3":case"vector4":return ba;case"color":return ga;case"quaternion":return Sa;case"bool":case"boolean":return ya;case"string":return wa}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],i=[];ma.flattenJSON(t.keys,e,i,"value"),t.times=e,t.values=i}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Ba={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};const Ma=new class{constructor(t,e,i){const s=this;let n,r=!1,o=0,a=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(t){a++,!1===r&&void 0!==s.onStart&&s.onStart(t,o,a),r=!0},this.itemEnd=function(t){o++,void 0!==s.onProgress&&s.onProgress(t,o,a),o===a&&(r=!1,void 0!==s.onLoad&&s.onLoad())},this.itemError=function(t){void 0!==s.onError&&s.onError(t)},this.resolveURL=function(t){return n?n(t):t},this.setURLModifier=function(t){return n=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,i=l.length;e<i;e+=2){const i=l[e],s=l[e+1];if(i.global&&(i.lastIndex=0),i.test(t))return s}return null}}};class Va{constructor(t){this.manager=void 0!==t?t:Ma,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise((function(s,n){i.load(t,s,e,n)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Ta={};class Pa extends Va{constructor(t){super(t)}load(t,e,i,s){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const n=Ba.get(t);if(void 0!==n)return this.manager.itemStart(t),setTimeout((()=>{e&&e(n),this.manager.itemEnd(t)}),0),n;if(void 0!==Ta[t])return void Ta[t].push({onLoad:e,onProgress:i,onError:s});Ta[t]=[],Ta[t].push({onLoad:e,onProgress:i,onError:s});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(r).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body.getReader)return e;const i=Ta[t],s=e.body.getReader(),n=e.headers.get("Content-Length"),r=n?parseInt(n):0,o=0!==r;let a=0;const l=new ReadableStream({start(t){!function e(){s.read().then((({done:s,value:n})=>{if(s)t.close();else{a+=n.byteLength;const s=new ProgressEvent("progress",{lengthComputable:o,loaded:a,total:r});for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onProgress&&e.onProgress(s)}t.enqueue(n),e()}}))}()}});return new Response(l)}throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)})).then((t=>{switch(a){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,o)));case"json":return t.json();default:if(void 0===o)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(o),i=e&&e[1]?e[1].toLowerCase():void 0,s=new TextDecoder(i);return t.arrayBuffer().then((t=>s.decode(t)))}}})).then((e=>{Ba.add(t,e);const i=Ta[t];delete Ta[t];for(let t=0,s=i.length;t<s;t++){const s=i[t];s.onLoad&&s.onLoad(e)}})).catch((e=>{const i=Ta[t];if(void 0===i)throw this.manager.itemError(t),e;delete Ta[t];for(let t=0,s=i.length;t<s;t++){const s=i[t];s.onError&&s.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Da extends Va{constructor(t){super(t)}load(t,e,i,s){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=Ba.get(t);if(void 0!==r)return n.manager.itemStart(t),setTimeout((function(){e&&e(r),n.manager.itemEnd(t)}),0),r;const o=K("img");function a(){h(),Ba.add(t,this),e&&e(this),n.manager.itemEnd(t)}function l(e){h(),s&&s(e),n.manager.itemError(t),n.manager.itemEnd(t)}function h(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),n.manager.itemStart(t),o.src=t,o}}class Ia extends Va{constructor(t){super(t)}load(t,e,i,s){const n=new vi,r=new Da(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let o=0;function a(i){r.load(t[i],(function(t){n.images[i]=t,o++,6===o&&(n.needsUpdate=!0,e&&e(n))}),void 0,s)}for(let e=0;e<t.length;++e)a(e);return n}}class Ea extends Va{constructor(t){super(t)}load(t,e,i,s){const n=new ht,r=new Da(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,(function(t){n.image=t,n.needsUpdate=!0,void 0!==e&&e(n)}),i,s),n}}class Ra extends ye{constructor(t,e=1){super(),this.type="Light",this.color=new rt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}Ra.prototype.isLight=!0;(class extends Ra{constructor(t,e,i){super(t,i),this.type="HemisphereLight",this.position.copy(ye.DefaultUp),this.updateMatrix(),this.groundColor=new rt(e)}copy(t){return Ra.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}).prototype.isHemisphereLight=!0;const La=new qt,Ga=new pt,Fa=new pt;class ka{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Z(512,512),this.map=null,this.mapPass=null,this.matrix=new qt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Vi,this._frameExtents=new Z(1,1),this._viewportCount=1,this._viewports=[new mt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;Ga.setFromMatrixPosition(t.matrixWorld),e.position.copy(Ga),Fa.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Fa),e.updateMatrixWorld(),La.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(La),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class za extends ka{constructor(){super(new yi(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,i=2*N*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;i===e.fov&&s===e.aspect&&n===e.far||(e.fov=i,e.aspect=s,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}za.prototype.isSpotLightShadow=!0;(class extends Ra{constructor(t,e,i=0,s=Math.PI/3,n=0,r=1){super(t,e),this.type="SpotLight",this.position.copy(ye.DefaultUp),this.updateMatrix(),this.target=new ye,this.distance=i,this.angle=s,this.penumbra=n,this.decay=r,this.shadow=new za}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isSpotLight=!0;const Oa=new qt,Na=new pt,Ua=new pt;class Wa extends ka{constructor(){super(new yi(90,1,.5,500)),this._frameExtents=new Z(4,2),this._viewportCount=6,this._viewports=[new mt(2,1,1,1),new mt(0,1,1,1),new mt(3,1,1,1),new mt(1,1,1,1),new mt(3,0,1,1),new mt(1,0,1,1)],this._cubeDirections=[new pt(1,0,0),new pt(-1,0,0),new pt(0,0,1),new pt(0,0,-1),new pt(0,1,0),new pt(0,-1,0)],this._cubeUps=[new pt(0,1,0),new pt(0,1,0),new pt(0,1,0),new pt(0,1,0),new pt(0,0,1),new pt(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),Na.setFromMatrixPosition(t.matrixWorld),i.position.copy(Na),Ua.copy(i.position),Ua.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(Ua),i.updateMatrixWorld(),s.makeTranslation(-Na.x,-Na.y,-Na.z),Oa.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Oa)}}Wa.prototype.isPointLightShadow=!0;(class extends Ra{constructor(t,e,i=0,s=1){super(t,e),this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new Wa}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}).prototype.isPointLight=!0;class ja extends ka{constructor(){super(new Ni(-5,5,5,-5,.5,500))}}ja.prototype.isDirectionalLightShadow=!0;(class extends Ra{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(ye.DefaultUp),this.updateMatrix(),this.target=new ye,this.shadow=new ja}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isDirectionalLight=!0;(class extends Ra{constructor(t,e){super(t,e),this.type="AmbientLight"}}).prototype.isAmbientLight=!0;(class extends Ra{constructor(t,e,i=10,s=10){super(t,e),this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}).prototype.isRectAreaLight=!0;class Ha{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new pt)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,s=t.y,n=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.282095),e.addScaledVector(r[1],.488603*s),e.addScaledVector(r[2],.488603*n),e.addScaledVector(r[3],.488603*i),e.addScaledVector(r[4],i*s*1.092548),e.addScaledVector(r[5],s*n*1.092548),e.addScaledVector(r[6],.315392*(3*n*n-1)),e.addScaledVector(r[7],i*n*1.092548),e.addScaledVector(r[8],.546274*(i*i-s*s)),e}getIrradianceAt(t,e){const i=t.x,s=t.y,n=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.886227),e.addScaledVector(r[1],1.023328*s),e.addScaledVector(r[2],1.023328*n),e.addScaledVector(r[3],1.023328*i),e.addScaledVector(r[4],.858086*i*s),e.addScaledVector(r[5],.858086*s*n),e.addScaledVector(r[6],.743125*n*n-.247708),e.addScaledVector(r[7],.858086*i*n),e.addScaledVector(r[8],.429043*(i*i-s*s)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].fromArray(t,e+3*s);return this}toArray(t=[],e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].toArray(t,e+3*s);return t}static getBasisAt(t,e){const i=t.x,s=t.y,n=t.z;e[0]=.282095,e[1]=.488603*s,e[2]=.488603*n,e[3]=.488603*i,e[4]=1.092548*i*s,e[5]=1.092548*s*n,e[6]=.315392*(3*n*n-1),e[7]=1.092548*i*n,e[8]=.546274*(i*i-s*s)}}Ha.prototype.isSphericalHarmonics3=!0;class qa extends Ra{constructor(t=new Ha,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}qa.prototype.isLightProbe=!0;let Xa;(class extends He{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}).prototype.isInstancedBufferGeometry=!0,class extends Va{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,s){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=Ba.get(t);if(void 0!==r)return n.manager.itemStart(t),setTimeout((function(){e&&e(r),n.manager.itemEnd(t)}),0),r;const o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(n.options,{colorSpaceConversion:"none"}))})).then((function(i){Ba.add(t,i),e&&e(i),n.manager.itemEnd(t)})).catch((function(e){s&&s(e),n.manager.itemError(t),n.manager.itemEnd(t)})),n.manager.itemStart(t)}}.prototype.isImageBitmapLoader=!0;class Ja extends Va{constructor(t){super(t)}load(t,e,i,s){const n=this,r=new Pa(this.manager);r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,(function(i){try{const t=i.slice(0);(void 0===Xa&&(Xa=new(window.AudioContext||window.webkitAudioContext)),Xa).decodeAudioData(t,(function(t){e(t)}))}catch(e){s?s(e):console.error(e),n.manager.itemError(t)}}),i,s)}}(class extends qa{constructor(t,e,i=1){super(void 0,i);const s=(new rt).set(t),n=(new rt).set(e),r=new pt(s.r,s.g,s.b),o=new pt(n.r,n.g,n.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(r).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(l)}}).prototype.isHemisphereLightProbe=!0,class extends qa{constructor(t,e=1){super(void 0,e);const i=(new rt).set(t);this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}.prototype.isAmbientLightProbe=!0;class Za{constructor(t,e,i){let s,n,r;switch(this.binding=t,this.valueSize=i,e){case"quaternion":s=this._slerp,n=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":s=this._select,n=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:s=this._lerp,n=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=n,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,s=this.valueSize,n=t*s+s;let r=this.cumulativeWeight;if(0===r){for(let t=0;t!==s;++t)i[n+t]=i[t];r=e}else{r+=e;const t=e/r;this._mixBufferRegion(i,n,0,t,s)}this.cumulativeWeight=r}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,s=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,s,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,s=t*e+e,n=this.cumulativeWeight,r=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,n<1){const t=e*this._origIndex;this._mixBufferRegion(i,s,t,1-n,e)}r>0&&this._mixBufferRegionAdditive(i,s,this._addIndex*e,1,e);for(let t=e,n=e+e;t!==n;++t)if(i[t]!==i[t+e]){o.setValue(i,s);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,s=i*this._origIndex;t.getValue(e,s);for(let t=i,n=s;t!==n;++t)e[t]=e[s+t%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,s,n){if(s>=.5)for(let s=0;s!==n;++s)t[e+s]=t[i+s]}_slerp(t,e,i,s){dt.slerpFlat(t,e,t,e,t,i,s)}_slerpAdditive(t,e,i,s,n){const r=this._workIndex*n;dt.multiplyQuaternionsFlat(t,r,t,e,t,i),dt.slerpFlat(t,e,t,e,t,r,s)}_lerp(t,e,i,s,n){const r=1-s;for(let o=0;o!==n;++o){const n=e+o;t[n]=t[n]*r+t[i+o]*s}}_lerpAdditive(t,e,i,s,n){for(let r=0;r!==n;++r){const n=e+r;t[n]=t[n]+t[i+r]*s}}}const Ya=new RegExp("[\\[\\]\\.:\\/]","g"),Qa="[^\\[\\]\\.:\\/]",Ka="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",$a=/((?:WC+[\/:])*)/.source.replace("WC",Qa),tl=/(WCOD+)?/.source.replace("WCOD",Ka),el=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Qa),il=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Qa),sl=new RegExp("^"+$a+tl+el+il+"$"),nl=["material","materials","bones"];class rl{constructor(t,e,i){this.path=e,this.parsedPath=i||rl.parseTrackName(e),this.node=rl.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new rl.Composite(t,e,i):new rl(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Ya,"")}static parseTrackName(t){const e=sl.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==s&&-1!==s){const t=i.nodeName.substring(s+1);-1!==nl.indexOf(t)&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=t)}if(null===i.propertyName||0===i.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(void 0!==i)return i}if(t.children){const i=function(t){for(let s=0;s<t.length;s++){const n=t[s];if(n.name===e||n.uuid===e)return n;const r=i(n.children);if(r)return r}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let n=e.propertyIndex;if(t||(t=rl.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(i){let s=e.objectIndex;switch(i){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===s){s=e;break}break;default:if(void 0===t[i])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[i]}if(void 0!==s){if(void 0===t[s])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[s]}}const r=t[s];if(void 0===r){const i=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+i+"."+s+" but it wasn't found.",t)}let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(void 0!==n){if("morphTargetInfluences"===s){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[n]&&(n=t.morphTargetDictionary[n])}a=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=n}else void 0!==r.fromArray&&void 0!==r.toArray?(a=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(a=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=s;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}rl.Composite=class{constructor(t,e,i){const s=i||rl.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,s)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];void 0!==s&&s.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,n=i.length;s!==n;++s)i[s].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}},rl.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},rl.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},rl.prototype.GetterByBindingType=[rl.prototype._getValue_direct,rl.prototype._getValue_array,rl.prototype._getValue_arrayElement,rl.prototype._getValue_toArray],rl.prototype.SetterByBindingTypeAndVersioning=[[rl.prototype._setValue_direct,rl.prototype._setValue_direct_setNeedsUpdate,rl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[rl.prototype._setValue_array,rl.prototype._setValue_array_setNeedsUpdate,rl.prototype._setValue_array_setMatrixWorldNeedsUpdate],[rl.prototype._setValue_arrayElement,rl.prototype._setValue_arrayElement_setNeedsUpdate,rl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[rl.prototype._setValue_fromArray,rl.prototype._setValue_fromArray_setNeedsUpdate,rl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class ol{constructor(t,e,i=null,s=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=s;const n=e.tracks,r=n.length,o=new Array(r),a={endingStart:M,endingEnd:M};for(let t=0;t!==r;++t){const e=n[t].createInterpolant(null);o[t]=e,e.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const i=this._clip.duration,s=t._clip.duration,n=s/i,r=i/s;t.warp(1,n,e),this.warp(r,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const s=this._mixer,n=s.time,r=this.timeScale;let o=this._timeScaleInterpolant;null===o&&(o=s._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=n,a[1]=n+i,l[0]=t/r,l[1]=e/r,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,s){if(!this.enabled)return void this._updateWeight(t);const n=this._startTime;if(null!==n){const s=(t-n)*i;if(s<0||0===i)return;this._startTime=null,e=i*s}e*=this._updateTimeScale(t);const r=this._updateTime(e),o=this._updateWeight(t);if(o>0){const t=this._interpolants,e=this._propertyBindings;if(2501===this.blendMode)for(let i=0,s=t.length;i!==s;++i)t[i].evaluate(r),e[i].accumulateAdditive(o);else for(let i=0,n=t.length;i!==n;++i)t[i].evaluate(r),e[i].accumulate(s,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(null!==i){const s=i.evaluate(t)[0];e*=s,t>i.parameterPositions[1]&&(this.stopFading(),0===s&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;null!==i&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let s=this.time+t,n=this._loopCount;const r=2202===i;if(0===t)return-1===n?s:r&&1==(1&n)?e-s:s;if(2200===i){-1===n&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(s>=e)s=e;else{if(!(s<0)){this.time=s;break t}s=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===n&&(t>=0?(n=0,this._setEndings(!0,0===this.repetitions,r)):this._setEndings(0===this.repetitions,!0,r)),s>=e||s<0){const i=Math.floor(s/e);s-=e*i,n+=Math.abs(i);const o=this.repetitions-n;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=t>0?e:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===o){const e=t<0;this._setEndings(e,!e,r)}else this._setEndings(!1,!1,r);this._loopCount=n,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=s;if(r&&1==(1&n))return e-s}return s}_setEndings(t,e,i){const s=this._interpolantSettings;i?(s.endingStart=V,s.endingEnd=V):(s.endingStart=t?this.zeroSlopeAtStart?V:M:T,s.endingEnd=e?this.zeroSlopeAtEnd?V:M:T)}_scheduleFading(t,e,i){const s=this._mixer,n=s.time;let r=this._weightInterpolant;null===r&&(r=s._lendControlInterpolant(),this._weightInterpolant=r);const o=r.parameterPositions,a=r.sampleValues;return o[0]=n,a[0]=e,o[1]=n+t,a[1]=i,this}}(class extends F{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,s=t._clip.tracks,n=s.length,r=t._propertyBindings,o=t._interpolants,a=i.uuid,l=this._bindingsByRootAndName;let h=l[a];void 0===h&&(h={},l[a]=h);for(let t=0;t!==n;++t){const n=s[t],l=n.name;let c=h[l];if(void 0!==c)++c.referenceCount,r[t]=c;else{if(c=r[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,a,l));continue}const s=e&&e._propertyBindings[t].binding.parsedPath;c=new Za(rl.create(i,l,s),n.ValueTypeName,n.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,a,l),r[t]=c}o[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,i=t._clip.uuid,s=this._actionsByClip[i];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,i,e)}const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0==i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0==--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,i){const s=this._actions,n=this._actionsByClip;let r=n[e];if(void 0===r)r={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,n[e]=r;else{const e=r.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=s.length,s.push(t),r.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],s=t._cacheIndex;i._cacheIndex=s,e[s]=i,e.pop(),t._cacheIndex=null;const n=t._clip.uuid,r=this._actionsByClip,o=r[n],a=o.knownActions,l=a[a.length-1],h=t._byClipCacheIndex;l._byClipCacheIndex=h,a[h]=l,a.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===a.length&&delete r[n],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0==--i.referenceCount&&this._removeInactiveBinding(i)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,s=this._nActiveActions++,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,s=--this._nActiveActions,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_addInactiveBinding(t,e,i){const s=this._bindingsByRootAndName,n=this._bindings;let r=s[e];void 0===r&&(r={},s[e]=r),r[i]=t,t._cacheIndex=n.length,n.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,s=i.rootNode.uuid,n=i.path,r=this._bindingsByRootAndName,o=r[s],a=e[e.length-1],l=t._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[n],0===Object.keys(o).length&&delete r[s]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,s=this._nActiveBindings++,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,s=--this._nActiveBindings,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return void 0===i&&(i=new da(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,s=--this._nActiveControlInterpolants,n=e[s];t.__cacheIndex=s,e[s]=t,n.__cacheIndex=i,e[i]=n}clipAction(t,e,i){const s=e||this._root,n=s.uuid;let r="string"==typeof t?Ca.findByName(s,t):t;const o=null!==r?r.uuid:t,a=this._actionsByClip[o];let l=null;if(void 0===i&&(i=null!==r?r.blendMode:2500),void 0!==a){const t=a.actionByRoot[n];if(void 0!==t&&t.blendMode===i)return t;l=a.knownActions[0],null===r&&(r=l._clip)}if(null===r)return null;const h=new ol(this,r,e,i);return this._bindAction(h,l),this._addInactiveAction(h,o,n),h}existingAction(t,e){const i=e||this._root,s=i.uuid,n="string"==typeof t?Ca.findByName(i,t):t,r=n?n.uuid:t,o=this._actionsByClip[r];return void 0!==o&&o.actionByRoot[s]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,s=this.time+=t,n=Math.sign(t),r=this._accuIndex^=1;for(let o=0;o!==i;++o)e[o]._update(s,t,n,r);const o=this._bindings,a=this._nActiveBindings;for(let t=0;t!==a;++t)o[t].apply(r);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,s=this._actionsByClip,n=s[i];if(void 0!==n){const t=n.knownActions;for(let i=0,s=t.length;i!==s;++i){const s=t[i];this._deactivateAction(s);const n=s._cacheIndex,r=e[e.length-1];s._cacheIndex=null,s._byClipCacheIndex=null,r._cacheIndex=n,e[n]=r,e.pop(),this._removeInactiveBindingsForAction(s)}delete s[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const t in i){const s=i[t].actionByRoot[e];void 0!==s&&(this._deactivateAction(s),this._removeInactiveAction(s))}const s=this._bindingsByRootAndName[e];if(void 0!==s)for(const t in s){const e=s[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const i=this.existingAction(t,e);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);class al{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new al(void 0===this.value.clone?this.value:this.value.clone())}}(class extends vr{constructor(t,e,i=1){super(t,e),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}).prototype.isInstancedInterleavedBuffer=!0;const ll=new Z;class hl{constructor(t=new Z(1/0,1/0),e=new Z(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=ll.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ll.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}hl.prototype.isBox2=!0;const cl=new pt,ml=new qt,ul=new qt;function _l(t){const e=[];t&&t.isBone&&e.push(t);for(let i=0;i<t.children.length;i++)e.push.apply(e,_l(t.children[i]));return e}const dl=new Float32Array(1);new Int32Array(dl.buffer),mo.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(mo.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Io.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)},class extends no{constructor(t=10,e=10,i=4473924,s=8947848){i=new rt(i),s=new rt(s);const n=e/2,r=t/e,o=t/2,a=[],l=[];for(let t=0,h=0,c=-o;t<=e;t++,c+=r){a.push(-o,0,c,o,0,c),a.push(c,0,-o,c,0,o);const e=t===n?i:s;e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3}const h=new He;h.setAttribute("position",new Fe(a,3)),h.setAttribute("color",new Fe(l,3)),super(h,new Zr({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},class extends no{constructor(t){const e=_l(t),i=new He,s=[],n=[],r=new rt(0,0,1),o=new rt(0,1,0);for(let t=0;t<e.length;t++){const i=e[t];i.parent&&i.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),n.push(r.r,r.g,r.b),n.push(o.r,o.g,o.b))}i.setAttribute("position",new Fe(s,3)),i.setAttribute("color",new Fe(n,3)),super(i,new Zr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,i=this.geometry,s=i.getAttribute("position");ul.copy(this.root.matrixWorld).invert();for(let t=0,i=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(ml.multiplyMatrices(ul,n.matrixWorld),cl.setFromMatrixPosition(ml),s.setXYZ(i,cl.x,cl.y,cl.z),ml.multiplyMatrices(ul,n.parent.matrixWorld),cl.setFromMatrixPosition(ml),s.setXYZ(i+1,cl.x,cl.y,cl.z),i+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Va.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),class{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}.extractUrlBase(t)},Va.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},hl.prototype.center=function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},hl.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},hl.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},hl.prototype.size=function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)},gt.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},gt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},gt.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},gt.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},gt.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},Ft.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Vi.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Y.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Y.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Y.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Y.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Y.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Y.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},qt.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},qt.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},qt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new pt).setFromMatrixColumn(this,3)},qt.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},qt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},qt.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},qt.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},qt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},qt.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},qt.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},qt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},qt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},qt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},qt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},qt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},qt.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},qt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},qt.prototype.makeFrustum=function(t,e,i,s,n,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,s,i,n,r)},qt.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Ai.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},dt.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},dt.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Ht.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Ht.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},Ht.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Ve.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Ve.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},Ve.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},Ve.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},Ve.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},Ve.barycoordFromPoint=function(t,e,i,s,n){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Ve.getBarycoord(t,e,i,s,n)},Ve.normal=function(t,e,i,s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Ve.getNormal(t,e,i,s)},Eo.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},Eo.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new aa(this,t)},Eo.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ha(this,t)},Z.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},Z.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},Z.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},pt.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},pt.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},pt.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},pt.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},pt.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},pt.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},pt.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},pt.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},pt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},mt.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},mt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},ye.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},ye.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},ye.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},ye.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},ye.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(ye.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),hi.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(hi.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Wr.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},yi.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(Ra.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(Re.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===R},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(R)}}}),Re.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?R:E),this},Re.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Re.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},He.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},He.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new Re(arguments[1],arguments[2])))},He.prototype.addDrawCall=function(t,e,i){void 0!==i&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},He.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},He.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},He.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},He.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(He.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),vr.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?R:E),this},vr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},aa.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},aa.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},aa.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},xr.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},al.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Pe.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new rt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(pi.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),fr.prototype.clearTarget=function(t,e,i,s){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,i,s)},fr.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},fr.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},fr.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},fr.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},fr.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},fr.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},fr.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},fr.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},fr.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},fr.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},fr.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},fr.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},fr.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},fr.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},fr.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},fr.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},fr.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},fr.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},fr.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},fr.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},fr.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},fr.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},fr.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},fr.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(fr.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?D:P}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}}),Object.defineProperties(rr.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(ut.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),class extends ye{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new Ja).load(t,(function(t){e.setBuffer(t)})),this},xi.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},xi.prototype.clear=function(t,e,i,s){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,i,s)},at.crossOrigin=void 0,at.loadTexture=function(t,e,i,s){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const n=new Ea;n.setCrossOrigin(this.crossOrigin);const r=n.load(t,i,void 0,s);return e&&(r.mapping=e),r},at.loadTextureCube=function(t,e,i,s){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const n=new Ia;n.setCrossOrigin(this.crossOrigin);const r=n.load(t,i,void 0,s);return e&&(r.mapping=e),r},at.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},at.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"137"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="137");class pl extends xr{constructor(){super(),this.matrixAutoUpdate=!1,this.autoUpdate=!1}addChildFromBuilder(t){const e=t.build(null);return t.processEvent(),e}}class fl{constructor(t=0,e=0,i=0){this.isVector3=!0,this._x=t,this._y=e,this._z=i,this._onBeforeChangeCallback=()=>{},this._onBeforeGetComponentCallback=()=>{}}onBeforeChange(t){this._onBeforeChangeCallback=t}onBeforeGetComponent(t){this._onBeforeGetComponentCallback=t}get x(){return this._onBeforeGetComponentCallback(),this._x}set x(t){this._onBeforeChangeCallback(),this._x=t}get y(){return this._onBeforeGetComponentCallback(),this._y}set y(t){this._onBeforeChangeCallback(),this._y=t}get z(){return this._onBeforeGetComponentCallback(),this._z}set z(t){this._onBeforeChangeCallback(),this._z=t}set(t,e,i){return void 0===i&&(this._onBeforeGetComponentCallback(),i=this._z),this._onBeforeChangeCallback(),this._x=t,this._y=e,this._z=i,this}setScalar(t){return this._onBeforeChangeCallback(),this._x=t,this._y=t,this._z=t,this}setX(t){return this._onBeforeChangeCallback(),this._x=t,this}setY(t){return this._onBeforeChangeCallback(),this._y=t,this}setZ(t){return this._onBeforeChangeCallback(),this._z=t,this}setComponent(t,e){switch(this._onBeforeChangeCallback(),t){case 0:this._x=e;break;case 1:this._y=e;break;case 2:this._z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(this._onBeforeGetComponentCallback(),t){case 0:return this._x;case 1:return this._y;case 2:return this._z;default:throw new Error("index is out of range: "+t)}}clone(){return this._onBeforeGetComponentCallback(),new pt(this._x,this._y,this._z)}copy(t){return this._onBeforeChangeCallback(),this._x=t.x,this._y=t.y,this._z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x+=t.x,this._y+=t.y,this._z+=t.z,this)}addScalar(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x+=t,this._y+=t,this._z+=t,this}addVectors(t,e){return this._onBeforeChangeCallback(),this._x=t.x+e.x,this._y=t.y+e.y,this._z=t.z+e.z,this}addScaledVector(t,e){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x+=t.x*e,this._y+=t.y*e,this._z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x-=t.x,this._y-=t.y,this._z-=t.z,this)}subScalar(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x-=t,this._y-=t,this._z-=t,this}subVectors(t,e){return this._onBeforeChangeCallback(),this._x=t.x-e.x,this._y=t.y-e.y,this._z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x*=t.x,this._y*=t.y,this._z*=t.z,this)}multiplyScalar(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x*=t,this._y*=t,this._z*=t,this}multiplyVectors(t,e){return this._onBeforeChangeCallback(),this._x=t.x*e.x,this._y=t.y*e.y,this._z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(gl.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(gl.setFromAxisAngle(t,e))}applyMatrix3(t){this._onBeforeGetComponentCallback();const e=this._x,i=this._y,s=this._z,n=t.elements;return this._onBeforeChangeCallback(),this._x=n[0]*e+n[3]*i+n[6]*s,this._y=n[1]*e+n[4]*i+n[7]*s,this._z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){this._onBeforeGetComponentCallback();const e=this._x,i=this._y,s=this._z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this._onBeforeChangeCallback(),this._x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this._y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this._z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){this._onBeforeGetComponentCallback();const e=this._x,i=this._y,s=this._z,n=t.x,r=t.y,o=t.z,a=t.w,l=a*e+r*s-o*i,h=a*i+o*e-n*s,c=a*s+n*i-r*e,m=-n*e-r*i-o*s;return this._onBeforeChangeCallback(),this._x=l*a+m*-n+h*-o-c*-r,this._y=h*a+m*-r+c*-n-l*-o,this._z=c*a+m*-o+l*-r-h*-n,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){this._onBeforeGetComponentCallback();const e=this._x,i=this._y,s=this._z,n=t.elements;return this._onBeforeChangeCallback(),this._x=n[0]*e+n[4]*i+n[8]*s,this._y=n[1]*e+n[5]*i+n[9]*s,this._z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x/=t.x,this._y/=t.y,this._z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.min(this._x,t.x),this._y=Math.min(this._y,t.y),this._z=Math.min(this._z,t.z),this}max(t){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.max(this._x,t.x),this._y=Math.max(this._y,t.y),this._z=Math.max(this._z,t.z),this}clamp(t,e){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.max(t.x,Math.min(e.x,this._x)),this._y=Math.max(t.y,Math.min(e.y,this._y)),this._z=Math.max(t.z,Math.min(e.z,this._z)),this}clampScalar(t,e){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.max(t,Math.min(e,this._x)),this._y=Math.max(t,Math.min(e,this._y)),this._z=Math.max(t,Math.min(e,this._z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.floor(this._x),this._y=Math.floor(this._y),this._z=Math.floor(this._z),this}ceil(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.ceil(this._x),this._y=Math.ceil(this._y),this._z=Math.ceil(this._z),this}round(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=Math.round(this._x),this._y=Math.round(this._y),this._z=Math.round(this._z),this}roundToZero(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=this._x<0?Math.ceil(this._x):Math.floor(this._x),this._y=this._y<0?Math.ceil(this._y):Math.floor(this._y),this._z=this._z<0?Math.ceil(this._z):Math.floor(this._z),this}negate(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x=-this._x,this._y=-this._y,this._z=-this._z,this}dot(t){return this._onBeforeGetComponentCallback(),this._x*t.x+this._y*t.y+this._z*t.z}lengthSq(){return this._onBeforeGetComponentCallback(),this._x*this._x+this._y*this._y+this._z*this._z}length(){return this._onBeforeGetComponentCallback(),Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z)}manhattanLength(){return this._onBeforeGetComponentCallback(),Math.abs(this._x)+Math.abs(this._y)+Math.abs(this._z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._x+=(t.x-this._x)*e,this._y+=(t.y-this._y)*e,this._z+=(t.z-this._z)*e,this}lerpVectors(t,e,i){return this._onBeforeChangeCallback(),this._x=t.x+(e.x-t.x)*i,this._y=t.y+(e.y-t.y)*i,this._z=t.z+(e.z-t.z)*i,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,o=e.y,a=e.z;return this._onBeforeChangeCallback(),this._x=s*a-n*o,this._y=n*r-i*a,this._z=i*o-s*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return yl.copy(this).projectOnVector(t),this.sub(yl)}reflect(t){return this.sub(yl.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(J.clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){this._onBeforeGetComponentCallback();const e=this._x-t.x,i=this._y-t.y,s=this._z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return this._onBeforeGetComponentCallback(),Math.abs(this._x-t.x)+Math.abs(this._y-t.y)+Math.abs(this._z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this._onBeforeChangeCallback(),this._x=s*Math.sin(i),this._y=Math.cos(e)*t,this._z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this._onBeforeChangeCallback(),this._x=t*Math.sin(e),this._y=i,this._z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this._onBeforeChangeCallback(),this._x=e[12],this._y=e[13],this._z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this._onBeforeChangeCallback(),this._x=e,this._y=i,this._z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return this._onBeforeGetComponentCallback(),t.x===this._x&&t.y===this._y&&t.z===this._z}fromArray(t,e=0){return this._onBeforeChangeCallback(),this._x=t[e],this._y=t[e+1],this._z=t[e+2],this}toArray(t=[],e=0){return this._onBeforeGetComponentCallback(),t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this._onBeforeChangeCallback(),this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this}random(){return this._onBeforeChangeCallback(),this._x=Math.random(),this._y=Math.random(),this._z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,i=Math.sqrt(1-Math.pow(t,2));return this._onBeforeChangeCallback(),this._x=i*Math.cos(e),this._y=i*Math.sin(e),this._z=t,this}*[Symbol.iterator](){this._onBeforeGetComponentCallback(),yield this._x,this._onBeforeGetComponentCallback(),yield this._y,this._onBeforeGetComponentCallback(),yield this._z}lengthManhattan(){throw new Error("deprecated")}distanceToManhattan(t){throw new Error("deprecated")}}const yl=new fl,gl=new dt,xl=[];for(let t=0;t<256;t++)xl[t]=(t<16?"0":"")+t.toString(16);function vl(t,e,i){return Math.max(e,Math.min(i,t))}Math.PI,Math.PI;class Sl{constructor(t=0,e=0,i=0,s=Sl.DefaultOrder){this.isEuler=!0,this._internal_x=t,this._internal_y=e,this._internal_z=i,this._internal_order=s,this._onChangeCallback=()=>{},this._onBeforeChangeCallback=()=>{},this._onBeforeGetComponentCallback=()=>{}}onBeforeGetComponent(t){this._onBeforeGetComponentCallback=t}onBeforeChange(t){this._onBeforeChangeCallback=t}get _x(){return this._onBeforeGetComponentCallback(),this._internal_x}set _x(t){this._internal_x=t}get _y(){return this._onBeforeGetComponentCallback(),this._internal_y}set _y(t){this._internal_y=t}get _z(){return this._onBeforeGetComponentCallback(),this._internal_z}set _z(t){this._internal_z=t}get _order(){return this._onBeforeGetComponentCallback(),this._internal_order}set _order(t){this._internal_order=t}get x(){return this._onBeforeGetComponentCallback(),this._internal_x}set x(t){this._onBeforeChangeCallback(),this._internal_x=t,this._onChangeCallback()}get y(){return this._onBeforeGetComponentCallback(),this._internal_y}set y(t){this._onBeforeChangeCallback(),this._internal_y=t,this._onChangeCallback()}get z(){return this._onBeforeGetComponentCallback(),this._internal_z}set z(t){this._onBeforeChangeCallback(),this._internal_z=t,this._onChangeCallback()}get order(){return this._onBeforeGetComponentCallback(),this._internal_order}set order(t){this._onBeforeChangeCallback(),this._internal_order=t,this._onChangeCallback()}set(t,e,i,s){return this._onBeforeChangeCallback(),this._internal_x=t,this._internal_y=e,this._internal_z=i,s&&(this._internal_order=s),this._onChangeCallback(),this}clone(){return this._onBeforeGetComponentCallback(),new ie(this._internal_x,this._internal_y,this._internal_z,this._internal_order)}copy(t){return this._onBeforeChangeCallback(),this._internal_x=t._x,this._internal_y=t._y,this._internal_z=t._z,this._internal_order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,i=!0){this._onBeforeGetComponentCallback();const s=t.elements,n=s[0],r=s[4],o=s[8],a=s[1],l=s[5],h=s[9],c=s[2],m=s[6],u=s[10];switch(e||(e=this._internal_order),this._onBeforeChangeCallback(),e){case"XYZ":this._internal_y=Math.asin(vl(o,-1,1)),Math.abs(o)<.9999999?(this._internal_x=Math.atan2(-h,u),this._internal_z=Math.atan2(-r,n)):(this._internal_x=Math.atan2(m,l),this._internal_z=0);break;case"YXZ":this._internal_x=Math.asin(-vl(h,-1,1)),Math.abs(h)<.9999999?(this._internal_y=Math.atan2(o,u),this._internal_z=Math.atan2(a,l)):(this._internal_y=Math.atan2(-c,n),this._internal_z=0);break;case"ZXY":this._internal_x=Math.asin(vl(m,-1,1)),Math.abs(m)<.9999999?(this._internal_y=Math.atan2(-c,u),this._internal_z=Math.atan2(-r,l)):(this._internal_y=0,this._internal_z=Math.atan2(a,n));break;case"ZYX":this._internal_y=Math.asin(-vl(c,-1,1)),Math.abs(c)<.9999999?(this._internal_x=Math.atan2(m,u),this._internal_z=Math.atan2(a,n)):(this._internal_x=0,this._internal_z=Math.atan2(-r,l));break;case"YZX":this._internal_z=Math.asin(vl(a,-1,1)),Math.abs(a)<.9999999?(this._internal_x=Math.atan2(-h,l),this._internal_y=Math.atan2(-c,n)):(this._internal_x=0,this._internal_y=Math.atan2(o,u));break;case"XZY":this._internal_z=Math.asin(-vl(r,-1,1)),Math.abs(r)<.9999999?(this._internal_x=Math.atan2(m,l),this._internal_y=Math.atan2(o,n)):(this._internal_x=Math.atan2(-h,u),this._internal_y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._internal_order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return wl.makeRotationFromQuaternion(t),this.setFromRotationMatrix(wl,e,i)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e)}reorder(t){return bl.setFromEuler(this),this.setFromQuaternion(bl,t)}equals(t){return this._onBeforeGetComponentCallback(),t._x===this._internal_x&&t._y===this._internal_y&&t._z===this._internal_z&&t._order===this._internal_order}fromArray(t){return this._onBeforeChangeCallback(),this._internal_x=t[0],this._internal_y=t[1],this._internal_z=t[2],void 0!==t[3]&&(this._internal_order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return this._onBeforeGetComponentCallback(),t[e]=this._internal_x,t[e+1]=this._internal_y,t[e+2]=this._internal_z,t[e+3]=this._internal_order,t}toVector3(t){return this._onBeforeGetComponentCallback(),t?t.set(this._internal_x,this._internal_y,this._internal_z):new pt(this._internal_x,this._internal_y,this._internal_z)}_onChange(t){return this._onChangeCallback=t,this}}Sl.DefaultOrder="XYZ",Sl.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const wl=new qt,bl=new dt;class Cl{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._internal_x=t,this._internal_y=e,this._internal_z=i,this._internal_w=s,this._onChangeCallback=()=>{},this._onBeforeChangeCallback=()=>{},this._onBeforeGetComponentCallback=()=>{}}onBeforeGetComponent(t){this._onBeforeGetComponentCallback=t}onBeforeChange(t){this._onBeforeChangeCallback=t}static slerp(t,e,i,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,s)}static slerpFlat(t,e,i,s,n,r,o){let a=i[s+0],l=i[s+1],h=i[s+2],c=i[s+3];const m=n[r+0],u=n[r+1],_=n[r+2],d=n[r+3];if(0===o)return t[e+0]=a,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===o)return t[e+0]=m,t[e+1]=u,t[e+2]=_,void(t[e+3]=d);if(c!==d||a!==m||l!==u||h!==_){let t=1-o;const e=a*m+l*u+h*_+c*d,i=e>=0?1:-1,s=1-e*e;if(s>Number.EPSILON){const n=Math.sqrt(s),r=Math.atan2(n,e*i);t=Math.sin(t*r)/n,o=Math.sin(o*r)/n}const n=o*i;if(a=a*t+m*n,l=l*t+u*n,h=h*t+_*n,c=c*t+d*n,t===1-o){const t=1/Math.sqrt(a*a+l*l+h*h+c*c);a*=t,l*=t,h*=t,c*=t}}t[e]=a,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const o=i[s],a=i[s+1],l=i[s+2],h=i[s+3],c=n[r],m=n[r+1],u=n[r+2],_=n[r+3];return t[e]=o*_+h*c+a*u-l*m,t[e+1]=a*_+h*m+l*c-o*u,t[e+2]=l*_+h*u+o*m-a*c,t[e+3]=h*_-o*c-a*m-l*u,t}get _x(){return this._onBeforeGetComponentCallback(),this._internal_x}set _x(t){this._internal_x=t}get _y(){return this._onBeforeGetComponentCallback(),this._internal_y}set _y(t){this._internal_y=t}get _z(){return this._onBeforeGetComponentCallback(),this._internal_z}set _z(t){this._internal_z=t}get _w(){return this._onBeforeGetComponentCallback(),this._internal_w}set _w(t){this._internal_w=t}get x(){return this._onBeforeGetComponentCallback(),this._internal_x}set x(t){this._onBeforeChangeCallback(),this._internal_x=t,this._onChangeCallback()}get y(){return this._onBeforeGetComponentCallback(),this._internal_y}set y(t){this._onBeforeChangeCallback(),this._internal_y=t,this._onChangeCallback()}get z(){return this._onBeforeGetComponentCallback(),this._internal_z}set z(t){this._onBeforeChangeCallback(),this._internal_z=t,this._onChangeCallback()}get w(){return this._onBeforeGetComponentCallback(),this._internal_w}set w(t){this._onBeforeChangeCallback(),this._internal_w=t,this._onChangeCallback()}set(t,e,i,s){return this._onBeforeChangeCallback(),this._internal_x=t,this._internal_y=e,this._internal_z=i,this._internal_w=s,this._onChangeCallback(),this}clone(){return this._onBeforeGetComponentCallback(),new dt(this._internal_x,this._internal_y,this._internal_z,this._internal_w)}copy(t){return this._onBeforeChangeCallback(),this._internal_x=t.x,this._internal_y=t.y,this._internal_z=t.z,this._internal_w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,s=t._y,n=t._z,r=t._order,o=Math.cos,a=Math.sin,l=o(i/2),h=o(s/2),c=o(n/2),m=a(i/2),u=a(s/2),_=a(n/2);switch(this._onBeforeChangeCallback(),r){case"XYZ":this._internal_x=m*h*c+l*u*_,this._internal_y=l*u*c-m*h*_,this._internal_z=l*h*_+m*u*c,this._internal_w=l*h*c-m*u*_;break;case"YXZ":this._internal_x=m*h*c+l*u*_,this._internal_y=l*u*c-m*h*_,this._internal_z=l*h*_-m*u*c,this._internal_w=l*h*c+m*u*_;break;case"ZXY":this._internal_x=m*h*c-l*u*_,this._internal_y=l*u*c+m*h*_,this._internal_z=l*h*_+m*u*c,this._internal_w=l*h*c-m*u*_;break;case"ZYX":this._internal_x=m*h*c-l*u*_,this._internal_y=l*u*c+m*h*_,this._internal_z=l*h*_-m*u*c,this._internal_w=l*h*c+m*u*_;break;case"YZX":this._internal_x=m*h*c+l*u*_,this._internal_y=l*u*c+m*h*_,this._internal_z=l*h*_-m*u*c,this._internal_w=l*h*c-m*u*_;break;case"XZY":this._internal_x=m*h*c-l*u*_,this._internal_y=l*u*c-m*h*_,this._internal_z=l*h*_+m*u*c,this._internal_w=l*h*c+m*u*_;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._onBeforeChangeCallback(),this._internal_x=t.x*s,this._internal_y=t.y*s,this._internal_z=t.z*s,this._internal_w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],o=e[5],a=e[9],l=e[2],h=e[6],c=e[10],m=i+o+c;if(this._onBeforeChangeCallback(),m>0){const t=.5/Math.sqrt(m+1);this._internal_w=.25/t,this._internal_x=(h-a)*t,this._internal_y=(n-l)*t,this._internal_z=(r-s)*t}else if(i>o&&i>c){const t=2*Math.sqrt(1+i-o-c);this._internal_w=(h-a)/t,this._internal_x=.25*t,this._internal_y=(s+r)/t,this._internal_z=(n+l)/t}else if(o>c){const t=2*Math.sqrt(1+o-i-c);this._internal_w=(n-l)/t,this._internal_x=(s+r)/t,this._internal_y=.25*t,this._internal_z=(a+h)/t}else{const t=2*Math.sqrt(1+c-i-o);this._internal_w=(r-s)/t,this._internal_x=(n+l)/t,this._internal_y=(a+h)/t,this._internal_z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return this._onBeforeChangeCallback(),i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._internal_x=-t.y,this._internal_y=t.x,this._internal_z=0,this._internal_w=i):(this._internal_x=0,this._internal_y=-t.z,this._internal_z=t.y,this._internal_w=i)):(this._internal_x=t.y*e.z-t.z*e.y,this._internal_y=t.z*e.x-t.x*e.z,this._internal_z=t.x*e.y-t.y*e.x,this._internal_w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(J.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._internal_x*=-1,this._internal_y*=-1,this._internal_z*=-1,this._onChangeCallback(),this}dot(t){return this._onBeforeGetComponentCallback(),this._internal_x*t._x+this._internal_y*t._y+this._internal_z*t._z+this._internal_w*t._w}lengthSq(){return this._onBeforeGetComponentCallback(),this._internal_x*this._internal_x+this._internal_y*this._internal_y+this._internal_z*this._internal_z+this._internal_w*this._internal_w}length(){return this._onBeforeGetComponentCallback(),Math.sqrt(this._internal_x*this._internal_x+this._internal_y*this._internal_y+this._internal_z*this._internal_z+this._internal_w*this._internal_w)}normalize(){let t=this.length();return 0===t?(this._onBeforeChangeCallback(),this._internal_x=0,this._internal_y=0,this._internal_z=0,this._internal_w=1):(t=1/t,this._onBeforeGetComponentCallback(),this._onBeforeChangeCallback(),this._internal_x=this._internal_x*t,this._internal_y=this._internal_y*t,this._internal_z=this._internal_z*t,this._internal_w=this._internal_w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,o=e._x,a=e._y,l=e._z,h=e._w;return this._onBeforeChangeCallback(),this._internal_x=i*h+r*o+s*l-n*a,this._internal_y=s*h+r*a+n*o-i*l,this._internal_z=n*h+r*l+i*a-s*o,this._internal_w=r*h-i*o-s*a-n*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);this._onBeforeGetComponentCallback();const i=this._internal_x,s=this._internal_y,n=this._internal_z,r=this._internal_w;let o=r*t._w+i*t._x+s*t._y+n*t._z;if(this._onBeforeChangeCallback(),o<0?(this._internal_w=-t._w,this._internal_x=-t._x,this._internal_y=-t._y,this._internal_z=-t._z,o=-o):this.copy(t),o>=1)return this._internal_w=r,this._internal_x=i,this._internal_y=s,this._internal_z=n,this;const a=1-o*o;if(a<=Number.EPSILON){const t=1-e;return this._internal_w=t*r+e*this._internal_w,this._internal_x=t*i+e*this._internal_x,this._internal_y=t*s+e*this._internal_y,this._internal_z=t*n+e*this._internal_z,this.normalize(),this}const l=Math.sqrt(a),h=Math.atan2(l,o),c=Math.sin((1-e)*h)/l,m=Math.sin(e*h)/l;return this._internal_w=r*c+this._internal_w*m,this._internal_x=i*c+this._internal_x*m,this._internal_y=s*c+this._internal_y*m,this._internal_z=n*c+this._internal_z*m,this._onChangeCallback(),this}slerpQuaternions(t,e,i){this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),s=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(e*Math.cos(s),i*Math.sin(n),i*Math.cos(n),e*Math.sin(s))}equals(t){return this._onBeforeGetComponentCallback(),t._x===this._internal_x&&t._y===this._internal_y&&t._z===this._internal_z&&t._w===this._internal_w}fromArray(t,e=0){return this._onBeforeChangeCallback(),this._internal_x=t[e],this._internal_y=t[e+1],this._internal_z=t[e+2],this._internal_w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return this._onBeforeGetComponentCallback(),t[e]=this._internal_x,t[e+1]=this._internal_y,t[e+2]=this._internal_z,t[e+3]=this._internal_w,t}fromBufferAttribute(t,e){return this._internal_x=t.getX(e),this._internal_y=t.getY(e),this._internal_z=t.getZ(e),this._internal_w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}multiplyVector3(t){throw new Error("deprecated")}inverse(){throw new Error("deprecated")}}class Al{constructor(t,e,i){this._hasChanged=!1,this._localMatrixNeedUpdate=!1,this._worldMatrixNeedUpdate=!1,this._worldPositionRotationScaleNeedUpdate=!1,this._localPositionRotationScaleNeedUpdate=!1,this._onBeforeGetLocalBind=this.onBeforeGetLocal.bind(this),this._onBeforeLocalChangeBind=this.onBeforeLocalChange.bind(this),this._onLocalEulerRotationChangedBind=this.onLocalEulerRotationChanged.bind(this),this._onLocalRotationChangedBind=this.onLocalRotationChanged.bind(this),this._onBeforeGetWorldBind=this.onBeforeGetWorld.bind(this),this._onBeforeWorldChangeBind=this.onBeforeWorldChange.bind(this),this._onWorldEulerRotationChangedBind=this.onWorldEulerRotationChanged.bind(this),this._onWorldRotationChangedBind=this.onWorldRotationChanged.bind(this),this._ignoreObservableEvent=!1,this.isRegisteredToProcessor=!1,this._engineGlobalObject=e,this._onParentChanged=i,this._object3D=new Al.TransformObject3D,this._object3D.matrixAutoUpdate=!0,this._object3D.userData=this,e.scene.add(this._object3D),Object.defineProperties(this._object3D,{position:{writable:!0},rotation:{writable:!0},quaternion:{writable:!0},scale:{writable:!0}});const s=this._onBeforeGetLocalBind,n=this._onBeforeLocalChangeBind,r=new fl;r.onBeforeGetComponent(s),r.onBeforeChange(n),this._object3D.position=r;const o=new Sl;o.onBeforeGetComponent(s),o.onBeforeChange(n),o._onChange(this._onLocalEulerRotationChangedBind),this._object3D.rotation=o;const a=new Cl;a.onBeforeGetComponent(s),a.onBeforeChange(n),a._onChange(this._onLocalRotationChangedBind),this._object3D.quaternion=a;const l=new fl(1,1,1);l.onBeforeGetComponent(s),l.onBeforeChange(n),this._object3D.scale=l,this._gameObject=t;const h=this._onBeforeGetWorldBind,c=this._onBeforeWorldChangeBind,m=new fl;m.onBeforeGetComponent(h),m.onBeforeChange(c),this._worldPosition=m;const u=new Sl;u.onBeforeGetComponent(h),u.onBeforeChange(c),u._onChange(this._onWorldEulerRotationChangedBind),this._worldRotationEuler=u;const _=new Cl;_.onBeforeGetComponent(h),_.onBeforeChange(c),_._onChange(this._onWorldRotationChangedBind),this._worldRotation=_;const d=new fl(1,1,1);d.onBeforeGetComponent(h),d.onBeforeChange(c),this._worldScale=d,this.setWorldMatrixNeedUpdateRecursively()}onBeforeGetLocal(){this._ignoreObservableEvent||this.updateLocalPositionRotationScaleFromOthers()}onBeforeLocalChange(){this._ignoreObservableEvent||(this.updateChildrenLocalPositionRotationScaleFromOthersRecursively(),this._localPositionRotationScaleNeedUpdate=!1,this._localMatrixNeedUpdate=!0,this.setWorldMatrixNeedUpdateRecursively(),this.setWorldPositionRotationScaleNeedUpdateRecursively(),this.setHasChangedRecursively())}onLocalEulerRotationChanged(){this._ignoreObservableEvent||this._object3D.quaternion.setFromEuler(this._object3D.rotation,!1)}onLocalRotationChanged(){this._ignoreObservableEvent||this._object3D.rotation.setFromQuaternion(this._object3D.quaternion,void 0,!1)}onBeforeGetWorld(){this._ignoreObservableEvent||this.updateWorldPositionRotationScaleFromOthers()}onBeforeWorldChange(){this._ignoreObservableEvent||(this.updateChildrenLocalPositionRotationScaleFromOthersRecursively(),this._worldPositionRotationScaleNeedUpdate=!1,this._localMatrixNeedUpdate=!0,this.setWorldMatrixNeedUpdateRecursively(),this._localPositionRotationScaleNeedUpdate=!0,this.setHasChangedRecursively())}onWorldEulerRotationChanged(){this._ignoreObservableEvent||this._worldRotation.setFromEuler(this._worldRotationEuler,!1)}onWorldRotationChanged(){this._ignoreObservableEvent||this._worldRotationEuler.setFromQuaternion(this._worldRotation,void 0,!1)}setWorldPositionRotationScaleNeedUpdateRecursively(){this._worldPositionRotationScaleNeedUpdate=!0;const t=this._object3D.children;for(let e=0,i=t.length;e<i;e++){const i=t[e];i.userData instanceof Al&&i.userData.setWorldPositionRotationScaleNeedUpdateRecursively()}}setWorldMatrixNeedUpdateRecursively(){this._engineGlobalObject.transformMatrixProcessor.enqueueTransformToUpdate(this),this.setWorldMatrixNeedUpdateRecursivelyInternal()}setWorldMatrixNeedUpdateRecursivelyInternal(){this._worldMatrixNeedUpdate=!0;const t=this._object3D.children;for(let e=0,i=t.length;e<i;e++){const i=t[e];i.userData instanceof Al&&i.userData.setWorldMatrixNeedUpdateRecursivelyInternal()}}setHasChangedRecursively(){this._hasChanged=!0;const t=this._object3D.children;for(let e=0,i=t.length;e<i;e++){const i=t[e];i.userData instanceof Al&&i.userData.setHasChangedRecursively()}}updateLocalPositionRotationScaleFromOthers(){if(this._localPositionRotationScaleNeedUpdate){if(this._localMatrixNeedUpdate){this._worldMatrixNeedUpdate&&(this._ignoreObservableEvent=!0,this._object3D.matrixWorld.compose(this._worldPosition,this._worldRotation,this._worldScale),this._ignoreObservableEvent=!1,this._worldMatrixNeedUpdate=!1,this._gameObject.invokeOnWorldMatrixUpdate());const t=this.parent;if(t){t.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=Al._matrix4Buffer.copy(t._object3D.matrixWorld).invert();this._object3D.matrix.multiplyMatrices(this._object3D.matrixWorld,e)}else this._object3D.matrix.copy(this._object3D.matrixWorld);this._localMatrixNeedUpdate=!1}this._ignoreObservableEvent=!0,this._object3D.matrix.decompose(this.localPosition,this.localRotation,this.localScale),this.localEulerAngles.setFromQuaternion(this.localRotation,void 0,!1),this._ignoreObservableEvent=!1,this._localPositionRotationScaleNeedUpdate=!1}}updateWorldPositionRotationScaleFromOthers(){this._worldPositionRotationScaleNeedUpdate&&(this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),this._ignoreObservableEvent=!0,this._object3D.matrixWorld.decompose(this._worldPosition,this._worldRotation,this._worldScale),this._worldRotationEuler.setFromQuaternion(this._worldRotation,void 0,!1),this._ignoreObservableEvent=!1,this._worldPositionRotationScaleNeedUpdate=!1)}updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(){if(!this._worldMatrixNeedUpdate)return;const t=this._object3D.matrix;if(this._localPositionRotationScaleNeedUpdate)this._ignoreObservableEvent=!0,this._object3D.matrixWorld.compose(this._worldPosition,this._worldRotation,this._worldScale),this._ignoreObservableEvent=!1;else{this._localMatrixNeedUpdate&&(this._ignoreObservableEvent=!0,t.compose(this.localPosition,this.localRotation,this.localScale),this._ignoreObservableEvent=!1,this._localMatrixNeedUpdate=!1);const e=this.parent;e?(e.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),this._object3D.matrixWorld.multiplyMatrices(e._object3D.matrixWorld,t)):this._object3D.matrixWorld.copy(t)}this._worldMatrixNeedUpdate=!1,this._gameObject.invokeOnWorldMatrixUpdate()}updateLocalMatrixFromOthers(){if(!this._localMatrixNeedUpdate)return;const t=this._object3D.matrix;if(this._worldPositionRotationScaleNeedUpdate)this._ignoreObservableEvent=!0,t.compose(this.localPosition,this.localRotation,this.localScale),this._ignoreObservableEvent=!1;else{this._worldMatrixNeedUpdate&&(this._ignoreObservableEvent=!0,this._object3D.matrixWorld.compose(this._worldPosition,this._worldRotation,this._worldScale),this._ignoreObservableEvent=!1,this._worldMatrixNeedUpdate=!1);const t=this.parent;if(t){t.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=Al._matrix4Buffer.copy(t._object3D.matrixWorld).invert();this._object3D.matrix.multiplyMatrices(this._object3D.matrixWorld,e)}else this._object3D.matrix.copy(this._object3D.matrixWorld)}this._localMatrixNeedUpdate=!1,this._gameObject.invokeOnWorldMatrixUpdate()}updateChildrenLocalPositionRotationScaleFromOthersRecursively(){const t=this._object3D.children;for(let e=0,i=t.length;e<i;e++){const i=t[e];i.userData instanceof Al&&(i.userData.updateLocalPositionRotationScaleFromOthers(),i.userData.updateChildrenLocalPositionRotationScaleFromOthersRecursively())}}tryUpdateWorldMatrixRecursivelyFromThisToChildren(){return!this._gameObject._destroyed&&this.tryUpdateWorldMatrixRecursivelyFromThisToChildrenInternal()}tryUpdateWorldMatrixRecursivelyFromThisToChildrenInternal(){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const t=this._object3D.children;for(let e=0,i=t.length;e<i;e++){const i=t[e];i.userData instanceof Al&&i.userData.tryUpdateWorldMatrixRecursivelyFromThisToChildrenInternal()}return!0}foreachChild(t){const e=this._object3D.children;for(let i=0,s=e.length;i<s;i++){const s=e[i];s.userData instanceof Al&&t(s.userData)}}iterateChild(t){const e=this._object3D.children;for(let i=0,s=e.length;i<s;i++){const s=e[i];if(s.userData instanceof Al&&!t(s.userData))break}}get parent(){return this._object3D.parent instanceof pl?null:this._object3D.parent.userData}set parent(t){if(t){const e=this.parent;this.updateLocalPositionRotationScaleFromOthers(),this._object3D.removeFromParent(),t._object3D.add(this._object3D),this.setWorldMatrixNeedUpdateRecursively(),this._onParentChanged(e,t)}else{const t=this.parent;this.updateLocalPositionRotationScaleFromOthers(),this._object3D.removeFromParent(),this._engineGlobalObject.scene.add(this._object3D),this.setWorldMatrixNeedUpdateRecursively(),this._onParentChanged(t,null)}}get children(){return this._object3D.children.filter((t=>t.userData instanceof Al)).map((t=>t.userData))}get gameObject(){return this._gameObject}getForward(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements;return t?t.set(e[8],e[9],e[10]):new pt(e[8],e[9],e[10])}setForward(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements,i=Al._vector3Buffer.copy(t).normalize();e[8]=i.x,e[9]=i.y,e[10]=i.z,this._localMatrixNeedUpdate=!0,this._localPositionRotationScaleNeedUpdate=!0,this._worldPositionRotationScaleNeedUpdate=!0}getRight(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements;return t?t.set(e[0],e[1],e[2]):new pt(e[0],e[1],e[2])}setRight(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements,i=Al._vector3Buffer.copy(t).normalize();e[0]=i.x,e[1]=i.y,e[2]=i.z,this._localMatrixNeedUpdate=!0,this._localPositionRotationScaleNeedUpdate=!0,this._worldPositionRotationScaleNeedUpdate=!0}getUp(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements;return t?t.set(e[4],e[5],e[6]):new pt(e[4],e[5],e[6])}setUp(t){this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix();const e=this._object3D.matrixWorld.elements,i=Al._vector3Buffer.copy(t).normalize();e[4]=i.x,e[5]=i.y,e[6]=i.z,this._localMatrixNeedUpdate=!0,this._localPositionRotationScaleNeedUpdate=!0,this._worldPositionRotationScaleNeedUpdate=!0}get localPosition(){return this._object3D.position}get localEulerAngles(){return this._object3D.rotation}get localRotation(){return this._object3D.quaternion}get localScale(){return this._object3D.scale}get position(){return this._worldPosition}get eulerAngles(){return this._worldRotationEuler}get rotation(){return this._worldRotation}get lossyScale(){return this._worldScale}get hasChanged(){return this._hasChanged}set hasChanged(t){this._hasChanged=t}getWorldToLocalMatrix(t){return this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),t?t.copy(this._object3D.matrixWorld).invert():this._object3D.matrixWorld.clone().invert()}getLocalToWorldMatrix(t){return this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),t?t.copy(this._object3D.matrixWorld):this._object3D.matrixWorld.clone()}transformPoint(t){return this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),this._object3D.localToWorld(t)}inverseTransformPoint(t){return this.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),this._object3D.worldToLocal(t)}transformDirection(t){const e=Al._matrix4Buffer.copy(this._object3D.matrixWorld).makeScale(1,1,1);return t.transformDirection(e)}inverseTransformDirection(t){const e=Al._matrix4Buffer.copy(this._object3D.matrixWorld).makeScale(1,1,1).invert();return t.transformDirection(e)}transformVector(t){return t.transformDirection(this._object3D.matrixWorld)}inverseTransformVector(t){return t.transformDirection(Al._matrix4Buffer.copy(this._object3D.matrixWorld).invert())}isChildOf(t){if(this===t)return!0;const e=this.parent;return!!e&&e.isChildOf(t)}lookAt(t){const e=this.parent;Al._vector3Buffer.setFromMatrixPosition(this._object3D.matrixWorld);const i=Al._matrix4Buffer.lookAt(Al._vector3Buffer,t,this._object3D.up);if(this._object3D.quaternion.setFromRotationMatrix(i),e){i.extractRotation(e._object3D.matrixWorld);const t=Al._quaternionBuffer.setFromRotationMatrix(i);this._object3D.quaternion.premultiply(t.invert())}}setRotationFromAxisAngle(t,e){this._object3D.setRotationFromAxisAngle(t,e)}setRotationFromEuler(t){this._object3D.setRotationFromEuler(t)}setRotationFromMatrix(t){this._object3D.setRotationFromMatrix(t)}setRotationFromQuaternion(t){this._object3D.setRotationFromQuaternion(t)}rotateOnAxis(t,e){return this._object3D.rotateOnAxis(t,e),this}rotateOnWorldAxis(t,e){return this._object3D.rotateOnWorldAxis(t,e),this}rotateX(t){return this._object3D.rotateX(t),this}rotateY(t){return this._object3D.rotateY(t),this}rotateZ(t){return this._object3D.rotateZ(t),this}translateOnAxis(t,e){return this._object3D.translateOnAxis(t,e),this}translateX(t){return this._object3D.translateX(t),this}translateY(t){return this._object3D.translateY(t),this}translateZ(t){return this._object3D.translateZ(t),this}unsafeGetObject3D(){return this._object3D}enqueueRenderAttachedObject3D(t){this._engineGlobalObject.transformMatrixProcessor.enqueueRenderObject(t)}static updateRawObject3DWorldMatrixRecursively(t){t.matrixAutoUpdate&&t.updateMatrix(),t.parent?t.matrixWorld.multiplyMatrices(t.parent.matrixWorld,t.matrix):t.matrixWorld.copy(t.matrix);const e=t.children;for(let t=0,i=e.length;t<i;t++)Al.updateRawObject3DWorldMatrixRecursivelyInternal(e[t])}static updateRawObject3DWorldMatrixRecursivelyInternal(t){t.matrixAutoUpdate&&t.updateMatrix(),t.matrixWorld.multiplyMatrices(t.parent.matrixWorld,t.matrix);const e=t.children;for(let t=0,i=e.length;t<i;t++)Al.updateRawObject3DWorldMatrixRecursivelyInternal(e[t])}toJSON(){return{}}}var Bl,Ml;Al.TransformObject3D=class extends ye{updateMatrix(){this.userData.updateLocalMatrixFromOthers()}updateMatrixWorld(t){this.userData.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix()}updateWorldMatrix(t,e){if(this.userData.updateWorldMatrixFromLocalMatrixAndParentWorldMatrix(),e){const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].updateWorldMatrix(!1,!0)}}},Al._matrix4Buffer=new qt,Al._vector3Buffer=new pt,Al._quaternionBuffer=new dt,function(t){t[t.awake=0]="awake",t[t.start=2]="start",t[t.update=3]="update",t[t.onEnable=1]="onEnable",t[t.onDisable=1]="onDisable",t[t.onDestroy=4]="onDestroy"}(Bl||(Bl={}));class Vl{constructor(t,e,i,s){this.isRemoved=!1,this._priority=i,this._eventId=t.generateEventId(),this._componentExecutionOrder=s,this._eventFunc=e}static createAwakeEvent(t,e){return new Vl(t,e,Bl.awake,0)}static createStartEvent(t,e,i){return new Vl(t,e,Bl.start,i)}static createUpdateEvent(t,e,i){return new Vl(t,e,Bl.update,i)}static createOnEnableEvent(t,e,i){return new Vl(t,e,Bl.onEnable,i)}static createOnDisableEvent(t,e,i){return new Vl(t,e,Bl.onDisable,i)}static createOnDestroyEvent(t,e,i){return new Vl(t,e,Bl.onDestroy,i)}invoke(){this._eventFunc()}static comparator(t,e){return t._priority===e._priority?t._componentExecutionOrder===e._componentExecutionOrder?t._eventId-e._eventId:t._componentExecutionOrder-e._componentExecutionOrder:t._priority-e._priority}}class Tl{constructor(){this.awakeCalled=!1,this.startRegistered=!1,this.startCalled=!1,this.updateRegistered=!1,this.enabled=!1}}function Pl(t){return void 0!==t.onWorldMatrixUpdated}class Dl{constructor(t){this._awake=null,this._onDestroy=null,this._onWorldMatrixUpdated=null,this._start=null,this._update=null,this._component=t,this._sceneProcessor=t.engine.sceneProcessor,this._instantiater=t.engine.instantiater,this._eventState=new Tl,function(t){return void 0!==t.awake}(t)&&(this._awake=Vl.createAwakeEvent(this._instantiater,t.awake.bind(t))),function(t){return void 0!==t.onDestroy}(t)&&(this._onDestroy=Vl.createOnDestroyEvent(this._instantiater,t.onDestroy.bind(t),t.executionOrder)),Pl(t)&&(this._onWorldMatrixUpdated=t.onWorldMatrixUpdated.bind(t)),function(t){return void 0!==t.start}(t)&&(this._start=Vl.createStartEvent(this._instantiater,(()=>{this._eventState.startCalled=!0,t.start(),this._eventState.startRegistered&&this._sceneProcessor.removeEventFromNonSyncedCollection(this._start)}),t.executionOrder)),function(t){return void 0!==t.update}(t)&&(this._update=Vl.createUpdateEvent(this._instantiater,t.update.bind(t),t.executionOrder))}tryCallAwake(){var t;this._eventState.awakeCalled||(this._eventState.awakeCalled=!0,null===(t=this._awake)||void 0===t||t.invoke())}tryRegisterOnEnable(){if(void 0===this._component.onEnable)return;if(this._component._engine_internal_destroyed)return;if(this._eventState.enabled)return;this._eventState.enabled=!0;const t=Vl.createOnEnableEvent(this._instantiater,this._component.onEnable.bind(this._component),this._component.executionOrder);this._sceneProcessor.addEventToSyncedCollection(t)}tryRegisterOnDisable(){if(void 0===this._component.onDisable)return;if(this._component._engine_internal_destroyed)return;if(!this._eventState.enabled)return;this._eventState.enabled=!1;const t=Vl.createOnDisableEvent(this._instantiater,this._component.onDisable.bind(this._component),this._component.executionOrder);this._sceneProcessor.addEventToSyncedCollection(t)}tryRegisterOnDestroy(){this._onDestroy&&this._sceneProcessor.addEventToSyncedCollection(this._onDestroy)}tryCallOnWorldMatrixUpdated(){var t;null===(t=this._onWorldMatrixUpdated)||void 0===t||t.call(this)}tryRegisterStart(){this._start&&(this._component._engine_internal_destroyed||this._eventState.startCalled||this._eventState.startRegistered||(this._eventState.startRegistered=!0,this._sceneProcessor.addEventToNonSyncedCollection(this._start)))}tryUnregisterStart(){this._start&&this._eventState.startRegistered&&!this._eventState.startCalled&&(this._eventState.startRegistered=!1,this._sceneProcessor.removeEventFromNonSyncedCollection(this._start))}tryRegisterUpdate(){this._update&&(this._component._engine_internal_destroyed||this._eventState.updateRegistered||(this._eventState.updateRegistered=!0,this._sceneProcessor.addEventToNonSyncedCollection(this._update)))}tryUnregisterUpdate(){this._update&&this._eventState.updateRegistered&&(this._eventState.updateRegistered=!1,this._sceneProcessor.removeEventFromNonSyncedCollection(this._update))}}class Il{constructor(t,e){this._destroyed=!1,this._engineGlobalObject=t,this._instanceId=t.instantiater.generateId(),this._activeInHierarchy=!0,this._activeSelf=!0,this._initialized=!1,this._components=[],this._matrixUpdateComponents=[],this._transform=new Al(this,t,this.onChangeParent.bind(this)),this._transform.unsafeGetObject3D().name=e}addChildFromBuilder(t){const e=t.build(this.transform);return t.processEvent(),e}onChangeParent(t,e){if(e&&this._engineGlobalObject!==e.gameObject._engineGlobalObject)throw new Error("can't change parent to another engine instance");const i=this.transform.gameObject;e?i._activeSelf&&i.setActiveInHierarchyWithEvent(e.gameObject._activeInHierarchy):i.setActiveInHierarchyWithEvent(i._activeSelf)}addComponent(t){const e=new t(this);if(e.engine_internal_constructAfterProcess(),e.disallowMultipleComponent&&this.getComponent(t))return console.warn(`Component ${t.name} already exists on GameObject ${this.name}`),null;const i=e.requiredComponents;for(let e=0;e<i.length;e++){const s=i[e];if(!this.getComponent(s))return console.warn(`Component ${s.name} is required by Component ${t.name} on GameObject ${this.name}`),null}return this._components.push(e),this.tryAddMatrixUpdateComponent(e),this._activeInHierarchy&&e.enabled&&(e._engine_internal_componentEventContainer.tryCallAwake(),e._engine_internal_componentEventContainer.tryRegisterOnEnable(),e._engine_internal_componentEventContainer.tryRegisterStart(),e._engine_internal_componentEventContainer.tryRegisterUpdate(),this._engineGlobalObject.sceneProcessor.tryStartProcessSyncedEvent()),e}tryAddMatrixUpdateComponent(t){Pl(t)&&this._matrixUpdateComponents.push(t)}invokeOnWorldMatrixUpdate(){for(let t=0;t<this._matrixUpdateComponents.length;t++)this._matrixUpdateComponents[t].onWorldMatrixUpdated()}getComponent(t){const e=this._components;for(let i=0;i<e.length;i++){const s=e[i];if(s instanceof t)return s}return null}getComponents(t){if(!t)return this._components.slice();const e=this._components,i=[];for(let s=0;s<e.length;s++){const n=e[s];n instanceof t&&i.push(n)}return i}getComponentInChildren(t){const e=this.getComponent(t);if(e)return e;let i=null;return this._transform.iterateChild((e=>{const s=e.gameObject.getComponentInChildren(t);return!s||(i=s,!1)})),i}getComponentsInChildren(t){if(t){const e=this.getComponents(t);return this._transform.foreachChild((i=>{const s=i.gameObject.getComponentsInChildren(t);e.push(...s)})),e}{const t=this.getComponents();return this._transform.foreachChild((e=>{t.push(...e.gameObject.getComponentsInChildren())})),t}}foreachComponent(t,e){const i=this._components;if(e)for(let s=0;s<i.length;s++){const n=i[s];n instanceof e&&t(n)}else for(let e=0;e<i.length;e++)t(i[e])}foreachComponentInChildren(t,e){e?(this.foreachComponent(t,e),this._transform.foreachChild((i=>{i.gameObject.foreachComponentInChildren(t,e)}))):(this.foreachComponent(t),this._transform.foreachChild((e=>{e.gameObject.foreachComponentInChildren(t)})))}destroy(){this._destroyed||(this._destroyed=!0,this.destroyEventProcess(),this._engineGlobalObject.sceneProcessor.tryStartProcessSyncedEvent(),this._engineGlobalObject.sceneProcessor.addRemoveGameObject(this))}destroyEventProcess(){const t=this._components;for(let e=0;e<t.length;e++){const i=t[e];i._engine_internal_destroyed||(i.enabled&&this._activeInHierarchy&&(i._engine_internal_componentEventContainer.tryRegisterOnDisable(),i._engine_internal_componentEventContainer.tryUnregisterStart(),i._engine_internal_componentEventContainer.tryUnregisterUpdate()),i.stopAllCoroutines(),i._engine_internal_componentEventContainer.tryRegisterOnDestroy(),i._engine_internal_destroyed=!0)}this._transform.children.forEach((t=>{t instanceof Al&&t.gameObject.destroyEventProcess()}))}removeFromParent(){this._transform.unsafeGetObject3D().removeFromParent()}removeComponent(t){const e=this._components.indexOf(t);e>=0&&this._components.splice(e,1)}get engine(){return this._engineGlobalObject}get activeInHierarchy(){return this._activeInHierarchy}set activeInHierarchy(t){if(this._activeInHierarchy!==t){if(this._activeInHierarchy=t,this._initialized){const t=this._components;if(this._activeInHierarchy)for(let e=0;e<t.length;e++){const i=t[e];i.enabled&&(i._engine_internal_componentEventContainer.tryCallAwake(),i._engine_internal_componentEventContainer.tryRegisterOnEnable(),i._engine_internal_componentEventContainer.tryRegisterStart(),i._engine_internal_componentEventContainer.tryRegisterUpdate())}else for(let e=0;e<t.length;e++){const i=t[e];i.enabled&&(i._engine_internal_componentEventContainer.tryRegisterOnDisable(),i._engine_internal_componentEventContainer.tryUnregisterUpdate(),i.stopAllCoroutines())}}this._transform.foreachChild((t=>{const e=t.gameObject;this._activeInHierarchy?e.activeInHierarchy=e._activeSelf:e.activeInHierarchy=!1}))}}setActiveInHierarchyWithEvent(t){this._activeInHierarchy!==t&&(this.activeInHierarchy=t,this._initialized&&this._engineGlobalObject.sceneProcessor.tryStartProcessSyncedEvent())}get activeSelf(){return this._activeSelf}set activeSelf(t){this._activeSelf!==t&&(this._activeSelf=t,this._transform.parent instanceof Al?this._transform.parent.gameObject._activeInHierarchy?this.setActiveInHierarchyWithEvent(this._activeSelf):this.setActiveInHierarchyWithEvent(!1):this.setActiveInHierarchyWithEvent(this._activeSelf))}get transform(){return this._transform}get name(){return this._transform.unsafeGetObject3D().name}set name(t){this._transform.unsafeGetObject3D().name=t}get instanceId(){return this._instanceId}get initialized(){return this._initialized}}class El{constructor(t,e,i,s,n){this._gameObject=new Il(t,e);const r=this._gameObject.transform;i&&r.localPosition.copy(i),s&&r.localRotation.copy(s),n&&r.localScale.copy(n),this._children=[],this._componentInitializeFuncList=[]}active(t){return this._gameObject.activeSelf=t,this}getGameObject(t){return t.ref=this._gameObject,this}getComponent(t,e){return e.ref=this._gameObject.getComponent(t),this}getComponents(t,e){return t.ref=e?this._gameObject.getComponents(e):this._gameObject.getComponents(),this}getComponentInChildren(t,e){return e.ref=this._gameObject.getComponentInChildren(t),this}getComponentsInChildren(t,e){return t.ref=e?this._gameObject.getComponentsInChildren(e):this._gameObject.getComponentsInChildren(),this}withComponent(t,e){const i=new t(this._gameObject);return i.engine_internal_constructAfterProcess(),i.disallowMultipleComponent&&this._gameObject.getComponent(t)?(console.warn(`Component ${t.name} already exists on GameObject ${this._gameObject.name}`),this):(this._gameObject._components.push(i),this._gameObject.tryAddMatrixUpdateComponent(i),e&&this._componentInitializeFuncList.push((()=>e(i))),this)}withChild(t){return this._children.push(t),this}checkComponentRequirements(t){let e=!1;const i=t._components;for(let s=0;s<i.length;s++){const n=i[s],r=n.requiredComponents;for(let i=0;i<r.length;i++){const s=r[i];t.getComponent(s)||(console.warn(`Component ${s.name} is required by Component ${n.constructor.name} on GameObject ${t.name}`),t.removeComponent(n),e=!0)}}e&&this.checkComponentRequirements(t)}build(t){return this.registerTransform(t),this.chackComponentRequirementsRecursive(),this.componentInitialize(),this._gameObject}registerTransform(t){this._gameObject.transform.parent=t;const e=this._children;for(let t=0;t<e.length;t++)e[t].registerTransform(this._gameObject.transform)}chackComponentRequirementsRecursive(){this.checkComponentRequirements(this._gameObject);const t=this._children;for(let e=0;e<t.length;e++)t[e].chackComponentRequirementsRecursive()}componentInitialize(){const t=this._componentInitializeFuncList;for(let e=0;e<t.length;e++)t[e]();const e=this._children;for(let t=0;t<e.length;t++)e[t].componentInitialize();this._gameObject._initialized=!0}processEvent(){El.processEventByGroup([this],this._gameObject.engine.sceneProcessor)}static processEventByGroup(t,e){const i=[];for(let e=0;e<t.length;e++)i.push(...t[e]._gameObject.getComponentsInChildren());for(let t=0;t<i.length;t++){const e=i[t];e.gameObject.activeInHierarchy&&e.enabled&&e._engine_internal_componentEventContainer.tryCallAwake()}for(let t=0;t<i.length;t++){const e=i[t];e._engine_internal_destroyed||e.gameObject.activeInHierarchy&&e.enabled&&(e._engine_internal_componentEventContainer.tryRegisterOnEnable(),e._engine_internal_componentEventContainer.tryRegisterStart(),e._engine_internal_componentEventContainer.tryRegisterUpdate())}e.tryStartProcessSyncedEvent()}}class Rl{constructor(t){this._sceneProcessor=t,this._children=[]}withChild(t){return this._children.push(t),this}build(){for(let t=0;t<this._children.length;t++)this._children[t].build(null);El.processEventByGroup(this._children,this._sceneProcessor)}}class Ll{}class Gl extends Ll{get instance(){return Gl._instance}}Gl._instance=new Gl;class Fl extends Ll{constructor(t){super(),this._seconds=t}get seconds(){return this._seconds}}class kl extends Ll{constructor(t){super(),this._predicate=t}get predicate(){return this._predicate}}class zl extends Ll{constructor(t){super(),this._predicate=t}get predicate(){return this._predicate}}class Ol{constructor(t,e,i){this._component=t,this._elapsedTime=0,this._coroutineIterator=e,this._currentYieldInstruction=null,this._isCurrenYieldInstructionExist=!1,this._onFinish=i,this.fatchNextInstruction()}get component(){return this._component}get elapsedTime(){return this._elapsedTime}set elapsedTime(t){this._elapsedTime=t}get currentYieldInstruction(){return this._currentYieldInstruction}get currentYieldInstructionExist(){return this._isCurrenYieldInstructionExist}fatchNextInstruction(){var t;const e=this._coroutineIterator.next();return e.done?(this._currentYieldInstruction=null,this._isCurrenYieldInstructionExist=!1,null===(t=this._onFinish)||void 0===t||t.call(this),this._onFinish=null,null):(this._currentYieldInstruction=e.value,this._isCurrenYieldInstructionExist=!0,this._currentYieldInstruction)}}class Nl{constructor(t){this.disallowMultipleComponent=!1,this.requiredComponents=[],this.executionOrder=0,this._runningCoroutines=[],this._engine_internal_destroyed=!1,this._enabled=!0,this._gameObject=t,this._instanceId=t.engine.instantiater.generateId(),this._engine_internal_componentEventContainer=new Dl(this)}engine_internal_constructAfterProcess(){Object.defineProperties(this,{disallowMultipleComponent:{configurable:!1,writable:!1},requiredComponents:{configurable:!1,writable:!1},executionOrder:{configurable:!1,writable:!1}})}startCorutine(t){const e=new Ol(this,t,(()=>{const t=this._runningCoroutines.indexOf(e);t>=0&&this._runningCoroutines.splice(t,1)}));return this._runningCoroutines.push(e),this.engine.coroutineProcessor.addCoroutine(e),e}stopAllCoroutines(){this._runningCoroutines.forEach((t=>{this.stopCoroutine(t)})),this._runningCoroutines.length=0}stopCoroutine(t){if(t.component!==this)throw new Error("Coroutine is not owned by this component");this.engine.coroutineProcessor.removeCoroutine(t);const e=this._runningCoroutines.indexOf(t);e>=0&&this._runningCoroutines.splice(e,1)}get enabled(){return this._enabled}set enabled(t){this._enabled!==t&&(this._enabled=t,this._gameObject.initialized&&this._gameObject.activeInHierarchy&&(this._enabled?(this._engine_internal_componentEventContainer.tryRegisterOnEnable(),this._engine_internal_componentEventContainer.tryRegisterStart(),this._engine_internal_componentEventContainer.tryRegisterUpdate(),this.engine.sceneProcessor.tryStartProcessSyncedEvent()):(this._engine_internal_componentEventContainer.tryRegisterOnDisable(),this._engine_internal_componentEventContainer.tryUnregisterStart(),this._engine_internal_componentEventContainer.tryUnregisterUpdate(),this.engine.sceneProcessor.tryStartProcessSyncedEvent())))}get gameObject(){return this._gameObject}get transform(){return this._gameObject.transform}get engine(){return this._gameObject.engine}get instanceId(){return this._instanceId}get initialized(){return this._gameObject.initialized}destroy(){this._engine_internal_destroyed||(this.enabled&&this.gameObject.activeInHierarchy&&(this._engine_internal_componentEventContainer.tryRegisterOnDisable(),this._engine_internal_componentEventContainer.tryUnregisterStart(),this._engine_internal_componentEventContainer.tryUnregisterUpdate()),this.stopAllCoroutines(),this._engine_internal_componentEventContainer.tryRegisterOnDestroy(),this._engine_internal_destroyed=!0,this.engine.sceneProcessor.tryStartProcessSyncedEvent(),this.engine.sceneProcessor.addRemoveComponent(this))}}class Ul{constructor(t=null){this.ref=t}}class Wl{constructor(t){this._onKeyDownDelegates=[],this._onKeyUpDelegates=[],this._onWheelDelegates=[],this._onPointerDownDelegates=[],this._onPointerUpDelegates=[],this._onPointerEnterDelegates=[],this._onPointerLeaveDelegates=[],this._onPointerMoveDelegates=[],this._touchMoveOccured=!1,this._onTouchStartFunc=null,this._lastMouseDownEvent=null,this._lastMouseEnterEvent=null,this._handleKeyDownBind=this.handleKeyDown.bind(this),this._handleKeyUpBind=this.handleKeyUp.bind(this),this._handleWheelBind=this.handleWheel.bind(this),this._handleMouseDownBind=this.handleMouseDown.bind(this),this._handleMouseUpBind=this.handleMouseUp.bind(this),this._handleMouseEnterBind=this.handleMouseEnter.bind(this),this._handleMouseLeaveBind=this.handleMouseLeave.bind(this),this._handleMouseMoveBind=this.handleMouseMove.bind(this),this._handleTouchStartBind=this.handleTouchStart.bind(this),this._handleTouchEndBind=this.handleTouchEnd.bind(this),this._handleTouchMoveBind=this.handleTouchMove.bind(this),this._handleTouchCancelBind=this.handleTouchCancel.bind(this),this._map=new Map,this._isDisposed=!1,this._renderTargetDom=t}get map(){return this._map}dispose(){this.stopHandleEvents(),this._isDisposed=!0}startHandleEvents(){if(this._isDisposed)throw new Error("InputHandler is disposed.");window.addEventListener("keydown",this._handleKeyDownBind),window.addEventListener("keyup",this._handleKeyUpBind),window.addEventListener("wheel",this._handleWheelBind),this._renderTargetDom.addEventListener("mousedown",this._handleMouseDownBind),this._renderTargetDom.addEventListener("mouseup",this._handleMouseUpBind),this._renderTargetDom.addEventListener("mouseenter",this._handleMouseEnterBind),this._renderTargetDom.addEventListener("mouseleave",this._handleMouseLeaveBind),this._renderTargetDom.addEventListener("mousemove",this._handleMouseMoveBind),this._renderTargetDom.addEventListener("touchstart",this._handleTouchStartBind),this._renderTargetDom.addEventListener("touchend",this._handleTouchEndBind),this._renderTargetDom.addEventListener("touchmove",this._handleTouchMoveBind),this._renderTargetDom.addEventListener("touchcancel",this._handleTouchCancelBind)}stopHandleEvents(){this._lastMouseDownEvent&&this.handleMouseUp(this._lastMouseDownEvent),this._lastMouseEnterEvent&&this.handleMouseLeave(this._lastMouseEnterEvent),this._map.clear(),window.removeEventListener("keydown",this._handleKeyDownBind),window.removeEventListener("keyup",this._handleKeyUpBind),window.removeEventListener("wheel",this._handleWheelBind),this._renderTargetDom.removeEventListener("mousedown",this._handleMouseDownBind),this._renderTargetDom.removeEventListener("mouseup",this._handleMouseUpBind),this._renderTargetDom.removeEventListener("mouseenter",this._handleMouseEnterBind),this._renderTargetDom.removeEventListener("mouseleave",this._handleMouseLeaveBind),this._renderTargetDom.removeEventListener("mousemove",this._handleMouseMoveBind),this._renderTargetDom.removeEventListener("touchstart",this._handleTouchStartBind),this._renderTargetDom.removeEventListener("touchend",this._handleTouchEndBind),this._renderTargetDom.removeEventListener("touchmove",this._handleTouchMoveBind),this._renderTargetDom.removeEventListener("touchcancel",this._handleTouchCancelBind)}simulateMouseEvent(t,e){const i=new MouseEvent(t,{bubbles:!0,cancelable:!0,view:window,detail:1,screenX:e.screenX,screenY:e.screenY,clientX:e.clientX,clientY:e.clientY,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,button:0,relatedTarget:null});e.target.dispatchEvent(i)}handleKeyDown(t){this._map.set(t.key,!0),this._onKeyDownDelegates.forEach((e=>e(t)))}handleKeyUp(t){this._map.set(t.key,!1),this._onKeyUpDelegates.forEach((e=>e(t)))}handleWheel(t){this._onWheelDelegates.forEach((e=>e(t)))}handleMouseDown(t){this._lastMouseDownEvent=t,this._onPointerDownDelegates.forEach((e=>e(t)))}handleMouseUp(t){this._lastMouseDownEvent=null,this._onPointerUpDelegates.forEach((e=>e(t)))}handleMouseEnter(t){this._lastMouseEnterEvent=t,this._onPointerEnterDelegates.forEach((e=>e(t)))}handleMouseLeave(t){this._lastMouseEnterEvent=null,this._onPointerLeaveDelegates.forEach((e=>e(t)))}handleMouseMove(t){this._lastMouseDownEvent=t,this._onPointerMoveDelegates.forEach((e=>e(t)))}handleTouchStart(t){this._onTouchStartFunc=()=>{this.simulateMouseEvent("mouseenter",t.touches[0]),this.simulateMouseEvent("mousedown",t.touches[0])}}handleTouchEnd(t){this._touchMoveOccured&&(this._touchMoveOccured=!1,this.simulateMouseEvent("mouseup",t.changedTouches[0]),this.simulateMouseEvent("mouseleave",t.changedTouches[0]))}handleTouchMove(t){this._onTouchStartFunc&&(this._onTouchStartFunc(),this._onTouchStartFunc=null),this.simulateMouseEvent("mousemove",t.touches[0]),this._touchMoveOccured=!0}handleTouchCancel(t){this._touchMoveOccured&&(this._touchMoveOccured=!1,this.simulateMouseEvent("mouseleave",t.changedTouches[0]))}addOnKeyDownEventListener(t){this._onKeyDownDelegates.push(t)}addOnKeyUpEventListener(t){this._onKeyUpDelegates.push(t)}addOnWheelEventListener(t){this._onWheelDelegates.push(t)}addOnPointerDownEventListener(t){this._onPointerDownDelegates.push(t)}addOnPointerUpEventListener(t){this._onPointerUpDelegates.push(t)}addOnPointerEnterEventListener(t){this._onPointerEnterDelegates.push(t)}addOnPointerLeaveEventListener(t){this._onPointerLeaveDelegates.push(t)}addOnPointerMoveEventListener(t){this._onPointerMoveDelegates.push(t)}removeOnKeyDownEventListener(t){const e=this._onKeyDownDelegates.indexOf(t);-1!==e&&this._onKeyDownDelegates.splice(e,1)}removeOnKeyUpEventListener(t){const e=this._onKeyUpDelegates.indexOf(t);-1!==e&&this._onKeyUpDelegates.splice(e,1)}removeOnWheelEventListener(t){const e=this._onWheelDelegates.indexOf(t);-1!==e&&this._onWheelDelegates.splice(e,1)}removeOnPointerDownEventListener(t){const e=this._onPointerDownDelegates.indexOf(t);-1!==e&&this._onPointerDownDelegates.splice(e,1)}removeOnPointerUpEventListener(t){const e=this._onPointerUpDelegates.indexOf(t);-1!==e&&this._onPointerUpDelegates.splice(e,1)}removeOnPointerEnterEventListener(t){const e=this._onPointerEnterDelegates.indexOf(t);-1!==e&&this._onPointerEnterDelegates.splice(e,1)}removeOnPointerLeaveEventListener(t){const e=this._onPointerLeaveDelegates.indexOf(t);-1!==e&&this._onPointerLeaveDelegates.splice(e,1)}removeOnPointerMoveEventListener(t){const e=this._onPointerMoveDelegates.indexOf(t);-1!==e&&this._onPointerMoveDelegates.splice(e,1)}}class jl{constructor(t){this._instanceNextId=0,this._eventInstanceNextId=0,this._engineGlobalObject=t}generateId(){const t=this._instanceNextId;return this._instanceNextId+=1,t}generateEventId(){const t=this._eventInstanceNextId;return this._eventInstanceNextId+=1,t}createGameObject(t,e,i,s){const n=new Il(this._engineGlobalObject,t),r=n.transform;return e&&r.localPosition.copy(e),i&&r.localRotation.copy(i),s&&r.localScale.copy(s),n}buildGameObject(t,e,i,s){return new El(this._engineGlobalObject,t,e,i,s)}buildPrefab(t,e,i,s,n){return new e(this._engineGlobalObject,t,i,s,n)}}class Hl{constructor(t,e,i,s,n,r,o,a,l,h){this._scene=t,this._cameraContainer=e,this._time=i,this._gameState=s,this._screen=n,this._sceneProcessor=r,this._coroutineProcessor=o,this._transformMatrixProcessor=a,this._physics2DProcessor=l,this._inputHandler=new Wl(h),this._instantiater=new jl(this)}dispose(){this._inputHandler.dispose()}get scene(){return this._scene}get cameraContainer(){return this._cameraContainer}get screen(){return this._screen}get input(){return this._inputHandler}get time(){return this._time}get physics(){throw new Error("not implemented")}get gameState(){return this._gameState}get instantiater(){return this._instantiater}get sceneProcessor(){return this._sceneProcessor}get coroutineProcessor(){return this._coroutineProcessor}get transformMatrixProcessor(){return this._transformMatrixProcessor}get physics2DProcessor(){return this._physics2DProcessor}}class ql{constructor(t){this._camera=null,this._currentCameraPriority=Number.MIN_SAFE_INTEGER,this._cameraList=[],this._onChangeBackgroundColor=t}get camera(){return this._camera}get currentCameraPriority(){return this._currentCameraPriority}addCamera(t,e){this._cameraList.push({camera:t,info:e}),this._cameraList.sort(((t,e)=>t.info.priority-e.info.priority)),this.setCamera()}removeCamera(t){this._cameraList=this._cameraList.filter((e=>e.camera!==t)),this.setCamera()}changeCameraPriority(t,e){const i=this._cameraList.findIndex((e=>e.camera===t));-1!==i&&(this._cameraList[i].info.priority=e,this._cameraList.sort(((t,e)=>t.info.priority-e.info.priority)),this.setCamera())}changeCameraBackgroundColor(t,e){const i=this._cameraList.findIndex((e=>e.camera===t));-1!==i&&(this._cameraList[i].info.backgroundColor=e),this._camera===t&&this._onChangeBackgroundColor(e)}setCamera(){if(0===this._cameraList.length)return void(this._camera=null);const t=this._cameraList[0].camera;this._camera=t,this._currentCameraPriority=this._cameraList[0].info.priority,this._onChangeBackgroundColor(this._cameraList[0].info.backgroundColor)}}class Xl{constructor(t){this._gameStateKind=t}get kind(){return this._gameStateKind}set kind(t){this._gameStateKind=t}}!function(t){t[t.WaitingForStart=0]="WaitingForStart",t[t.Initializing=1]="Initializing",t[t.Running=2]="Running",t[t.Stopped=3]="Stopped",t[t.Finalizing=4]="Finalizing",t[t.Finalized=5]="Finalized"}(Ml||(Ml={}));var Jl=function(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.freeze((function(t){var e=this;void 0===t&&(t=[]);var i=0,s=[];this.size=function(){return i},this.empty=function(){return 0===i},this.clear=function(){i=0,s.length=0},this.front=function(){if(!this.empty())return s[0]},this.back=function(){if(!this.empty())return s[i-1]},this.forEach=function(t){s.forEach(t)},this.getElementByPos=function(t){if(t<0||t>=i)throw new Error("pos must more than 0 and less than vector's size");return s[t]},this.eraseElementByPos=function(t){if(t<0||t>=i)throw new Error("pos must more than 0 and less than vector's size");for(var e=t;e<i-1;++e)s[e]=s[e+1];this.popBack()},this.eraseElementByValue=function(t){var e=[];this.forEach((function(i){i!==t&&e.push(i)})),e.forEach((function(t,e){s[e]=t}));for(var n=e.length;i>n;)this.popBack()},this.pushBack=function(t){s.push(t),++i},this.popBack=function(){s.pop(),i>0&&--i},this.setElementByPos=function(t,e){if(t<0||t>=i)throw new Error("pos must more than 0 and less than vector's size");s[t]=e},this.insert=function(t,e,n){if(void 0===n&&(n=1),t<0||t>i)throw new Error("pos must more than 0 and less than or equal to vector's size");s.splice.apply(s,function(t,e,i){if(i||2===arguments.length)for(var s,n=0,r=e.length;n<r;n++)!s&&n in e||(s||(s=Array.prototype.slice.call(e,0,n)),s[n]=e[n]);return t.concat(s||Array.prototype.slice.call(e))}([t,0],function(t,e){var i="function"==typeof Symbol&&t[Symbol.iterator];if(!i)return t;var s,n,r=i.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(s=r.next()).done;)o.push(s.value)}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=r.return)&&i.call(r)}finally{if(n)throw n.error}}return o}(new Array(n).fill(e)),!1)),i+=n},this.find=function(t){return s.includes(t)},this.reverse=function(){s.reverse()},this.unique=function(){var t,e=[];this.forEach((function(i,s){0!==s&&i===t||(e.push(i),t=i)})),e.forEach((function(t,e){s[e]=t}));for(var n=e.length;i>n;)this.popBack()},this.sort=function(t){s.sort(t)},this[Symbol.iterator]=function(){return function(){return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(t){switch(t.label){case 0:return[5,Jl(s)];case 1:return[2,t.sent()]}}))}()},t.forEach((function(t){return e.pushBack(t)})),Object.freeze(this)})),Object.freeze((function(t){var e=this;void 0===t&&(t=[]);var i=0,s=[];this.size=function(){return i},this.empty=function(){return 0===i},this.clear=function(){i=0,s.length=0},this.push=function(t){s.push(t),++i},this.pop=function(){s.pop(),i>0&&--i},this.top=function(){return s[i-1]},t.forEach((function(t){return e.push(t)})),Object.freeze(this)}));var Zl=function(t){this.value=void 0,this.pre=void 0,this.next=void 0,this.value=t};function Yl(t){var e=this;void 0===t&&(t=[]);var i=0,s=void 0,n=void 0;this.size=function(){return i},this.empty=function(){return 0===i},this.clear=function(){s=n=void 0,i=0},this.front=function(){return null==s?void 0:s.value},this.back=function(){return null==n?void 0:n.value},this.forEach=function(t){for(var e=s,i=0;e;){if(void 0===e.value)throw new Error("unknown error");t(e.value,i++),e=e.next}},this.getElementByPos=function(t){if(t<0||t>=i)throw new Error("pos must more then 0 and less then the list length");for(var e=s;t--&&e;)e=e.next;if(!e||void 0===e.value)throw new Error("unknown error");return e.value},this.eraseElementByPos=function(t){if(t<0||t>=i)throw new Error("erase pos must more then 0 and less then the list length");if(0===t)this.popFront();else if(t===i-1)this.popBack();else{for(var e=s;t--;){if(!(null==e?void 0:e.next))throw new Error("unknown error");e=e.next}if(!e||!e.pre||!e.next)throw new Error("unknown error");var n=e.pre,r=e.next;r.pre=n,n.next=r,i>0&&--i}},this.eraseElementByValue=function(t){for(;s&&s.value===t;)this.popFront();for(;n&&n.value===t;)this.popBack();if(s)for(var e=s;e;){if(e.value===t){var r=e.pre,o=e.next;o&&(o.pre=r),r&&(r.next=o),i>0&&--i}e=e.next}},this.pushBack=function(t){if(null==t)throw new Error("you can't push null or undefined here");++i;var e=new Zl(t);n?(n.next=e,e.pre=n,n=e):s=n=e},this.popBack=function(){n&&(i>0&&--i,n&&(s===n?s=n=void 0:(n=n.pre)&&(n.next=void 0)))},this.setElementByPos=function(t,e){if(null==e)throw new Error("you can't set null or undefined here");if(t<0||t>=i)throw new Error("pos must more then 0 and less then the list length");for(var n=s;t--;){if(!n)throw new Error("unknown error");n=n.next}n&&(n.value=e)},this.insert=function(t,e,n){if(void 0===n&&(n=1),null==e)throw new Error("you can't insert null or undefined here");if(t<0||t>i)throw new Error("insert pos must more then 0 and less then or equal to the list length");if(n<0)throw new Error("insert size must more than 0");if(0===t)for(;n--;)this.pushFront(e);else if(t===i)for(;n--;)this.pushBack(e);else{for(var r=s,o=1;o<t;++o){if(!(null==r?void 0:r.next))throw new Error("unknown error");r=null==r?void 0:r.next}if(!r)throw new Error("unknown error");var a=r.next;for(i+=n;n--;)r.next=new Zl(e),r.next.pre=r,r=r.next;r.next=a,a&&(a.pre=r)}},this.find=function(t){for(var e=s;e;){if(e.value===t)return!0;e=e.next}return!1},this.reverse=function(){for(var t=s,e=n,r=0;t&&e&&2*r<i;){var o=t.value;t.value=e.value,e.value=o,t=t.next,e=e.pre,++r}},this.unique=function(){for(var t=s;t;){for(var e=t;e&&e.next&&e.value===e.next.value;)e=e.next,i>0&&--i;t.next=e.next,t.next&&(t.next.pre=t),t=t.next}},this.sort=function(t){var e=[];this.forEach((function(t){e.push(t)})),e.sort(t);var i=s;e.forEach((function(t){i&&(i.value=t,i=i.next)}))},this.pushFront=function(t){if(null==t)throw new Error("you can't push null or undefined here");++i;var e=new Zl(t);s?(e.next=s,s.pre=e,s=e):s=n=e},this.popFront=function(){s&&(i>0&&--i,s&&(s===n?s=n=void 0:(s=s.next)&&(s.pre=void 0)))},this.merge=function(t){var e=this,r=s;t.forEach((function(t){for(;r&&void 0!==r.value&&r.value<=t;)r=r.next;if(void 0===r)e.pushBack(t),r=n;else if(r===s)e.pushFront(t),r=s;else{++i;var o=r.pre;o&&(o.next=new Zl(t),o.next.pre=o,o.next.next=r,r&&(r.pre=o.next))}}))},this[Symbol.iterator]=function(){return function(){var t;return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(e){switch(e.label){case 0:t=s,e.label=1;case 1:if(void 0===t)return[3,3];if(!t.value)throw new Error("unknown error");return[4,t.value];case 2:return e.sent(),t=t.next,[3,1];case 3:return[2]}}))}()},t.forEach((function(t){return e.pushBack(t)})),Object.freeze(this)}Object.freeze(Yl);const Ql=Yl;Object.freeze((function(t){void 0===t&&(t=[]);var e=new Ql(t);this.size=function(){return e.size()},this.empty=function(){return e.empty()},this.clear=function(){e.clear()},this.push=function(t){e.pushBack(t)},this.pop=function(){e.popFront()},this.front=function(){return e.front()},Object.freeze(this)}));function Kl(t){var e=this;void 0===t&&(t=[]);var i=[],s=0,n=0,r=0,o=0,a=0,l=0;this.size=function(){return l},this.empty=function(){return 0===l},this.clear=function(){s=r=n=o=a=l=0,c.call(this,Kl.bucketSize),l=0},this.front=function(){return i[s][n]},this.back=function(){return i[r][o]},this.forEach=function(t){if(!this.empty()){var e=0;if(s!==r){for(l=n;l<Kl.bucketSize;++l)t(i[s][l],e++);for(l=s+1;l<r;++l)for(var a=0;a<Kl.bucketSize;++a)t(i[l][a],e++);for(l=0;l<=o;++l)t(i[r][l],e++)}else for(var l=n;l<=o;++l)t(i[s][l],e++)}};var h=function(t){var e=s*Kl.bucketSize+n,i=e+t,a=r*Kl.bucketSize+o;if(i<e||i>a)throw new Error("pos should more than 0 and less than queue's size");return{curNodeBucketIndex:Math.floor(i/Kl.bucketSize),curNodePointerIndex:i%Kl.bucketSize}};this.getElementByPos=function(t){var e=h(t),s=e.curNodeBucketIndex,n=e.curNodePointerIndex;return i[s][n]},this.eraseElementByPos=function(t){var e=this;if(t<0||t>l)throw new Error("pos should more than 0 and less than queue's size");if(0===t)this.popFront();else if(t===this.size())this.popBack();else{for(var i=[],s=t+1;s<l;++s)i.push(this.getElementByPos(s));this.cut(t),this.popBack(),i.forEach((function(t){return e.pushBack(t)}))}},this.eraseElementByValue=function(t){if(!this.empty()){var e=[];this.forEach((function(i){i!==t&&e.push(i)}));for(var i=e.length,s=0;s<i;++s)this.setElementByPos(s,e[s]);this.cut(i-1)}};var c=function(t){for(var e=[],h=t*Kl.sigma,c=Math.max(Math.ceil(h/Kl.bucketSize),2),m=0;m<c;++m)e.push(new Array(Kl.bucketSize));var u=Math.ceil(t/Kl.bucketSize),_=Math.floor(c/2)-Math.floor(u/2),d=_,p=0;if(this.size())for(m=0;m<u;++m){for(var f=0;f<Kl.bucketSize;++f)if(e[_+m][f]=this.front(),this.popFront(),this.empty()){d=_+m,p=f;break}if(this.empty())break}i=e,s=_,n=0,r=d,o=p,a=c,l=t};this.pushBack=function(t){this.empty()||(r===a-1&&o===Kl.bucketSize-1&&c.call(this,this.size()),o<Kl.bucketSize-1?++o:r<a-1&&(++r,o=0)),++l,i[r][o]=t},this.popBack=function(){this.empty()||(1!==this.size()&&(o>0?--o:s<r&&(--r,o=Kl.bucketSize-1)),l>0&&--l)},this.setElementByPos=function(t,e){var s=h(t),n=s.curNodeBucketIndex,r=s.curNodePointerIndex;i[n][r]=e},this.insert=function(t,e,i){var s=this;if(void 0===i&&(i=1),0===t)for(;i--;)this.pushFront(e);else if(t===this.size())for(;i--;)this.pushBack(e);else{for(var n=[],r=t;r<l;++r)n.push(this.getElementByPos(r));for(this.cut(t-1),r=0;r<i;++r)this.pushBack(e);n.forEach((function(t){return s.pushBack(t)}))}},this.find=function(t){if(s===r){for(var e=n;e<=o;++e)if(i[s][e]===t)return!0;return!1}for(e=n;e<Kl.bucketSize;++e)if(i[s][e]===t)return!0;for(e=s+1;e<r;++e)for(var a=0;a<Kl.bucketSize;++a)if(i[e][a]===t)return!0;for(e=0;e<=o;++e)if(i[r][e]===t)return!0;return!1},this.reverse=function(){for(var t=0,e=l-1;t<e;){var i=this.getElementByPos(t);this.setElementByPos(t,this.getElementByPos(e)),this.setElementByPos(e,i),++t,--e}},this.unique=function(){if(!this.empty()){var t=[],e=this.front();this.forEach((function(i,s){0!==s&&i===e||(t.push(i),e=i)}));for(var i=0;i<l;++i)this.setElementByPos(i,t[i]);this.cut(t.length-1)}},this.sort=function(t){var e=[];this.forEach((function(t){e.push(t)})),e.sort(t);for(var i=0;i<l;++i)this.setElementByPos(i,e[i])},this.pushFront=function(t){this.empty()||(0===s&&0===n&&c.call(this,this.size()),n>0?--n:s>0&&(--s,n=Kl.bucketSize-1)),++l,i[s][n]=t},this.popFront=function(){this.empty()||(1!==this.size()&&(n<Kl.bucketSize-1?++n:s<r&&(++s,n=0)),l>0&&--l)},this.shrinkToFit=function(){var t=this,e=[];this.forEach((function(t){e.push(t)}));var s=e.length;i=[];for(var n=Math.ceil(s/Kl.bucketSize),r=0;r<n;++r)i.push(new Array(Kl.bucketSize));this.clear(),e.forEach((function(e){return t.pushBack(e)}))},this.cut=function(t){if(t<0)this.clear();else{var e=h(t),i=e.curNodeBucketIndex,s=e.curNodePointerIndex;r=i,o=s,l=t+1}},this[Symbol.iterator]=function(){return function(){var t,e;return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(a){switch(a.label){case 0:if(0===l)return[2];if(s!==r)return[3,5];e=n,a.label=1;case 1:return e<=o?[4,i[s][e]]:[3,4];case 2:a.sent(),a.label=3;case 3:return++e,[3,1];case 4:return[2];case 5:e=n,a.label=6;case 6:return e<Kl.bucketSize?[4,i[s][e]]:[3,9];case 7:a.sent(),a.label=8;case 8:return++e,[3,6];case 9:e=s+1,a.label=10;case 10:if(!(e<r))return[3,15];t=0,a.label=11;case 11:return t<Kl.bucketSize?[4,i[e][t]]:[3,14];case 12:a.sent(),a.label=13;case 13:return++t,[3,11];case 14:return++e,[3,10];case 15:e=0,a.label=16;case 16:return e<=o?[4,i[r][e]]:[3,19];case 17:a.sent(),a.label=18;case 18:return++e,[3,16];case 19:return[2]}}))}()},function(){var n=Kl.bucketSize;t.size?n=t.size():t.length&&(n=t.length);var o=n*Kl.sigma;a=Math.ceil(o/Kl.bucketSize),a=Math.max(a,3);for(var l=0;l<a;++l)i.push(new Array(Kl.bucketSize));var h=Math.ceil(n/Kl.bucketSize);s=Math.floor(a/2)-Math.floor(h/2),r=s,t.forEach((function(t){return e.pushBack(t)}))}(),Object.freeze(this)}Kl.sigma=3,Kl.bucketSize=5e3,Object.freeze(Kl),Object.freeze((function(t,e){void 0===t&&(t=[]),e=e||function(t,e){return t>e?-1:t<e?1:0};var i=[];t.forEach((function(t){return i.push(t)}));var s=i.length,n=function(t,e){if(t<0||t>=s)throw new Error("unknown error");if(e<0||e>=s)throw new Error("unknown error");var n=i[t];i[t]=i[e],i[e]=n},r=function(t){if(t<0||t>=s)throw new Error("unknown error");var r=2*t+1,o=2*t+2;r<s&&e(i[t],i[r])>0&&n(t,r),o<s&&e(i[t],i[o])>0&&n(t,o)};!function(){for(var t=Math.floor((s-1)/2);t>=0;--t)for(var r=t,o=2*r+1;o<s;){var a=o+1,l=o;if(a<s&&e(i[o],i[a])>0&&(l=a),e(i[r],i[l])<=0)break;n(r,l),o=2*(r=l)+1}}(),this.size=function(){return s},this.empty=function(){return 0===s},this.clear=function(){s=0,i.length=0},this.push=function(t){if(i.push(t),1!=++s)for(var n=s-1;n>0;){var o=Math.floor((n-1)/2);if(e(i[o],t)<=0)break;r(o),n=o}},this.pop=function(){if(!this.empty())if(1!==this.size()){var t=i[s-1];--s;for(var n=0;n<this.size();){var r=2*n+1,o=2*n+2;if(r>=this.size())break;var a=r;if(o<this.size()&&e(i[r],i[o])>0&&(a=o),e(i[a],t)>=0)break;i[n]=i[a],n=a}i[n]=t}else--s},this.top=function(){return i[0]},Object.freeze(this)}));var $l=function(){function t(t,e){this.color=!0,this.key=void 0,this.value=void 0,this.parent=void 0,this.brother=void 0,this.leftChild=void 0,this.rightChild=void 0,this.key=t,this.value=e}return t.prototype.rotateLeft=function(){var t=this.parent,e=this.brother,i=this.leftChild,s=this.rightChild;if(!s)throw new Error("unknown error");var n=s.leftChild,r=s.rightChild;return t&&(t.leftChild===this?t.leftChild=s:t.rightChild===this&&(t.rightChild=s)),s.parent=t,s.brother=e,s.leftChild=this,s.rightChild=r,e&&(e.brother=s),this.parent=s,this.brother=r,this.leftChild=i,this.rightChild=n,r&&(r.parent=s,r.brother=this),i&&(i.parent=this,i.brother=n),n&&(n.parent=this,n.brother=i),s},t.prototype.rotateRight=function(){var t=this.parent,e=this.brother,i=this.leftChild;if(!i)throw new Error("unknown error");var s=this.rightChild,n=i.leftChild,r=i.rightChild;return t&&(t.leftChild===this?t.leftChild=i:t.rightChild===this&&(t.rightChild=i)),i.parent=t,i.brother=e,i.leftChild=n,i.rightChild=this,e&&(e.brother=i),n&&(n.parent=i,n.brother=this),this.parent=i,this.brother=n,this.leftChild=r,this.rightChild=s,r&&(r.parent=this,r.brother=s),s&&(s.parent=this,s.brother=r),i},t.prototype.remove=function(){if(this.leftChild||this.rightChild)throw new Error("can only remove leaf node");this.parent&&(this===this.parent.leftChild?this.parent.leftChild=void 0:this===this.parent.rightChild&&(this.parent.rightChild=void 0)),this.brother&&(this.brother.brother=void 0),this.key=void 0,this.value=void 0,this.parent=void 0,this.brother=void 0},t.TreeNodeColorType={red:!0,black:!1},t}();Object.freeze($l);const th=$l;var eh=function(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};function ih(t,e){var i=this;void 0===t&&(t=[]),e=e||function(t,e){return t<e?-1:t>e?1:0};var s=0,n=new th;n.color=th.TreeNodeColorType.black,this.size=function(){return s},this.empty=function(){return 0===s},this.clear=function(){s=0,n.key=void 0,n.leftChild=n.rightChild=n.brother=n.parent=void 0,n.color=th.TreeNodeColorType.black};var r=function(t){if(!t||void 0===t.key)throw new Error("unknown error");return t.leftChild?r(t.leftChild):t},o=function(t){if(!t||void 0===t.key)throw new Error("unknown error");return t.rightChild?o(t.rightChild):t};this.front=function(){if(!this.empty())return r(n).key},this.back=function(){if(!this.empty())return o(n).key},this.forEach=function(t){var e,i,s=0;try{for(var n=eh(this),r=n.next();!r.done;r=n.next())t(r.value,s++)}catch(t){e={error:t}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},this.getElementByPos=function(t){var e,i;if(t<0||t>=this.size())throw new Error("pos must more than 0 and less than set's size");var s=0;try{for(var n=eh(this),r=n.next();!r.done;r=n.next()){var o=r.value;if(s===t)return o;++s}}catch(t){e={error:t}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}throw new Error("unknown error")};var a=function(t){var e=t.parent;if(!e){if(t===n)return;throw new Error("unknown error")}if(t.color!==th.TreeNodeColorType.red){var i=t.brother;if(!i)throw new Error("unknown error");if(t===e.leftChild)if(i.color===th.TreeNodeColorType.red){i.color=th.TreeNodeColorType.black,e.color=th.TreeNodeColorType.red;var s=e.rotateLeft();n===e&&(n=s),a(t)}else i.color===th.TreeNodeColorType.black&&(i.rightChild&&i.rightChild.color===th.TreeNodeColorType.red?(i.color=e.color,e.color=th.TreeNodeColorType.black,i.rightChild&&(i.rightChild.color=th.TreeNodeColorType.black),s=e.rotateLeft(),n===e&&(n=s),t.color=th.TreeNodeColorType.black):i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||!i.leftChild||i.leftChild.color!==th.TreeNodeColorType.red?i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||(i.color=th.TreeNodeColorType.red,a(e)):(i.color=th.TreeNodeColorType.red,i.leftChild&&(i.leftChild.color=th.TreeNodeColorType.black),s=i.rotateRight(),n===i&&(n=s),a(t)));else t===e.rightChild&&(i.color===th.TreeNodeColorType.red?(i.color=th.TreeNodeColorType.black,e.color=th.TreeNodeColorType.red,s=e.rotateRight(),n===e&&(n=s),a(t)):i.color===th.TreeNodeColorType.black&&(i.leftChild&&i.leftChild.color===th.TreeNodeColorType.red?(i.color=e.color,e.color=th.TreeNodeColorType.black,i.leftChild&&(i.leftChild.color=th.TreeNodeColorType.black),s=e.rotateRight(),n===e&&(n=s),t.color=th.TreeNodeColorType.black):i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||!i.rightChild||i.rightChild.color!==th.TreeNodeColorType.red?i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||(i.color=th.TreeNodeColorType.red,a(e)):(i.color=th.TreeNodeColorType.red,i.rightChild&&(i.rightChild.color=th.TreeNodeColorType.black),s=i.rotateLeft(),n===i&&(n=s),a(t))))}else t.color=th.TreeNodeColorType.black},l=function(t){for(var e=t;e.leftChild||e.rightChild;){if(e.rightChild){e=r(e.rightChild);var i=t.key;t.key=e.key,e.key=i,t=e}e.leftChild&&(e=o(e.leftChild),i=t.key,t.key=e.key,e.key=i,t=e)}a(e),e&&e.remove(),--s,n.color=th.TreeNodeColorType.black},h=function(t,e){return!(!t||void 0===t.key)&&(!!h(t.leftChild,e)||!!e(t)||h(t.rightChild,e))};this.eraseElementByPos=function(t){if(t<0||t>=s)throw new Error("pos must more than 0 and less than set's size");var e=0;h(n,(function(i){return t===e?(l(i),!0):(++e,!1)}))},this.eraseElementByValue=function(t){if(!this.empty()){var i=u(n,t);void 0!==i&&void 0!==i.key&&0===e(i.key,t)&&l(i)}};var c=function(t,i){if(!t||void 0===t.key)throw new Error("unknown error");var s=e(i,t.key);return s<0?t.leftChild?c(t.leftChild,i):(t.leftChild=new th,t.leftChild.parent=t,t.leftChild.brother=t.rightChild,t.rightChild&&(t.rightChild.brother=t.leftChild),t.leftChild):s>0?t.rightChild?c(t.rightChild,i):(t.rightChild=new th,t.rightChild.parent=t,t.rightChild.brother=t.leftChild,t.leftChild&&(t.leftChild.brother=t.rightChild),t.rightChild):t},m=function(t){var e=t.parent;if(!e){if(t===n)return;throw new Error("unknown error")}if(e.color!==th.TreeNodeColorType.black&&e.color===th.TreeNodeColorType.red){var i=e.brother,s=e.parent;if(!s)throw new Error("unknown error");if(i&&i.color===th.TreeNodeColorType.red)i.color=e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red,m(s);else if(!i||i.color===th.TreeNodeColorType.black)if(e===s.leftChild)if(t===e.leftChild){e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red;var r=s.rotateRight();s===n&&(n=r)}else t===e.rightChild&&(r=e.rotateLeft(),s===n&&(n=r),m(e));else e===s.rightChild&&(t===e.leftChild?(r=e.rotateRight(),s===n&&(n=r),m(e)):t===e.rightChild&&(e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red,r=s.rotateLeft(),s===n&&(n=r)))}};this.insert=function(t){if(null==t)throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");if(this.empty())return++s,n.key=t,void(n.color=th.TreeNodeColorType.black);var i=c(n,t);void 0!==i.key&&0===e(i.key,t)||(++s,i.key=t,m(i),n.color=th.TreeNodeColorType.black)};var u=function(t,i){if(t&&void 0!==t.key){var s=e(i,t.key);return s<0?u(t.leftChild,i):s>0?u(t.rightChild,i):t}};this.find=function(t){var i=u(n,t);return void 0!==i&&void 0!==i.key&&0===e(i.key,t)};var _=function(t,i){if(t&&void 0!==t.key){var s=e(t.key,i);if(0===s)return t.key;if(s<0)return _(t.rightChild,i);var n=_(t.leftChild,i);return void 0!==n?n:t.key}};this.lowerBound=function(t){return _(n,t)};var d=function(t,i){if(t&&void 0!==t.key){if(e(t.key,i)<=0)return d(t.rightChild,i);var s=d(t.leftChild,i);return void 0!==s?s:t.key}};this.upperBound=function(t){return d(n,t)};var p=function(t,i){if(t&&void 0!==t.key){var s=e(t.key,i);if(0===s)return t.key;if(s>0)return p(t.leftChild,i);var n=p(t.rightChild,i);return void 0!==n?n:t.key}};this.reverseLowerBound=function(t){return p(n,t)};var f=function(t,i){if(t&&void 0!==t.key){if(e(t.key,i)>=0)return f(t.leftChild,i);var s=f(t.rightChild,i);return void 0!==s?s:t.key}};this.reverseUpperBound=function(t){return f(n,t)},this.union=function(t){var e=this;t.forEach((function(t){return e.insert(t)}))},this.getHeight=function(){if(this.empty())return 0;var t=function(e){return e?Math.max(t(e.leftChild),t(e.rightChild))+1:1};return t(n)};var y=function(t){return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(e){switch(e.label){case 0:return t&&void 0!==t.key?[5,eh(y(t.leftChild))]:[2];case 1:return e.sent(),[4,t.key];case 2:return e.sent(),[5,eh(y(t.rightChild))];case 3:return e.sent(),[2]}}))};this[Symbol.iterator]=function(){return y(n)},t.forEach((function(t){return i.insert(t)})),Object.freeze(this)}Object.freeze(ih);const sh=ih;var nh=function(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};function rh(t,e){var i=this;void 0===t&&(t=[]),e=e||function(t,e){return t<e?-1:t>e?1:0};var s=0,n=new th;n.color=th.TreeNodeColorType.black,this.size=function(){return s},this.empty=function(){return 0===s},this.clear=function(){s=0,n.key=n.value=void 0,n.leftChild=n.rightChild=n.brother=void 0};var r=function(t){if(!t||void 0===t.key)throw new Error("unknown error");return t.leftChild?r(t.leftChild):t},o=function(t){if(!t||void 0===t.key)throw new Error("unknown error");return t.rightChild?o(t.rightChild):t};this.front=function(){if(!this.empty()){var t=r(n);if(void 0===t.key||void 0===t.value)throw new Error("unknown error");return{key:t.key,value:t.value}}},this.back=function(){if(!this.empty()){var t=o(n);if(void 0===t.key||void 0===t.value)throw new Error("unknown error");return{key:t.key,value:t.value}}},this.forEach=function(t){var e,i,s=0;try{for(var n=nh(this),r=n.next();!r.done;r=n.next())t(r.value,s++)}catch(t){e={error:t}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}},this.getElementByPos=function(t){var e,i;if(t<0||t>=this.size())throw new Error("pos must more than 0 and less than set's size");var s=0;try{for(var n=nh(this),r=n.next();!r.done;r=n.next()){var o=r.value;if(s===t)return o;++s}}catch(t){e={error:t}}finally{try{r&&!r.done&&(i=n.return)&&i.call(n)}finally{if(e)throw e.error}}throw new Error("unknown Error")};var a=function(t,i){if(t&&void 0!==t.key&&void 0!==t.value){var s=e(t.key,i);return 0===s?{key:t.key,value:t.value}:s<0?a(t.rightChild,i):a(t.leftChild,i)||{key:t.key,value:t.value}}};this.lowerBound=function(t){return a(n,t)};var l=function(t,i){if(t&&void 0!==t.key&&void 0!==t.value)return e(t.key,i)<=0?l(t.rightChild,i):l(t.leftChild,i)||{key:t.key,value:t.value}};this.upperBound=function(t){return l(n,t)};var h=function(t,i){if(t&&void 0!==t.key&&void 0!==t.value){var s=e(t.key,i);return 0===s?{key:t.key,value:t.value}:s>0?h(t.leftChild,i):h(t.rightChild,i)||{key:t.key,value:t.value}}};this.reverseLowerBound=function(t){return h(n,t)};var c=function(t,i){if(t&&void 0!==t.key&&void 0!==t.value)return e(t.key,i)>=0?c(t.leftChild,i):c(t.rightChild,i)||{key:t.key,value:t.value}};this.reverseUpperBound=function(t){return c(n,t)};var m=function(t){var e=t.parent;if(!e){if(t===n)return;throw new Error("unknown error")}if(t.color!==th.TreeNodeColorType.red){var i=t.brother;if(!i)throw new Error("unknown error");if(t===e.leftChild)if(i.color===th.TreeNodeColorType.red){i.color=th.TreeNodeColorType.black,e.color=th.TreeNodeColorType.red;var s=e.rotateLeft();n===e&&(n=s),m(t)}else i.color===th.TreeNodeColorType.black&&(i.rightChild&&i.rightChild.color===th.TreeNodeColorType.red?(i.color=e.color,e.color=th.TreeNodeColorType.black,i.rightChild&&(i.rightChild.color=th.TreeNodeColorType.black),s=e.rotateLeft(),n===e&&(n=s),t.color=th.TreeNodeColorType.black):i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||!i.leftChild||i.leftChild.color!==th.TreeNodeColorType.red?i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||(i.color=th.TreeNodeColorType.red,m(e)):(i.color=th.TreeNodeColorType.red,i.leftChild&&(i.leftChild.color=th.TreeNodeColorType.black),s=i.rotateRight(),n===i&&(n=s),m(t)));else t===e.rightChild&&(i.color===th.TreeNodeColorType.red?(i.color=th.TreeNodeColorType.black,e.color=th.TreeNodeColorType.red,s=e.rotateRight(),n===e&&(n=s),m(t)):i.color===th.TreeNodeColorType.black&&(i.leftChild&&i.leftChild.color===th.TreeNodeColorType.red?(i.color=e.color,e.color=th.TreeNodeColorType.black,i.leftChild&&(i.leftChild.color=th.TreeNodeColorType.black),s=e.rotateRight(),n===e&&(n=s),t.color=th.TreeNodeColorType.black):i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||!i.rightChild||i.rightChild.color!==th.TreeNodeColorType.red?i.leftChild&&i.leftChild.color!==th.TreeNodeColorType.black||i.rightChild&&i.rightChild.color!==th.TreeNodeColorType.black||(i.color=th.TreeNodeColorType.red,m(e)):(i.color=th.TreeNodeColorType.red,i.rightChild&&(i.rightChild.color=th.TreeNodeColorType.black),s=i.rotateLeft(),n===i&&(n=s),m(t))))}else t.color=th.TreeNodeColorType.black},u=function(t){for(var e=t;e.leftChild||e.rightChild;){if(e.rightChild){e=r(e.rightChild);var i=t.key;t.key=e.key,e.key=i;var a=t.value;t.value=e.value,e.value=a,t=e}e.leftChild&&(e=o(e.leftChild),i=t.key,t.key=e.key,e.key=i,a=t.value,t.value=e.value,e.value=a,t=e)}m(e),e&&e.remove(),--s,n.color=th.TreeNodeColorType.black},_=function(t,e){return!(!t||void 0===t.key)&&(!!_(t.leftChild,e)||!!e(t)||_(t.rightChild,e))};this.eraseElementByPos=function(t){if(t<0||t>=s)throw new Error("pos must more than 0 and less than set's size");var e=0;_(n,(function(i){return t===e?(u(i),!0):(++e,!1)}))},this.eraseElementByKey=function(t){if(!this.empty()){var i=f(n,t);void 0!==i&&void 0!==i.key&&0===e(i.key,t)&&u(i)}};var d=function(t,i){if(!t||void 0===t.key)throw new Error("unknown error");var s=e(i,t.key);return s<0?t.leftChild?d(t.leftChild,i):(t.leftChild=new th,t.leftChild.parent=t,t.leftChild.brother=t.rightChild,t.rightChild&&(t.rightChild.brother=t.leftChild),t.leftChild):s>0?t.rightChild?d(t.rightChild,i):(t.rightChild=new th,t.rightChild.parent=t,t.rightChild.brother=t.leftChild,t.leftChild&&(t.leftChild.brother=t.rightChild),t.rightChild):t},p=function(t){var e=t.parent;if(!e){if(t===n)return;throw new Error("unknown error")}if(e.color!==th.TreeNodeColorType.black&&e.color===th.TreeNodeColorType.red){var i=e.brother,s=e.parent;if(!s)throw new Error("unknown error");if(i&&i.color===th.TreeNodeColorType.red)i.color=e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red,p(s);else if(!i||i.color===th.TreeNodeColorType.black)if(e===s.leftChild)if(t===e.leftChild){e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red;var r=s.rotateRight();s===n&&(n=r)}else t===e.rightChild&&(r=e.rotateLeft(),s===n&&(n=r),p(e));else e===s.rightChild&&(t===e.leftChild?(r=e.rotateRight(),s===n&&(n=r),p(e)):t===e.rightChild&&(e.color=th.TreeNodeColorType.black,s.color=th.TreeNodeColorType.red,r=s.rotateLeft(),s===n&&(n=r)))}};this.setElement=function(t,i){if(null==t)throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");if(null!=i){if(this.empty())return++s,n.key=t,n.value=i,void(n.color=th.TreeNodeColorType.black);var r=d(n,t);void 0===r.key||0!==e(r.key,t)?(++s,r.key=t,r.value=i,p(r),n.color=th.TreeNodeColorType.black):r.value=i}else this.eraseElementByKey(t)};var f=function(t,i){if(t&&void 0!==t.key){var s=e(i,t.key);return s<0?f(t.leftChild,i):s>0?f(t.rightChild,i):t}};this.find=function(t){return!!f(n,t)},this.getElementByKey=function(t){var e=f(n,t);if(void 0===(null==e?void 0:e.key)||void 0===(null==e?void 0:e.value))throw new Error("unknown error");return e.value},this.union=function(t){var e=this;t.forEach((function(t){var i=t.key,s=t.value;return e.setElement(i,s)}))},this.getHeight=function(){if(this.empty())return 0;var t=function(e){return e?Math.max(t(e.leftChild),t(e.rightChild))+1:1};return t(n)};var y=function(t){return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(e){switch(e.label){case 0:return t&&void 0!==t.key&&void 0!==t.value?[5,nh(y(t.leftChild))]:[2];case 1:return e.sent(),[4,{key:t.key,value:t.value}];case 2:return e.sent(),[5,nh(y(t.rightChild))];case 3:return e.sent(),[2]}}))};this[Symbol.iterator]=function(){return y(n)},t.forEach((function(t){var e=t.key,s=t.value;return i.setElement(e,s)})),Object.freeze(this)}Object.freeze(rh);const oh=rh;function ah(t,e,i){var s=this;if(void 0===t&&(t=[]),void 0===e&&(e=ah.initSize),i=i||function(t){var e=0,i="";if("number"==typeof t)e=((e=Math.floor(t))<<5)-e,e&=e;else{i="string"!=typeof t?JSON.stringify(t):t;for(var s=0;s<i.length;s++)e=(e<<5)-e+i.charCodeAt(s),e&=e}return e^e>>>16},0!=(e&e-1))throw new Error("initBucketNum must be 2 to the power of n");var n=0,r=[],o=Math.max(ah.initSize,Math.min(ah.maxSize,e));this.size=function(){return n},this.empty=function(){return 0===n},this.clear=function(){n=0,o=e,r=[]},this.forEach=function(t){var e=0;r.forEach((function(i){i.forEach((function(i){t(i,e++)}))}))};var a=function(t){if(!(t>=ah.maxSize)){o=2*t;var e=[];r.forEach((function(s,n){if(!s.empty()){if(s instanceof Ql&&1===s.size()){var a=s.front();if(void 0===a)throw new Error("unknown error");e[i(a)&o-1]=new Ql([a])}else if(s instanceof sh){var l=new Ql,h=new Ql;s.forEach((function(e){0==(i(e)&t)?l.pushBack(e):h.pushBack(e)})),l.size()>ah.untreeifyThreshold?e[n]=new sh(l):l.size()&&(e[n]=l),h.size()>ah.untreeifyThreshold?e[n+t]=new sh(h):h.size()&&(e[n+t]=h)}else{var c=new Ql,m=new Ql;s.forEach((function(e){0==(i(e)&t)?c.pushBack(e):m.pushBack(e)})),c.size()&&(e[n]=c),m.size()&&(e[n+t]=m)}r[n].clear()}})),r=e}};this.insert=function(t){if(null==t)throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");var e=i(t)&o-1;if(r[e]){var s=r[e].size();if(r[e]instanceof Ql){if(r[e].find(t))return;r[e].pushBack(t),r[e].size()>=ah.treeifyThreshold&&(r[e]=new sh(r[e]))}else r[e].insert(t);var l=r[e].size();n+=l-s}else r[e]=new Ql([t]),++n;n>o*ah.sigma&&a.call(this,o)},this.eraseElementByValue=function(t){var e=i(t)&o-1;if(r[e]){var s=r[e].size();r[e].eraseElementByValue(t),r[e]instanceof sh&&r[e].size()<=ah.untreeifyThreshold&&(r[e]=new Ql(r[e]));var a=r[e].size();n+=a-s}},this.find=function(t){var e=i(t)&o-1;return!!r[e]&&r[e].find(t)},this[Symbol.iterator]=function(){return function(){var t,e,i,s,n,a;return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(l){switch(l.label){case 0:t=0,l.label=1;case 1:if(!(t<o))return[3,10];for(;t<o&&!r[t];)++t;if(t>=o)return[3,10];l.label=2;case 2:l.trys.push([2,7,8,9]),n=void 0,e=function(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}(r[t]),i=e.next(),l.label=3;case 3:return i.done?[3,6]:[4,i.value];case 4:l.sent(),l.label=5;case 5:return i=e.next(),[3,3];case 6:return[3,9];case 7:return s=l.sent(),n={error:s},[3,9];case 8:try{i&&!i.done&&(a=e.return)&&a.call(e)}finally{if(n)throw n.error}return[7];case 9:return++t,[3,1];case 10:return[2]}}))}()},t.forEach((function(t){return s.insert(t)})),Object.freeze(this)}ah.initSize=16,ah.maxSize=1<<30,ah.sigma=.75,ah.treeifyThreshold=8,ah.untreeifyThreshold=6,ah.minTreeifySize=64,Object.freeze(ah);var lh=function(t){var e="function"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};function hh(t,e,i){var s=this;if(void 0===t&&(t=[]),void 0===e&&(e=hh.initSize),i=i||function(t){var e,i,s=0,n="";if("number"==typeof t)s=((s=Math.floor(t))<<5)-s,s&=s;else{n="string"!=typeof t?JSON.stringify(t):t;try{for(var r=lh(n),o=r.next();!o.done;o=r.next())s=(s<<5)-s+o.value.charCodeAt(0),s&=s}catch(t){e={error:t}}finally{try{o&&!o.done&&(i=r.return)&&i.call(r)}finally{if(e)throw e.error}}}return s^s>>>16},0!=(e&e-1))throw new Error("initBucketNum must be 2 to the power of n");var n=0,r=[],o=Math.max(hh.initSize,Math.min(hh.maxSize,e));this.size=function(){return n},this.empty=function(){return 0===n},this.clear=function(){n=0,o=e,r=[]},this.forEach=function(t){var e=0;r.forEach((function(i){i.forEach((function(i){t(i,e++)}))}))};var a=function(t){if(!(t>=hh.maxSize)){o=2*t;var e=[];r.forEach((function(s,n){if(!s.empty()){if(s instanceof Ql&&1===s.size()){var a=s.front(),l=a.key,h=a.value;e[i(l)&o-1]=new Ql([{key:l,value:h}])}else if(s instanceof oh){var c=new Ql,m=new Ql;s.forEach((function(e){0==(i(e.key)&t)?c.pushBack(e):m.pushBack(e)})),c.size()>hh.untreeifyThreshold?e[n]=new oh(c):c.size()&&(e[n]=c),m.size()>hh.untreeifyThreshold?e[n+t]=new oh(m):m.size()&&(e[n+t]=m)}else{var u=new Ql,_=new Ql;s.forEach((function(e){0==(i(e.key)&t)?u.pushBack(e):_.pushBack(e)})),u.size()&&(e[n]=u),_.size()&&(e[n+t]=_)}r[n].clear()}})),r=e}};this.setElement=function(t,e){var s,l;if(null==t)throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");if(null!=e){var h=i(t)&o-1;if(r[h]){var c=r[h].size();if(r[h]instanceof Ql){try{for(var m=lh(r[h]),u=m.next();!u.done;u=m.next()){var _=u.value;if(_.key===t)return void(_.value=e)}}catch(t){s={error:t}}finally{try{u&&!u.done&&(l=m.return)&&l.call(m)}finally{if(s)throw s.error}}r[h].pushBack({key:t,value:e}),r[h].size()>=hh.treeifyThreshold&&(r[h]=new oh(r[h]))}else r[h].setElement(t,e);var d=r[h].size();n+=d-c}else++n,r[h]=new Ql([{key:t,value:e}]);n>o*hh.sigma&&a.call(this,o)}else this.eraseElementByKey(t)},this.getElementByKey=function(t){var e,s,n=i(t)&o-1;if(r[n]){if(r[n]instanceof oh)return r[n].getElementByKey(t);try{for(var a=lh(r[n]),l=a.next();!l.done;l=a.next()){var h=l.value;if(h.key===t)return h.value}}catch(t){e={error:t}}finally{try{l&&!l.done&&(s=a.return)&&s.call(a)}finally{if(e)throw e.error}}}},this.eraseElementByKey=function(t){var e,s,a=i(t)&o-1;if(r[a]){var l=r[a].size();if(r[a]instanceof oh)r[a].eraseElementByKey(t),r[a].size()<=hh.untreeifyThreshold&&(r[a]=new Ql(r[a]));else{var h=-1;try{for(var c=lh(r[a]),m=c.next();!m.done;m=c.next()){var u=m.value;if(++h,u.key===t){r[a].eraseElementByPos(h);break}}}catch(t){e={error:t}}finally{try{m&&!m.done&&(s=c.return)&&s.call(c)}finally{if(e)throw e.error}}}var _=r[a].size();n+=_-l}},this.find=function(t){var e,s,n=i(t)&o-1;if(!r[n])return!1;if(r[n]instanceof oh)return r[n].find(t);try{for(var a=lh(r[n]),l=a.next();!l.done;l=a.next())if(l.value.key===t)return!0}catch(t){e={error:t}}finally{try{l&&!l.done&&(s=a.return)&&s.call(a)}finally{if(e)throw e.error}}return!1},this[Symbol.iterator]=function(){return function(){var t,e,i,s,n,a;return function(t,e){var i,s,n,r,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(i)throw new TypeError("Generator is already executing.");for(;o;)try{if(i=1,s&&(n=2&r[0]?s.return:r[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,r[1])).done)return n;switch(s=0,n&&(r=[2&r[0],n.value]),r[0]){case 0:case 1:n=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,s=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((n=(n=o.trys).length>0&&n[n.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!n||r[1]>n[0]&&r[1]<n[3])){o.label=r[1];break}if(6===r[0]&&o.label<n[1]){o.label=n[1],n=r;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(r);break}n[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],s=0}finally{i=n=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}}(this,(function(l){switch(l.label){case 0:t=0,l.label=1;case 1:if(!(t<o))return[3,10];for(;t<o&&!r[t];)++t;if(t>=o)return[3,10];l.label=2;case 2:l.trys.push([2,7,8,9]),n=void 0,e=lh(r[t]),i=e.next(),l.label=3;case 3:return i.done?[3,6]:[4,i.value];case 4:l.sent(),l.label=5;case 5:return i=e.next(),[3,3];case 6:return[3,9];case 7:return s=l.sent(),n={error:s},[3,9];case 8:try{i&&!i.done&&(a=e.return)&&a.call(e)}finally{if(n)throw n.error}return[7];case 9:return++t,[3,1];case 10:return[2]}}))}()},t.forEach((function(t){var e=t.key,i=t.value;return s.setElement(e,i)})),Object.freeze(this)}hh.initSize=16,hh.maxSize=1<<30,hh.sigma=.75,hh.treeifyThreshold=8,hh.untreeifyThreshold=6,hh.minTreeifySize=64,Object.freeze(hh);class ch{constructor(t){this._iterateCollection=null,this._collection=new sh(void 0,t),this._insertBuffer=new sh(void 0,t),this._insertBufferSwap=new sh(void 0,t),this._deleteBuffer=new sh(void 0,t)}get size(){return this._collection.size()}insert(t){null!==this._iterateCollection?this._insertBuffer.insert(t):this._collection.insert(t)}delete(t){null!==this._iterateCollection?(t.isRemoved=!0,this._deleteBuffer.insert(t)):this._collection.eraseElementByValue(t)}clear(){this._collection.clear(),this._insertBuffer.clear(),this._deleteBuffer.clear()}forEach(t){this._iterateCollection=this._collection,this._iterateCollection.forEach((e=>{e.isRemoved||t(e)}));do{this._iterateCollection=this.flushBuffer(),this._iterateCollection.forEach((e=>{e.isRemoved||t(e)}))}while(0<this._insertBuffer.size()||0<this._deleteBuffer.size());this._iterateCollection=null}flushBuffer(){this._iterateCollection=null,this._deleteBuffer.forEach((t=>this.delete(t))),this._insertBuffer.forEach((t=>this.insert(t)));const t=this._insertBuffer;return this._insertBuffer=this._insertBufferSwap,this._insertBufferSwap=t,this._insertBuffer.clear(),this._deleteBuffer.clear(),t}}class mh{constructor(){this._nonSyncedEvents=new ch(Vl.comparator),this._syncedEvents=new ch(Vl.comparator),this._processingSyncedEvent=!1,this._removeGameObjects=[],this._removeComponents=[]}addEventToNonSyncedCollection(t){this._nonSyncedEvents.insert(t)}removeEventFromNonSyncedCollection(t){this._nonSyncedEvents.delete(t)}addEventToSyncedCollection(t){this._syncedEvents.insert(t)}startProcessNonSyncedEvent(){this._nonSyncedEvents.forEach((t=>t.invoke()))}tryStartProcessSyncedEvent(){this._processingSyncedEvent||(this._processingSyncedEvent=!0,this._syncedEvents.forEach((t=>t.invoke())),this._syncedEvents.clear(),this._processingSyncedEvent=!1)}addRemoveGameObject(t){this._removeGameObjects.push(t)}addRemoveComponent(t){this._removeComponents.push(t)}processRemoveObject(){const t=this._removeComponents;for(let e=0;e<t.length;e++)t[e].gameObject.removeComponent(t[e]);const e=this._removeGameObjects;for(let t=0;t<e.length;t++)e[t].removeFromParent()}}class uh{constructor(){this._oldTime=0,this._time=0,this._unscaledTime=0,this._deltaTime=0,this._unscaledDeltaTime=0,this._timeScale=1}start(){this._oldTime=performance.now()}update(){const t=performance.now();this._unscaledDeltaTime=(t-this._oldTime)/1e3,this._unscaledTime+=this._unscaledDeltaTime,this._deltaTime=this._unscaledDeltaTime*this._timeScale,this._time+=this._deltaTime,this._oldTime=t}get time(){return this._time}get unscaledTime(){return this._unscaledTime}get deltaTime(){return this._deltaTime}get unscaledDeltaTime(){return this._unscaledDeltaTime}get timeScale(){return this._timeScale}set timeScale(t){this._timeScale=t}}class _h{constructor(t,e){this._width=t,this._height=e,this._onResizeDelegates=[]}get width(){return this._width}get height(){return this._height}resize(t,e){this._width=t,this._height=e,this._onResizeDelegates.forEach((i=>i(t,e)))}addOnResizeEventListener(t){this._onResizeDelegates.push(t)}removeOnResizeEventListener(t){const e=this._onResizeDelegates.indexOf(t);e>=0&&this._onResizeDelegates.splice(e,1)}}class dh{constructor(t){this._time=t,this._coroutines=[],this._coroutineCount=0}addCoroutine(t){this._coroutines.push(t),this._coroutineCount+=1}removeCoroutine(t){const e=this._coroutines.indexOf(t);e>=0&&(this._coroutines[e]=null,this._coroutineCount-=1)}tryCompact(){if(dh._needToCompactCount<=this._coroutines.length-this._coroutineCount){let t=0;for(let e=0;e<this._coroutines.length;e++){const i=this._coroutines[e];null!==i&&(this._coroutines[t]=i,t+=1)}this._coroutines.length=this._coroutineCount}}updateAfterProcess(){const t=this._coroutines;for(let e=0;e<t.length;e++){const i=t[e];null!=i&&(i.currentYieldInstructionExist?this.updateAfterProcessSingleInstruction(i):(t[e]=null,this._coroutineCount-=1))}}updateAfterProcessSingleInstruction(t){const e=t.currentYieldInstruction;e instanceof Fl?(t.elapsedTime+=this._time.deltaTime,t.elapsedTime>=e.seconds&&(t.elapsedTime=0,t.fatchNextInstruction())):e instanceof kl?e.predicate()&&t.fatchNextInstruction():e instanceof zl?e.predicate()||t.fatchNextInstruction():null===e&&t.fatchNextInstruction()}endFrameAfterProcess(){const t=this._coroutines;for(let e=0;e<t.length;e++){const i=t[e];null!=i&&(i.currentYieldInstructionExist?this.endFrameAfterProcessSingleInstruction(i):(t[e]=null,this._coroutineCount-=1))}}endFrameAfterProcessSingleInstruction(t){t.currentYieldInstruction instanceof Gl&&t.fatchNextInstruction()}}dh._needToCompactCount=16;class ph{constructor(){this._transformsNeedToUpdate=[],this._rerenderObjectsReadBuffer=new Set,this._rerenderObjectsWriteBuffer=new Set}switchBuffer(){const t=this._rerenderObjectsReadBuffer;this._rerenderObjectsReadBuffer=this._rerenderObjectsWriteBuffer,this._rerenderObjectsWriteBuffer=t}enqueueTransformToUpdate(t){t.isRegisteredToProcessor||(t.isRegisteredToProcessor=!0,this._transformsNeedToUpdate.push(t))}enqueueRenderObject(t){this._rerenderObjectsWriteBuffer.add(t)}flush(){this._rerenderObjectsReadBuffer.clear()}update(){const t=this._transformsNeedToUpdate;for(let e=0;e<t.length;e++){const i=t[e];i.tryUpdateWorldMatrixRecursivelyFromThisToChildren(),i.isRegisteredToProcessor=!1}return this._transformsNeedToUpdate.length=0,this.switchBuffer(),this._rerenderObjectsReadBuffer}}const fh=new pt,yh=new dt,gh=new pt,xh=new qt,vh=new qt;class Sh{constructor(){this._width=0,this._height=0,this._widthHalf=0,this._heightHalf=0,this._cache={camera:{fov:0,style:""},objects:new WeakMap};const t=document.createElement("div");t.style.overflow="hidden",this.domElement=t,this._cameraElement=document.createElement("div"),this._cameraElement.style.transformStyle="preserve-3d",this._cameraElement.style.pointerEvents="none",this.domElement.appendChild(this._cameraElement)}getSize(){return{width:this._width,height:this._height}}render(t,e,i){const s=i.projectionMatrix.elements[5]*this._heightHalf;let n,r;this._cache.camera.fov!==s&&(this.domElement.style.perspective=i.isPerspectiveCamera?s+"px":"",this._cache.camera.fov=s),!0===e.autoUpdate&&e.updateMatrixWorld(),null===i.parent&&i.updateMatrixWorld(),i.isOrthographicCamera?(n=-(i.right+i.left)/2,r=(i.top+i.bottom)/2):(n=1,r=1);const o=i.isOrthographicCamera?"scale("+s+")translate("+this.epsilon(n)+"px,"+this.epsilon(r)+"px)"+this.getCameraCSSMatrix(i.matrixWorldInverse):"translateZ("+s+"px)"+this.getCameraCSSMatrix(i.matrixWorldInverse),a=o+"translate("+this._widthHalf+"px,"+this._heightHalf+"px)";this._cache.camera.style!==a&&(this._cameraElement.style.transform=a,this._cache.camera.style=a);for(const s of t)this.renderObject(s,e,i,o)}setSize(t,e){this._width=t,this._height=e,this._widthHalf=this._width/2,this._heightHalf=this._height/2,this.domElement.style.width=t+"px",this.domElement.style.height=e+"px",this._cameraElement.style.width=t+"px",this._cameraElement.style.height=e+"px"}epsilon(t){return Math.abs(t)<1e-10?0:t}getCameraCSSMatrix(t){const e=t.elements,i=this.epsilon;return"matrix3d("+i(e[0])+","+i(-e[1])+","+i(e[2])+","+i(e[3])+","+i(e[4])+","+i(-e[5])+","+i(e[6])+","+i(e[7])+","+i(e[8])+","+i(-e[9])+","+i(e[10])+","+i(e[11])+","+i(e[12])+","+i(-e[13])+","+i(e[14])+","+i(e[15])+")"}getObjectCSSMatrix(t){const e=t.elements,i=this.epsilon;return"translate(-50%,-50%)matrix3d("+i(e[0])+","+i(e[1])+","+i(e[2])+","+i(e[3])+","+i(-e[4])+","+i(-e[5])+","+i(-e[6])+","+i(-e[7])+","+i(e[8])+","+i(e[9])+","+i(e[10])+","+i(e[11])+","+i(e[12])+","+i(e[13])+","+i(e[14])+","+i(e[15])+")"}renderObject(t,e,i,s){if(t.isCSS3DObject){let s;t.onBeforeRender(this,e,i),t.isCSS3DSprite?(xh.copy(i.matrixWorldInverse),xh.transpose(),0!==t.rotation2D&&xh.multiply(vh.makeRotationZ(t.rotation2D)),t.matrixWorld.decompose(fh,yh,gh),xh.setPosition(fh),xh.scale(gh),xh.elements[3]=0,xh.elements[7]=0,xh.elements[11]=0,xh.elements[15]=1,s=this.getObjectCSSMatrix(xh)):s=this.getObjectCSSMatrix(t.matrixWorld);const n=t.element,r=this._cache.objects.get(t);if(void 0===r||r.style!==s){n.style.transform=s;const e={style:s};this._cache.objects.set(t,e)}n.style.display=t.visible?"":"none",n.parentNode!==this._cameraElement&&this._cameraElement.appendChild(n),t.onAfterRender(this,e,i)}for(let n=0,r=t.children.length;n<r;++n)this.renderObject(t.children[n],e,i,s)}}class wh{constructor(t=.5,e=.5,i=.5,s=1){this.r=t,this.g=e,this.b=i,this.a=s}Clone(){return(new wh).Copy(this)}Copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,i,s=this.a){this.SetRGBA(t,e,i,s)}SetByteRGB(t,e,i){return this.r=t/255,this.g=e/255,this.b=i/255,this}SetByteRGBA(t,e,i,s){return this.r=t/255,this.g=e/255,this.b=i/255,this.a=s/255,this}SetRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}SetRGBA(t,e,i,s){return this.r=t,this.g=e,this.b=i,this.a=s,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){wh.MixColors(this,t,e)}static MixColors(t,e,i){const s=i*(e.r-t.r),n=i*(e.g-t.g),r=i*(e.b-t.b),o=i*(e.a-t.a);t.r+=s,t.g+=n,t.b+=r,t.a+=o,e.r-=s,e.g-=n,e.b-=r,e.a-=o}MakeStyleString(t=this.a){return wh.MakeStyleString(this.r,this.g,this.b,t)}static MakeStyleString(t,e,i,s=1){return t*=255,e*=255,i*=255,s<1?`rgba(${t},${e},${i},${s})`:`rgb(${t},${e},${i})`}}wh.ZERO=new wh(0,0,0,0),wh.RED=new wh(1,0,0),wh.GREEN=new wh(0,1,0),wh.BLUE=new wh(0,0,1);class bh{constructor(...t){if(t[0]instanceof Float32Array){if(4!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:.5,i="number"==typeof t[1]?t[1]:.5,s="number"==typeof t[2]?t[2]:.5,n="number"==typeof t[3]?t[3]:1;this.data=new Float32Array([e,i,s,n])}}get r(){return this.data[0]}set r(t){this.data[0]=t}get g(){return this.data[1]}set g(t){this.data[1]=t}get b(){return this.data[2]}set b(t){this.data[2]=t}get a(){return this.data[3]}set a(t){this.data[3]=t}Clone(){return new bh(new Float32Array(this.data))}Copy(t){return t instanceof bh?this.data.set(t.data):(this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a),this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,i,s=this.a){this.SetRGBA(t,e,i,s)}SetByteRGB(t,e,i){return this.r=t/255,this.g=e/255,this.b=i/255,this}SetByteRGBA(t,e,i,s){return this.r=t/255,this.g=e/255,this.b=i/255,this.a=s/255,this}SetRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}SetRGBA(t,e,i,s){return this.r=t,this.g=e,this.b=i,this.a=s,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){wh.MixColors(this,t,e)}MakeStyleString(t=this.a){return wh.MakeStyleString(this.r,this.g,this.b,t)}}var Ch;function Ah(t,e){return void 0!==t?t:e}!function(t){t[t.e_none=0]="e_none",t[t.e_shapeBit=1]="e_shapeBit",t[t.e_jointBit=2]="e_jointBit",t[t.e_aabbBit=4]="e_aabbBit",t[t.e_pairBit=8]="e_pairBit",t[t.e_centerOfMassBit=16]="e_centerOfMassBit",t[t.e_particleBit=32]="e_particleBit",t[t.e_controllerBit=64]="e_controllerBit",t[t.e_all=63]="e_all"}(Ch||(Ch={}));const Bh=1e37,Mh=1e-5,Vh=1.0000000000000002e-10,Th=3.14159265359,Ph=.005,Dh=.03490658503988889,Ih=.01,Eh=.13962634015955555,Rh=1.570796326795,Lh=2.4674011002726646,Gh=-1;function Fh(t,e){const i=new Array(t);for(let s=0;s<t;++s)i[s]=e(s);return i}function kh(t,e=0){const i=new Array(t);for(let s=0;s<t;++s)i[s]=e;return i}new class{constructor(t=0,e=0,i=0){this.major=0,this.minor=0,this.revision=0,this.major=t,this.minor=e,this.revision=i}toString(){return this.major+"."+this.minor+"."+this.revision}}(2,4,1);class zh{constructor(t){this.m_stack=[],this.m_count=0,this.m_stack=Fh(t,(t=>null)),this.m_count=0}Reset(){return this.m_count=0,this}Push(t){this.m_stack[this.m_count]=t,this.m_count++}Pop(){this.m_count--;const t=this.m_stack[this.m_count];return this.m_stack[this.m_count]=null,t}GetCount(){return this.m_count}}const Oh=6.28318530718,Nh=Math.abs;function Uh(t,e){return t<e?t:e}function Wh(t,e){return t>e?t:e}function jh(t,e,i){return t<e?e:t>i?i:t}function Hh(t){return t*t}function qh(t){return 1/Math.sqrt(t)}isFinite;const Xh=Math.sqrt,Jh=Math.pow;Math.cos,Math.sin,Math.acos;const Zh=Math.asin;Math.atan2;class Yh{constructor(t=0,e=0){this.x=t,this.y=e}Clone(){return new Yh(this.x,this.y)}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return this.x=t.x,this.y=t.y,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=Mh){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=Mh){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.x;return this.x=e*s-i*this.y,this.y=i*s+e*this.y,this}SelfRotateCosSin(t,e){const i=this.x;return this.x=t*i-e*this.y,this.y=e*i+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=Uh(this.x,t.x),this.y=Uh(this.y,t.y),this}SelfMaxV(t){return this.x=Wh(this.x,t.x),this.y=Wh(this.y,t.y),this}SelfAbs(){return this.x=Nh(this.x),this.y=Nh(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}static MakeArray(t){return Fh(t,(t=>new Yh))}static AbsV(t,e){return e.x=Nh(t.x),e.y=Nh(t.y),e}static MinV(t,e,i){return i.x=Uh(t.x,e.x),i.y=Uh(t.y,e.y),i}static MaxV(t,e,i){return i.x=Wh(t.x,e.x),i.y=Wh(t.y,e.y),i}static ClampV(t,e,i,s){return s.x=jh(t.x,e.x,i.x),s.y=jh(t.y,e.y,i.y),s}static RotateV(t,e,i){const s=t.x,n=t.y,r=Math.cos(e),o=Math.sin(e);return i.x=r*s-o*n,i.y=o*s+r*n,i}static DotVV(t,e){return t.x*e.x+t.y*e.y}static CrossVV(t,e){return t.x*e.y-t.y*e.x}static CrossVS(t,e,i){const s=t.x;return i.x=e*t.y,i.y=-e*s,i}static CrossVOne(t,e){const i=t.x;return e.x=t.y,e.y=-i,e}static CrossSV(t,e,i){const s=e.x;return i.x=-t*e.y,i.y=t*s,i}static CrossOneV(t,e){const i=t.x;return e.x=-t.y,e.y=i,e}static AddVV(t,e,i){return i.x=t.x+e.x,i.y=t.y+e.y,i}static SubVV(t,e,i){return i.x=t.x-e.x,i.y=t.y-e.y,i}static MulSV(t,e,i){return i.x=e.x*t,i.y=e.y*t,i}static MulVS(t,e,i){return i.x=t.x*e,i.y=t.y*e,i}static AddVMulSV(t,e,i,s){return s.x=t.x+e*i.x,s.y=t.y+e*i.y,s}static SubVMulSV(t,e,i,s){return s.x=t.x-e*i.x,s.y=t.y-e*i.y,s}static AddVCrossSV(t,e,i,s){const n=i.x;return s.x=t.x-e*i.y,s.y=t.y+e*n,s}static MidVV(t,e,i){return i.x=.5*(t.x+e.x),i.y=.5*(t.y+e.y),i}static ExtVV(t,e,i){return i.x=.5*(e.x-t.x),i.y=.5*(e.y-t.y),i}static IsEqualToV(t,e){return t.x===e.x&&t.y===e.y}static DistanceVV(t,e){const i=t.x-e.x,s=t.y-e.y;return Math.sqrt(i*i+s*s)}static DistanceSquaredVV(t,e){const i=t.x-e.x,s=t.y-e.y;return i*i+s*s}static NegV(t,e){return e.x=-t.x,e.y=-t.y,e}}Yh.ZERO=new Yh(0,0),Yh.UNITX=new Yh(1,0),Yh.UNITY=new Yh(0,1),Yh.s_t0=new Yh,Yh.s_t1=new Yh,Yh.s_t2=new Yh,Yh.s_t3=new Yh,new Yh(0,0);class Qh{constructor(...t){if(t[0]instanceof Float32Array){if(2!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,i="number"==typeof t[1]?t[1]:0;this.data=new Float32Array([e,i])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}Clone(){return new Qh(new Float32Array(this.data))}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return t instanceof Qh?this.data.set(t.data):(this.x=t.x,this.y=t.y),this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=Mh){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=Mh){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.x;return this.x=e*s-i*this.y,this.y=i*s+e*this.y,this}SelfRotateCosSin(t,e){const i=this.x;return this.x=t*i-e*this.y,this.y=e*i+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=Uh(this.x,t.x),this.y=Uh(this.y,t.y),this}SelfMaxV(t){return this.x=Wh(this.x,t.x),this.y=Wh(this.y,t.y),this}SelfAbs(){return this.x=Nh(this.x),this.y=Nh(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}}class Kh{constructor(...t){if(t[0]instanceof Float32Array){if(3!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,i="number"==typeof t[1]?t[1]:0,s="number"==typeof t[2]?t[2]:0;this.data=new Float32Array([e,i,s])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}get z(){return this.data[2]}set z(t){this.data[2]=t}Clone(){return new Kh(this.x,this.y,this.z)}SetZero(){return this.x=0,this.y=0,this.z=0,this}SetXYZ(t,e,i){return this.x=t,this.y=e,this.z=i,this}Copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}SelfAddXYZ(t,e,i){return this.x+=t,this.y+=e,this.z+=i,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}SelfSubXYZ(t,e,i){return this.x-=t,this.y-=e,this.z-=i,this}SelfMul(t){return this.x*=t,this.y*=t,this.z*=t,this}static DotV3V3(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossV3V3(t,e,i){const s=t.x,n=t.y,r=t.z,o=e.x,a=e.y,l=e.z;return i.x=n*l-r*a,i.y=r*o-s*l,i.z=s*a-n*o,i}}Kh.ZERO=new Kh(0,0,0),Kh.s_t0=new Kh;class $h{constructor(){this.ex=new Yh(1,0),this.ey=new Yh(0,1)}Clone(){return(new $h).Copy(this)}static FromVV(t,e){return(new $h).SetVV(t,e)}static FromSSSS(t,e,i,s){return(new $h).SetSSSS(t,e,i,s)}static FromAngle(t){return(new $h).SetAngle(t)}SetSSSS(t,e,i,s){return this.ex.Set(t,i),this.ey.Set(e,s),this}SetVV(t,e){return this.ex.Copy(t),this.ey.Copy(e),this}SetAngle(t){const e=Math.cos(t),i=Math.sin(t);return this.ex.Set(e,i),this.ey.Set(-i,e),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this}SetIdentity(){return this.ex.Set(1,0),this.ey.Set(0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this}GetAngle(){return Math.atan2(this.ex.y,this.ex.x)}GetInverse(t){const e=this.ex.x,i=this.ey.x,s=this.ex.y,n=this.ey.y;let r=e*n-i*s;return 0!==r&&(r=1/r),t.ex.x=r*n,t.ey.x=-r*i,t.ex.y=-r*s,t.ey.y=r*e,t}Solve(t,e,i){const s=this.ex.x,n=this.ey.x,r=this.ex.y,o=this.ey.y;let a=s*o-n*r;return 0!==a&&(a=1/a),i.x=a*(o*t-n*e),i.y=a*(s*e-r*t),i}SelfAbs(){return this.ex.SelfAbs(),this.ey.SelfAbs(),this}SelfInv(){return this.GetInverse(this),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this}SelfSubM(t){return this.ex.SelfSub(t.ex),this.ey.SelfSub(t.ey),this}static AbsM(t,e){const i=t.ex,s=t.ey;return e.ex.x=Nh(i.x),e.ex.y=Nh(i.y),e.ey.x=Nh(s.x),e.ey.y=Nh(s.y),e}static MulMV(t,e,i){const s=t.ex,n=t.ey,r=e.x,o=e.y;return i.x=s.x*r+n.x*o,i.y=s.y*r+n.y*o,i}static MulTMV(t,e,i){const s=t.ex,n=t.ey,r=e.x,o=e.y;return i.x=s.x*r+s.y*o,i.y=n.x*r+n.y*o,i}static AddMM(t,e,i){const s=t.ex,n=t.ey,r=e.ex,o=e.ey;return i.ex.x=s.x+r.x,i.ex.y=s.y+r.y,i.ey.x=n.x+o.x,i.ey.y=n.y+o.y,i}static MulMM(t,e,i){const s=t.ex.x,n=t.ex.y,r=t.ey.x,o=t.ey.y,a=e.ex.x,l=e.ex.y,h=e.ey.x,c=e.ey.y;return i.ex.x=s*a+r*l,i.ex.y=n*a+o*l,i.ey.x=s*h+r*c,i.ey.y=n*h+o*c,i}static MulTMM(t,e,i){const s=t.ex.x,n=t.ex.y,r=t.ey.x,o=t.ey.y,a=e.ex.x,l=e.ex.y,h=e.ey.x,c=e.ey.y;return i.ex.x=s*a+n*l,i.ex.y=r*a+o*l,i.ey.x=s*h+n*c,i.ey.y=r*h+o*c,i}}$h.IDENTITY=new $h;class tc{constructor(){this.data=new Float32Array([1,0,0,0,1,0,0,0,1]),this.ex=new Kh(this.data.subarray(0,3)),this.ey=new Kh(this.data.subarray(3,6)),this.ez=new Kh(this.data.subarray(6,9))}Clone(){return(new tc).Copy(this)}SetVVV(t,e,i){return this.ex.Copy(t),this.ey.Copy(e),this.ez.Copy(i),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this.ez.Copy(t.ez),this}SetIdentity(){return this.ex.SetXYZ(1,0,0),this.ey.SetXYZ(0,1,0),this.ez.SetXYZ(0,0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this.ez.SetZero(),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this.ez.SelfAdd(t.ez),this}Solve33(t,e,i,s){const n=this.ex.x,r=this.ex.y,o=this.ex.z,a=this.ey.x,l=this.ey.y,h=this.ey.z,c=this.ez.x,m=this.ez.y,u=this.ez.z;let _=n*(l*u-h*m)+r*(h*c-a*u)+o*(a*m-l*c);return 0!==_&&(_=1/_),s.x=_*(t*(l*u-h*m)+e*(h*c-a*u)+i*(a*m-l*c)),s.y=_*(n*(e*u-i*m)+r*(i*c-t*u)+o*(t*m-e*c)),s.z=_*(n*(l*i-h*e)+r*(h*t-a*i)+o*(a*e-l*t)),s}Solve22(t,e,i){const s=this.ex.x,n=this.ey.x,r=this.ex.y,o=this.ey.y;let a=s*o-n*r;return 0!==a&&(a=1/a),i.x=a*(o*t-n*e),i.y=a*(s*e-r*t),i}GetInverse22(t){const e=this.ex.x,i=this.ey.x,s=this.ex.y,n=this.ey.y;let r=e*n-i*s;0!==r&&(r=1/r),t.ex.x=r*n,t.ey.x=-r*i,t.ex.z=0,t.ex.y=-r*s,t.ey.y=r*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}GetSymInverse33(t){let e=Kh.DotV3V3(this.ex,Kh.CrossV3V3(this.ey,this.ez,Kh.s_t0));0!==e&&(e=1/e);const i=this.ex.x,s=this.ey.x,n=this.ez.x,r=this.ey.y,o=this.ez.y,a=this.ez.z;t.ex.x=e*(r*a-o*o),t.ex.y=e*(n*o-s*a),t.ex.z=e*(s*o-n*r),t.ey.x=t.ex.y,t.ey.y=e*(i*a-n*n),t.ey.z=e*(n*s-i*o),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(i*r-s*s)}static MulM33V3(t,e,i){const s=e.x,n=e.y,r=e.z;return i.x=t.ex.x*s+t.ey.x*n+t.ez.x*r,i.y=t.ex.y*s+t.ey.y*n+t.ez.y*r,i.z=t.ex.z*s+t.ey.z*n+t.ez.z*r,i}static MulM33XYZ(t,e,i,s,n){return n.x=t.ex.x*e+t.ey.x*i+t.ez.x*s,n.y=t.ex.y*e+t.ey.y*i+t.ez.y*s,n.z=t.ex.z*e+t.ey.z*i+t.ez.z*s,n}static MulM33V2(t,e,i){const s=e.x,n=e.y;return i.x=t.ex.x*s+t.ey.x*n,i.y=t.ex.y*s+t.ey.y*n,i}static MulM33XY(t,e,i,s){return s.x=t.ex.x*e+t.ey.x*i,s.y=t.ex.y*e+t.ey.y*i,s}}tc.IDENTITY=new tc;class ec{constructor(t=0){this.s=0,this.c=1,t&&(this.s=Math.sin(t),this.c=Math.cos(t))}Clone(){return(new ec).Copy(this)}Copy(t){return this.s=t.s,this.c=t.c,this}SetAngle(t){return this.s=Math.sin(t),this.c=Math.cos(t),this}SetIdentity(){return this.s=0,this.c=1,this}GetAngle(){return Math.atan2(this.s,this.c)}GetXAxis(t){return t.x=this.c,t.y=this.s,t}GetYAxis(t){return t.x=-this.s,t.y=this.c,t}static MulRR(t,e,i){const s=t.c,n=t.s,r=e.c,o=e.s;return i.s=n*r+s*o,i.c=s*r-n*o,i}static MulTRR(t,e,i){const s=t.c,n=t.s,r=e.c,o=e.s;return i.s=s*o-n*r,i.c=s*r+n*o,i}static MulRV(t,e,i){const s=t.c,n=t.s,r=e.x,o=e.y;return i.x=s*r-n*o,i.y=n*r+s*o,i}static MulTRV(t,e,i){const s=t.c,n=t.s,r=e.x,o=e.y;return i.x=s*r+n*o,i.y=-n*r+s*o,i}}ec.IDENTITY=new ec;class ic{constructor(){this.p=new Yh,this.q=new ec}Clone(){return(new ic).Copy(this)}Copy(t){return this.p.Copy(t.p),this.q.Copy(t.q),this}SetIdentity(){return this.p.SetZero(),this.q.SetIdentity(),this}SetPositionRotation(t,e){return this.p.Copy(t),this.q.Copy(e),this}SetPositionAngle(t,e){return this.p.Copy(t),this.q.SetAngle(e),this}SetPosition(t){return this.p.Copy(t),this}SetPositionXY(t,e){return this.p.Set(t,e),this}SetRotation(t){return this.q.Copy(t),this}SetRotationAngle(t){return this.q.SetAngle(t),this}GetPosition(){return this.p}GetRotation(){return this.q}GetRotationAngle(){return this.q.GetAngle()}GetAngle(){return this.q.GetAngle()}static MulXV(t,e,i){const s=t.q.c,n=t.q.s,r=e.x,o=e.y;return i.x=s*r-n*o+t.p.x,i.y=n*r+s*o+t.p.y,i}static MulTXV(t,e,i){const s=t.q.c,n=t.q.s,r=e.x-t.p.x,o=e.y-t.p.y;return i.x=s*r+n*o,i.y=-n*r+s*o,i}static MulXX(t,e,i){return ec.MulRR(t.q,e.q,i.q),Yh.AddVV(ec.MulRV(t.q,e.p,i.p),t.p,i.p),i}static MulTXX(t,e,i){return ec.MulTRR(t.q,e.q,i.q),ec.MulTRV(t.q,Yh.SubVV(e.p,t.p,i.p),i.p),i}}ic.IDENTITY=new ic;class sc{constructor(){this.localCenter=new Yh,this.c0=new Yh,this.c=new Yh,this.a0=0,this.a=0,this.alpha0=0}Clone(){return(new sc).Copy(this)}Copy(t){return this.localCenter.Copy(t.localCenter),this.c0.Copy(t.c0),this.c.Copy(t.c),this.a0=t.a0,this.a=t.a,this.alpha0=t.alpha0,this}GetTransform(t,e){t.p.x=(1-e)*this.c0.x+e*this.c.x,t.p.y=(1-e)*this.c0.y+e*this.c.y;const i=(1-e)*this.a0+e*this.a;return t.q.SetAngle(i),t.p.SelfSub(ec.MulRV(t.q,this.localCenter,Yh.s_t0)),t}Advance(t){const e=(t-this.alpha0)/(1-this.alpha0),i=1-e;this.c0.x=i*this.c0.x+e*this.c.x,this.c0.y=i*this.c0.y+e*this.c.y,this.a0=i*this.a0+e*this.a,this.alpha0=t}Normalize(){const t=Oh*Math.floor(this.a0/Oh);this.a0-=t,this.a-=t}}class nc{constructor(){this.m_buffer=Yh.MakeArray(2),this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0}Copy(t){return t.m_vertices===t.m_buffer?(this.m_vertices=this.m_buffer,this.m_buffer[0].Copy(t.m_buffer[0]),this.m_buffer[1].Copy(t.m_buffer[1])):this.m_vertices=t.m_vertices,this.m_count=t.m_count,this.m_radius=t.m_radius,this}Reset(){return this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0,this}SetShape(t,e){t.SetupDistanceProxy(this,e)}SetVerticesRadius(t,e,i){this.m_vertices=t,this.m_count=e,this.m_radius=i}GetSupport(t){let e=0,i=Yh.DotVV(this.m_vertices[0],t);for(let s=1;s<this.m_count;++s){const n=Yh.DotVV(this.m_vertices[s],t);n>i&&(e=s,i=n)}return e}GetSupportVertex(t){let e=0,i=Yh.DotVV(this.m_vertices[0],t);for(let s=1;s<this.m_count;++s){const n=Yh.DotVV(this.m_vertices[s],t);n>i&&(e=s,i=n)}return this.m_vertices[e]}GetVertexCount(){return this.m_count}GetVertex(t){return this.m_vertices[t]}}class rc{constructor(){this.metric=0,this.count=0,this.indexA=[0,0,0],this.indexB=[0,0,0]}Reset(){return this.metric=0,this.count=0,this}}class oc{constructor(){this.proxyA=new nc,this.proxyB=new nc,this.transformA=new ic,this.transformB=new ic,this.useRadii=!1}Reset(){return this.proxyA.Reset(),this.proxyB.Reset(),this.transformA.SetIdentity(),this.transformB.SetIdentity(),this.useRadii=!1,this}}class ac{constructor(){this.pointA=new Yh,this.pointB=new Yh,this.distance=0,this.iterations=0}Reset(){return this.pointA.SetZero(),this.pointB.SetZero(),this.distance=0,this.iterations=0,this}}let lc=0;class hc{constructor(){this.wA=new Yh,this.wB=new Yh,this.w=new Yh,this.a=0,this.indexA=0,this.indexB=0}Copy(t){return this.wA.Copy(t.wA),this.wB.Copy(t.wB),this.w.Copy(t.w),this.a=t.a,this.indexA=t.indexA,this.indexB=t.indexB,this}}class cc{constructor(){this.m_v1=new hc,this.m_v2=new hc,this.m_v3=new hc,this.m_vertices=[],this.m_count=0,this.m_vertices[0]=this.m_v1,this.m_vertices[1]=this.m_v2,this.m_vertices[2]=this.m_v3}ReadCache(t,e,i,s,n){this.m_count=t.count;const r=this.m_vertices;for(let o=0;o<this.m_count;++o){const a=r[o];a.indexA=t.indexA[o],a.indexB=t.indexB[o];const l=e.GetVertex(a.indexA),h=s.GetVertex(a.indexB);ic.MulXV(i,l,a.wA),ic.MulXV(n,h,a.wB),Yh.SubVV(a.wB,a.wA,a.w),a.a=0}if(this.m_count>1){const e=t.metric,i=this.GetMetric();(i<.5*e||2*e<i||i<Mh)&&(this.m_count=0)}if(0===this.m_count){const t=r[0];t.indexA=0,t.indexB=0;const o=e.GetVertex(0),a=s.GetVertex(0);ic.MulXV(i,o,t.wA),ic.MulXV(n,a,t.wB),Yh.SubVV(t.wB,t.wA,t.w),t.a=1,this.m_count=1}}WriteCache(t){t.metric=this.GetMetric(),t.count=this.m_count;const e=this.m_vertices;for(let i=0;i<this.m_count;++i)t.indexA[i]=e[i].indexA,t.indexB[i]=e[i].indexB}GetSearchDirection(t){switch(this.m_count){case 1:return Yh.NegV(this.m_v1.w,t);case 2:{const e=Yh.SubVV(this.m_v2.w,this.m_v1.w,t);return Yh.CrossVV(e,Yh.NegV(this.m_v1.w,Yh.s_t0))>0?Yh.CrossOneV(e,t):Yh.CrossVOne(e,t)}default:return t.SetZero()}}GetClosestPoint(t){switch(this.m_count){case 0:case 3:default:return t.SetZero();case 1:return t.Copy(this.m_v1.w);case 2:return t.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y)}}GetWitnessPoints(t,e){switch(this.m_count){case 0:default:break;case 1:t.Copy(this.m_v1.wA),e.Copy(this.m_v1.wB);break;case 2:t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x,t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y,e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x,e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x,e.y=t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y}}GetMetric(){switch(this.m_count){case 0:case 1:default:return 0;case 2:return Yh.DistanceVV(this.m_v1.w,this.m_v2.w);case 3:return Yh.CrossVV(Yh.SubVV(this.m_v2.w,this.m_v1.w,Yh.s_t0),Yh.SubVV(this.m_v3.w,this.m_v1.w,Yh.s_t1))}}Solve2(){const t=this.m_v1.w,e=this.m_v2.w,i=Yh.SubVV(e,t,cc.s_e12),s=-Yh.DotVV(t,i);if(s<=0)return this.m_v1.a=1,void(this.m_count=1);const n=Yh.DotVV(e,i);if(n<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);const r=1/(n+s);this.m_v1.a=n*r,this.m_v2.a=s*r,this.m_count=2}Solve3(){const t=this.m_v1.w,e=this.m_v2.w,i=this.m_v3.w,s=Yh.SubVV(e,t,cc.s_e12),n=Yh.DotVV(t,s),r=Yh.DotVV(e,s),o=-n,a=Yh.SubVV(i,t,cc.s_e13),l=Yh.DotVV(t,a),h=Yh.DotVV(i,a),c=-l,m=Yh.SubVV(i,e,cc.s_e23),u=Yh.DotVV(e,m),_=Yh.DotVV(i,m),d=-u,p=Yh.CrossVV(s,a),f=p*Yh.CrossVV(e,i),y=p*Yh.CrossVV(i,t),g=p*Yh.CrossVV(t,e);if(o<=0&&c<=0)return this.m_v1.a=1,void(this.m_count=1);if(r>0&&o>0&&g<=0){const t=1/(r+o);return this.m_v1.a=r*t,this.m_v2.a=o*t,void(this.m_count=2)}if(h>0&&c>0&&y<=0){const t=1/(h+c);return this.m_v1.a=h*t,this.m_v3.a=c*t,this.m_count=2,void this.m_v2.Copy(this.m_v3)}if(r<=0&&d<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);if(h<=0&&_<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v3);if(_>0&&d>0&&f<=0){const t=1/(_+d);return this.m_v2.a=_*t,this.m_v3.a=d*t,this.m_count=2,void this.m_v1.Copy(this.m_v3)}const x=1/(f+y+g);this.m_v1.a=f*x,this.m_v2.a=y*x,this.m_v3.a=g*x,this.m_count=3}}cc.s_e12=new Yh,cc.s_e13=new Yh,cc.s_e23=new Yh;const mc=new cc,uc=[0,0,0],_c=[0,0,0],dc=new Yh,pc=new Yh,fc=new Yh,yc=new Yh,gc=new Yh;function xc(t,e,i){const s=i.proxyA,n=i.proxyB,r=i.transformA,o=i.transformB,a=mc;a.ReadCache(e,s,r,n,o);const l=a.m_vertices,h=uc,c=_c;let m=0,u=0;for(;u<20;){m=a.m_count;for(let t=0;t<m;++t)h[t]=l[t].indexA,c[t]=l[t].indexB;switch(a.m_count){case 1:default:break;case 2:a.Solve2();break;case 3:a.Solve3()}if(3===a.m_count)break;const t=a.GetSearchDirection(pc);if(t.LengthSquared()<Vh)break;const e=l[a.m_count];e.indexA=s.GetSupport(ec.MulTRV(r.q,Yh.NegV(t,Yh.s_t0),yc)),ic.MulXV(r,s.GetVertex(e.indexA),e.wA),e.indexB=n.GetSupport(ec.MulTRV(o.q,t,gc)),ic.MulXV(o,n.GetVertex(e.indexB),e.wB),Yh.SubVV(e.wB,e.wA,e.w),++u;let i=!1;for(let t=0;t<m;++t)if(e.indexA===h[t]&&e.indexB===c[t]){i=!0;break}if(i)break;++a.m_count}if(lc=Wh(lc,u),a.GetWitnessPoints(t.pointA,t.pointB),t.distance=Yh.DistanceVV(t.pointA,t.pointB),t.iterations=u,a.WriteCache(e),i.useRadii){const e=s.m_radius,i=n.m_radius;if(t.distance>e+i&&t.distance>Mh){t.distance-=e+i;const s=Yh.SubVV(t.pointB,t.pointA,fc);s.Normalize(),t.pointA.SelfMulAdd(e,s),t.pointB.SelfMulSub(i,s)}else{const e=Yh.MidVV(t.pointA,t.pointB,dc);t.pointA.Copy(e),t.pointB.Copy(e),t.distance=0}}}var vc,Sc,wc;new Yh,new cc,new Yh,new Yh,new Yh,new Yh,new Yh,new Yh,function(t){t[t.e_vertex=0]="e_vertex",t[t.e_face=1]="e_face"}(vc||(vc={}));class bc{constructor(){this._key=0,this._key_invalid=!1,this._indexA=0,this._indexB=0,this._typeA=0,this._typeB=0}get key(){return this._key_invalid&&(this._key_invalid=!1,this._key=this._indexA|this._indexB<<8|this._typeA<<16|this._typeB<<24),this._key}set key(t){this._key=t,this._key_invalid=!1,this._indexA=255&this._key,this._indexB=this._key>>8&255,this._typeA=this._key>>16&255,this._typeB=this._key>>24&255}get indexA(){return this._indexA}set indexA(t){this._indexA=t,this._key_invalid=!0}get indexB(){return this._indexB}set indexB(t){this._indexB=t,this._key_invalid=!0}get typeA(){return this._typeA}set typeA(t){this._typeA=t,this._key_invalid=!0}get typeB(){return this._typeB}set typeB(t){this._typeB=t,this._key_invalid=!0}}class Cc{constructor(){this.cf=new bc}Copy(t){return this.key=t.key,this}Clone(){return(new Cc).Copy(this)}get key(){return this.cf.key}set key(t){this.cf.key=t}}class Ac{constructor(){this.localPoint=new Yh,this.normalImpulse=0,this.tangentImpulse=0,this.id=new Cc}static MakeArray(t){return Fh(t,(t=>new Ac))}Reset(){this.localPoint.SetZero(),this.normalImpulse=0,this.tangentImpulse=0,this.id.key=0}Copy(t){return this.localPoint.Copy(t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.Copy(t.id),this}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circles=0]="e_circles",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(Sc||(Sc={}));class Bc{constructor(){this.points=Ac.MakeArray(2),this.localNormal=new Yh,this.localPoint=new Yh,this.type=Sc.e_unknown,this.pointCount=0}Reset(){for(let t=0;t<2;++t)this.points[t].Reset();this.localNormal.SetZero(),this.localPoint.SetZero(),this.type=Sc.e_unknown,this.pointCount=0}Copy(t){this.pointCount=t.pointCount;for(let e=0;e<2;++e)this.points[e].Copy(t.points[e]);return this.localNormal.Copy(t.localNormal),this.localPoint.Copy(t.localPoint),this.type=t.type,this}Clone(){return(new Bc).Copy(this)}}class Mc{constructor(){this.normal=new Yh,this.points=Yh.MakeArray(2),this.separations=kh(2)}Initialize(t,e,i,s,n){if(0!==t.pointCount)switch(t.type){case Sc.e_circles:{this.normal.Set(1,0);const r=ic.MulXV(e,t.localPoint,Mc.Initialize_s_pointA),o=ic.MulXV(s,t.points[0].localPoint,Mc.Initialize_s_pointB);Yh.DistanceSquaredVV(r,o)>Vh&&Yh.SubVV(o,r,this.normal).SelfNormalize();const a=Yh.AddVMulSV(r,i,this.normal,Mc.Initialize_s_cA),l=Yh.SubVMulSV(o,n,this.normal,Mc.Initialize_s_cB);Yh.MidVV(a,l,this.points[0]),this.separations[0]=Yh.DotVV(Yh.SubVV(l,a,Yh.s_t0),this.normal);break}case Sc.e_faceA:{ec.MulRV(e.q,t.localNormal,this.normal);const r=ic.MulXV(e,t.localPoint,Mc.Initialize_s_planePoint);for(let e=0;e<t.pointCount;++e){const o=ic.MulXV(s,t.points[e].localPoint,Mc.Initialize_s_clipPoint),a=i-Yh.DotVV(Yh.SubVV(o,r,Yh.s_t0),this.normal),l=Yh.AddVMulSV(o,a,this.normal,Mc.Initialize_s_cA),h=Yh.SubVMulSV(o,n,this.normal,Mc.Initialize_s_cB);Yh.MidVV(l,h,this.points[e]),this.separations[e]=Yh.DotVV(Yh.SubVV(h,l,Yh.s_t0),this.normal)}break}case Sc.e_faceB:{ec.MulRV(s.q,t.localNormal,this.normal);const r=ic.MulXV(s,t.localPoint,Mc.Initialize_s_planePoint);for(let s=0;s<t.pointCount;++s){const o=ic.MulXV(e,t.points[s].localPoint,Mc.Initialize_s_clipPoint),a=n-Yh.DotVV(Yh.SubVV(o,r,Yh.s_t0),this.normal),l=Yh.AddVMulSV(o,a,this.normal,Mc.Initialize_s_cB),h=Yh.SubVMulSV(o,i,this.normal,Mc.Initialize_s_cA);Yh.MidVV(h,l,this.points[s]),this.separations[s]=Yh.DotVV(Yh.SubVV(h,l,Yh.s_t0),this.normal)}this.normal.SelfNeg();break}}}}Mc.Initialize_s_pointA=new Yh,Mc.Initialize_s_pointB=new Yh,Mc.Initialize_s_cA=new Yh,Mc.Initialize_s_cB=new Yh,Mc.Initialize_s_planePoint=new Yh,Mc.Initialize_s_clipPoint=new Yh,function(t){t[t.b2_nullState=0]="b2_nullState",t[t.b2_addState=1]="b2_addState",t[t.b2_persistState=2]="b2_persistState",t[t.b2_removeState=3]="b2_removeState"}(wc||(wc={}));class Vc{constructor(){this.v=new Yh,this.id=new Cc}static MakeArray(t){return Fh(t,(t=>new Vc))}Copy(t){return this.v.Copy(t.v),this.id.Copy(t.id),this}}class Tc{constructor(){this.p1=new Yh,this.p2=new Yh,this.maxFraction=1}Copy(t){return this.p1.Copy(t.p1),this.p2.Copy(t.p2),this.maxFraction=t.maxFraction,this}}class Pc{constructor(){this.normal=new Yh,this.fraction=0}Copy(t){return this.normal.Copy(t.normal),this.fraction=t.fraction,this}}class Dc{constructor(){this.lowerBound=new Yh,this.upperBound=new Yh,this.m_cache_center=new Yh,this.m_cache_extent=new Yh}Copy(t){return this.lowerBound.Copy(t.lowerBound),this.upperBound.Copy(t.upperBound),this}IsValid(){return!(!this.lowerBound.IsValid()||!this.upperBound.IsValid()||this.upperBound.x<this.lowerBound.x||this.upperBound.y<this.lowerBound.y)}GetCenter(){return Yh.MidVV(this.lowerBound,this.upperBound,this.m_cache_center)}GetExtents(){return Yh.ExtVV(this.lowerBound,this.upperBound,this.m_cache_extent)}GetPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+(this.upperBound.y-this.lowerBound.y))}Combine1(t){return this.lowerBound.x=Uh(this.lowerBound.x,t.lowerBound.x),this.lowerBound.y=Uh(this.lowerBound.y,t.lowerBound.y),this.upperBound.x=Wh(this.upperBound.x,t.upperBound.x),this.upperBound.y=Wh(this.upperBound.y,t.upperBound.y),this}Combine2(t,e){return this.lowerBound.x=Uh(t.lowerBound.x,e.lowerBound.x),this.lowerBound.y=Uh(t.lowerBound.y,e.lowerBound.y),this.upperBound.x=Wh(t.upperBound.x,e.upperBound.x),this.upperBound.y=Wh(t.upperBound.y,e.upperBound.y),this}static Combine(t,e,i){return i.Combine2(t,e),i}Contains(t){let e=!0;return e=e&&this.lowerBound.x<=t.lowerBound.x,e=e&&this.lowerBound.y<=t.lowerBound.y,e=e&&t.upperBound.x<=this.upperBound.x,e=e&&t.upperBound.y<=this.upperBound.y,e}RayCast(t,e){let i=-Bh,s=Bh;const n=e.p1.x,r=e.p1.y,o=e.p2.x-e.p1.x,a=e.p2.y-e.p1.y,l=Nh(o),h=Nh(a),c=t.normal;if(l<Mh){if(n<this.lowerBound.x||this.upperBound.x<n)return!1}else{const t=1/o;let e=(this.lowerBound.x-n)*t,r=(this.upperBound.x-n)*t,a=-1;if(e>r){const t=e;e=r,r=t,a=1}if(e>i&&(c.x=a,c.y=0,i=e),s=Uh(s,r),i>s)return!1}if(h<Mh){if(r<this.lowerBound.y||this.upperBound.y<r)return!1}else{const t=1/a;let e=(this.lowerBound.y-r)*t,n=(this.upperBound.y-r)*t,o=-1;if(e>n){const t=e;e=n,n=t,o=1}if(e>i&&(c.x=0,c.y=o,i=e),s=Uh(s,n),i>s)return!1}return!(i<0||e.maxFraction<i||(t.fraction=i,0))}TestContain(t){return!(t.x<this.lowerBound.x||this.upperBound.x<t.x||t.y<this.lowerBound.y||this.upperBound.y<t.y)}TestOverlap(t){return!(this.upperBound.x<t.lowerBound.x||this.upperBound.y<t.lowerBound.y||t.upperBound.x<this.lowerBound.x||t.upperBound.y<this.lowerBound.y)}}function Ic(t,e){return!(t.upperBound.x<e.lowerBound.x||t.upperBound.y<e.lowerBound.y||e.upperBound.x<t.lowerBound.x||e.upperBound.y<t.lowerBound.y)}function Ec(t,e,i,s,n){let r=0;const o=e[0],a=e[1],l=Yh.DotVV(i,o.v)-s,h=Yh.DotVV(i,a.v)-s;if(l<=0&&t[r++].Copy(o),h<=0&&t[r++].Copy(a),l*h<0){const e=l/(l-h),i=t[r].v;i.x=o.v.x+e*(a.v.x-o.v.x),i.y=o.v.y+e*(a.v.y-o.v.y);const s=t[r].id;s.cf.indexA=n,s.cf.indexB=o.id.cf.indexB,s.cf.typeA=vc.e_vertex,s.cf.typeB=vc.e_face,++r}return r}const Rc=new oc,Lc=new rc,Gc=new ac;function Fc(t,e,i,s,n,r){const o=Rc.Reset();o.proxyA.SetShape(t,e),o.proxyB.SetShape(i,s),o.transformA.Copy(n),o.transformB.Copy(r),o.useRadii=!0;const a=Lc.Reset();a.count=0;const l=Gc.Reset();return xc(l,a,o),l.distance<1e-4}function kc(t){if(null===t)throw new Error;return t}class zc{constructor(t=0){this.m_id=0,this.aabb=new Dc,this._userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=0,this.moved=!1,this.m_id=t}get userData(){if(null===this._userData)throw new Error;return this._userData}set userData(t){if(null!==this._userData)throw new Error;this._userData=t}Reset(){this._userData=null}IsLeaf(){return null===this.child1}}class Oc{constructor(){this.m_root=null,this.m_freeList=null,this.m_insertionCount=0,this.m_stack=new zh(256)}Query(t,e){const i=this.m_stack.Reset();for(i.Push(this.m_root);i.GetCount()>0;){const s=i.Pop();if(null!==s&&s.aabb.TestOverlap(t))if(s.IsLeaf()){if(!e(s))return}else i.Push(s.child1),i.Push(s.child2)}}QueryPoint(t,e){const i=this.m_stack.Reset();for(i.Push(this.m_root);i.GetCount()>0;){const s=i.Pop();if(null!==s&&s.aabb.TestContain(t))if(s.IsLeaf()){if(!e(s))return}else i.Push(s.child1),i.Push(s.child2)}}RayCast(t,e){const i=t.p1,s=t.p2,n=Yh.SubVV(s,i,Oc.s_r);n.Normalize();const r=Yh.CrossOneV(n,Oc.s_v),o=Yh.AbsV(r,Oc.s_abs_v);let a=t.maxFraction;const l=Oc.s_segmentAABB;let h=i.x+a*(s.x-i.x),c=i.y+a*(s.y-i.y);l.lowerBound.x=Uh(i.x,h),l.lowerBound.y=Uh(i.y,c),l.upperBound.x=Wh(i.x,h),l.upperBound.y=Wh(i.y,c);const m=this.m_stack.Reset();for(m.Push(this.m_root);m.GetCount()>0;){const n=m.Pop();if(null===n)continue;if(!Ic(n.aabb,l))continue;const u=n.aabb.GetCenter(),_=n.aabb.GetExtents();if(!(Nh(Yh.DotVV(r,Yh.SubVV(i,u,Yh.s_t0)))-Yh.DotVV(o,_)>0))if(n.IsLeaf()){const r=Oc.s_subInput;r.p1.Copy(t.p1),r.p2.Copy(t.p2),r.maxFraction=a;const o=e(r,n);if(0===o)return;o>0&&(a=o,h=i.x+a*(s.x-i.x),c=i.y+a*(s.y-i.y),l.lowerBound.x=Uh(i.x,h),l.lowerBound.y=Uh(i.y,c),l.upperBound.x=Wh(i.x,h),l.upperBound.y=Wh(i.y,c))}else m.Push(n.child1),m.Push(n.child2)}}AllocateNode(){if(null!==this.m_freeList){const t=this.m_freeList;return this.m_freeList=t.parent,t.parent=null,t.child1=null,t.child2=null,t.height=0,t.moved=!1,t}return new zc(Oc.s_node_id++)}FreeNode(t){t.parent=this.m_freeList,t.child1=null,t.child2=null,t.height=-1,t.Reset(),this.m_freeList=t}CreateProxy(t,e){const i=this.AllocateNode();return i.aabb.lowerBound.x=t.lowerBound.x-.1,i.aabb.lowerBound.y=t.lowerBound.y-.1,i.aabb.upperBound.x=t.upperBound.x+.1,i.aabb.upperBound.y=t.upperBound.y+.1,i.userData=e,i.height=0,i.moved=!0,this.InsertLeaf(i),i}DestroyProxy(t){this.RemoveLeaf(t),this.FreeNode(t)}MoveProxy(t,e,i){const s=Oc.MoveProxy_s_fatAABB;s.lowerBound.x=e.lowerBound.x-.1,s.lowerBound.y=e.lowerBound.y-.1,s.upperBound.x=e.upperBound.x+.1,s.upperBound.y=e.upperBound.y+.1;const n=4*i.x,r=4*i.y;n<0?s.lowerBound.x+=n:s.upperBound.x+=n,r<0?s.lowerBound.y+=r:s.upperBound.y+=r;const o=t.aabb;if(o.Contains(e)){const t=Oc.MoveProxy_s_hugeAABB;if(t.lowerBound.x=s.lowerBound.x-.4,t.lowerBound.y=s.lowerBound.y-.4,t.upperBound.x=s.upperBound.x+.4,t.upperBound.y=s.upperBound.y+.4,t.Contains(o))return!1}return this.RemoveLeaf(t),t.aabb.Copy(s),this.InsertLeaf(t),t.moved=!0,!0}InsertLeaf(t){if(++this.m_insertionCount,null===this.m_root)return this.m_root=t,void(this.m_root.parent=null);const e=t.aabb;let i=this.m_root;for(;!i.IsLeaf();){const t=kc(i.child1),s=kc(i.child2),n=i.aabb.GetPerimeter(),r=Oc.s_combinedAABB;r.Combine2(i.aabb,e);const o=r.GetPerimeter(),a=2*o,l=2*(o-n);let h;const c=Oc.s_aabb;let m,u,_;if(t.IsLeaf()?(c.Combine2(e,t.aabb),h=c.GetPerimeter()+l):(c.Combine2(e,t.aabb),m=t.aabb.GetPerimeter(),u=c.GetPerimeter(),h=u-m+l),s.IsLeaf()?(c.Combine2(e,s.aabb),_=c.GetPerimeter()+l):(c.Combine2(e,s.aabb),m=s.aabb.GetPerimeter(),u=c.GetPerimeter(),_=u-m+l),a<h&&a<_)break;i=h<_?t:s}const s=i.parent,n=this.AllocateNode();n.parent=s,n.aabb.Combine2(e,i.aabb),n.height=i.height+1,null!==s?(s.child1===i?s.child1=n:s.child2=n,n.child1=i,n.child2=t,i.parent=n,t.parent=n):(n.child1=i,n.child2=t,i.parent=n,t.parent=n,this.m_root=n);let r=t.parent;for(;null!==r;){r=this.Balance(r);const t=kc(r.child1),e=kc(r.child2);r.height=1+Wh(t.height,e.height),r.aabb.Combine2(t.aabb,e.aabb),r=r.parent}}RemoveLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=kc(t.parent),i=e&&e.parent,s=kc(e.child1===t?e.child2:e.child1);if(null!==i){i.child1===e?i.child1=s:i.child2=s,s.parent=i,this.FreeNode(e);let t=i;for(;null!==t;){t=this.Balance(t);const e=kc(t.child1),i=kc(t.child2);t.aabb.Combine2(e.aabb,i.aabb),t.height=1+Wh(e.height,i.height),t=t.parent}}else this.m_root=s,s.parent=null,this.FreeNode(e)}Balance(t){if(t.IsLeaf()||t.height<2)return t;const e=kc(t.child1),i=kc(t.child2),s=i.height-e.height;if(s>1){const s=kc(i.child1),n=kc(i.child2);return i.child1=t,i.parent=t.parent,t.parent=i,null!==i.parent?i.parent.child1===t?i.parent.child1=i:i.parent.child2=i:this.m_root=i,s.height>n.height?(i.child2=s,t.child2=n,n.parent=t,t.aabb.Combine2(e.aabb,n.aabb),i.aabb.Combine2(t.aabb,s.aabb),t.height=1+Wh(e.height,n.height),i.height=1+Wh(t.height,s.height)):(i.child2=n,t.child2=s,s.parent=t,t.aabb.Combine2(e.aabb,s.aabb),i.aabb.Combine2(t.aabb,n.aabb),t.height=1+Wh(e.height,s.height),i.height=1+Wh(t.height,n.height)),i}if(s<-1){const s=kc(e.child1),n=kc(e.child2);return e.child1=t,e.parent=t.parent,t.parent=e,null!==e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.m_root=e,s.height>n.height?(e.child2=s,t.child1=n,n.parent=t,t.aabb.Combine2(i.aabb,n.aabb),e.aabb.Combine2(t.aabb,s.aabb),t.height=1+Wh(i.height,n.height),e.height=1+Wh(t.height,s.height)):(e.child2=n,t.child1=s,s.parent=t,t.aabb.Combine2(i.aabb,s.aabb),e.aabb.Combine2(t.aabb,n.aabb),t.height=1+Wh(i.height,s.height),e.height=1+Wh(t.height,n.height)),e}return t}GetHeight(){return null===this.m_root?0:this.m_root.height}static GetAreaNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;let e=t.aabb.GetPerimeter();return e+=Oc.GetAreaNode(t.child1),e+=Oc.GetAreaNode(t.child2),e}GetAreaRatio(){if(null===this.m_root)return 0;const t=this.m_root.aabb.GetPerimeter();return Oc.GetAreaNode(this.m_root)/t}static ComputeHeightNode(t){return null===t||t.IsLeaf()?0:1+Wh(Oc.ComputeHeightNode(t.child1),Oc.ComputeHeightNode(t.child2))}ComputeHeight(){return Oc.ComputeHeightNode(this.m_root)}ValidateStructure(t){if(null===t)return;if(this.m_root,t.IsLeaf())return;const e=kc(t.child1),i=kc(t.child2);this.ValidateStructure(e),this.ValidateStructure(i)}ValidateMetrics(t){if(null===t)return;if(t.IsLeaf())return;const e=kc(t.child1),i=kc(t.child2);Oc.s_aabb.Combine2(e.aabb,i.aabb),this.ValidateMetrics(e),this.ValidateMetrics(i)}Validate(){}static GetMaxBalanceNode(t,e){if(null===t)return e;if(t.height<=1)return e;const i=kc(t.child1),s=kc(t.child2);return Wh(e,Nh(s.height-i.height))}GetMaxBalance(){return Oc.GetMaxBalanceNode(this.m_root,0)}RebuildBottomUp(){this.Validate()}static ShiftOriginNode(t,e){if(null===t)return;if(t.height<=1)return;const i=t.child1,s=t.child2;Oc.ShiftOriginNode(i,e),Oc.ShiftOriginNode(s,e),t.aabb.lowerBound.SelfSub(e),t.aabb.upperBound.SelfSub(e)}ShiftOrigin(t){Oc.ShiftOriginNode(this.m_root,t)}}Oc.s_r=new Yh,Oc.s_v=new Yh,Oc.s_abs_v=new Yh,Oc.s_segmentAABB=new Dc,Oc.s_subInput=new Tc,Oc.s_combinedAABB=new Dc,Oc.s_aabb=new Dc,Oc.s_node_id=0,Oc.MoveProxy_s_fatAABB=new Dc,Oc.MoveProxy_s_hugeAABB=new Dc;class Nc{constructor(t,e){this.proxyA=t,this.proxyB=e}}class Uc{constructor(){this.m_tree=new Oc,this.m_proxyCount=0,this.m_moveCount=0,this.m_moveBuffer=[],this.m_pairCount=0,this.m_pairBuffer=[]}CreateProxy(t,e){const i=this.m_tree.CreateProxy(t,e);return++this.m_proxyCount,this.BufferMove(i),i}DestroyProxy(t){this.UnBufferMove(t),--this.m_proxyCount,this.m_tree.DestroyProxy(t)}MoveProxy(t,e,i){this.m_tree.MoveProxy(t,e,i)&&this.BufferMove(t)}TouchProxy(t){this.BufferMove(t)}GetProxyCount(){return this.m_proxyCount}UpdatePairs(t){this.m_pairCount=0;for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];if(null===e)continue;const i=e.aabb;this.m_tree.Query(i,(t=>{if(t.m_id===e.m_id)return!0;if(t.moved&&t.m_id>e.m_id)return!0;let i,s;if(t.m_id<e.m_id?(i=t,s=e):(i=e,s=t),this.m_pairCount===this.m_pairBuffer.length)this.m_pairBuffer[this.m_pairCount]=new Nc(i,s);else{const t=this.m_pairBuffer[this.m_pairCount];t.proxyA=i,t.proxyB=s}return++this.m_pairCount,!0}))}for(let e=0;e<this.m_pairCount;++e){const i=this.m_pairBuffer[e];t(i.proxyA.userData,i.proxyB.userData)}for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];null!==e&&(e.moved=!1)}this.m_moveCount=0}Query(t,e){this.m_tree.Query(t,e)}QueryPoint(t,e){this.m_tree.QueryPoint(t,e)}RayCast(t,e){this.m_tree.RayCast(t,e)}GetTreeHeight(){return this.m_tree.GetHeight()}GetTreeBalance(){return this.m_tree.GetMaxBalance()}GetTreeQuality(){return this.m_tree.GetAreaRatio()}ShiftOrigin(t){this.m_tree.ShiftOrigin(t)}BufferMove(t){this.m_moveBuffer[this.m_moveCount]=t,++this.m_moveCount}UnBufferMove(t){for(let e=0;e<this.m_moveCount;++e)this.m_moveBuffer[e]===t&&(this.m_moveBuffer[e]=null)}}class Wc{constructor(){this.mass=0,this.center=new Yh(0,0),this.I=0}}var jc;!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circleShape=0]="e_circleShape",t[t.e_edgeShape=1]="e_edgeShape",t[t.e_polygonShape=2]="e_polygonShape",t[t.e_chainShape=3]="e_chainShape",t[t.e_shapeTypeCount=4]="e_shapeTypeCount"}(jc||(jc={}));class Hc{constructor(t,e){this.m_type=jc.e_unknown,this.m_radius=0,this.m_type=t,this.m_radius=e}Copy(t){return this.m_radius=t.m_radius,this}GetType(){return this.m_type}}class qc extends Hc{constructor(){super(jc.e_edgeShape,Ih),this.m_vertex1=new Yh,this.m_vertex2=new Yh,this.m_vertex0=new Yh,this.m_vertex3=new Yh,this.m_oneSided=!1}SetOneSided(t,e,i,s){return this.m_vertex0.Copy(t),this.m_vertex1.Copy(e),this.m_vertex2.Copy(i),this.m_vertex3.Copy(s),this.m_oneSided=!0,this}SetTwoSided(t,e){return this.m_vertex1.Copy(t),this.m_vertex2.Copy(e),this.m_oneSided=!1,this}Clone(){return(new qc).Copy(this)}Copy(t){return super.Copy(t),this.m_vertex1.Copy(t.m_vertex1),this.m_vertex2.Copy(t.m_vertex2),this.m_vertex0.Copy(t.m_vertex0),this.m_vertex3.Copy(t.m_vertex3),this.m_oneSided=t.m_oneSided,this}GetChildCount(){return 1}TestPoint(t,e){return!1}ComputeDistance(t,e,i,s){const n=ic.MulXV(t,this.m_vertex1,qc.ComputeDistance_s_v1),r=ic.MulXV(t,this.m_vertex2,qc.ComputeDistance_s_v2),o=Yh.SubVV(e,n,qc.ComputeDistance_s_d),a=Yh.SubVV(r,n,qc.ComputeDistance_s_s),l=Yh.DotVV(o,a);if(l>0){const t=Yh.DotVV(a,a);l>t?Yh.SubVV(e,r,o):o.SelfMulSub(l/t,a)}return i.Copy(o),i.Normalize()}RayCast(t,e,i,s){const n=ic.MulTXV(i,e.p1,qc.RayCast_s_p1),r=ic.MulTXV(i,e.p2,qc.RayCast_s_p2),o=Yh.SubVV(r,n,qc.RayCast_s_d),a=this.m_vertex1,l=this.m_vertex2,h=Yh.SubVV(l,a,qc.RayCast_s_e),c=t.normal.Set(h.y,-h.x).SelfNormalize(),m=Yh.DotVV(c,Yh.SubVV(a,n,Yh.s_t0));if(this.m_oneSided&&m>0)return!1;const u=Yh.DotVV(c,o);if(0===u)return!1;const _=m/u;if(_<0||e.maxFraction<_)return!1;const d=Yh.AddVMulSV(n,_,o,qc.RayCast_s_q),p=Yh.SubVV(l,a,qc.RayCast_s_r),f=Yh.DotVV(p,p);if(0===f)return!1;const y=Yh.DotVV(Yh.SubVV(d,a,Yh.s_t0),p)/f;return!(y<0||1<y||(t.fraction=_,ec.MulRV(i.q,t.normal,t.normal),m>0&&t.normal.SelfNeg(),0))}ComputeAABB(t,e,i){const s=ic.MulXV(e,this.m_vertex1,qc.ComputeAABB_s_v1),n=ic.MulXV(e,this.m_vertex2,qc.ComputeAABB_s_v2);Yh.MinV(s,n,t.lowerBound),Yh.MaxV(s,n,t.upperBound);const r=this.m_radius;t.lowerBound.SelfSubXY(r,r),t.upperBound.SelfAddXY(r,r)}ComputeMass(t,e){t.mass=0,Yh.MidVV(this.m_vertex1,this.m_vertex2,t.center),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertex1),t.m_vertices[1].Copy(this.m_vertex2),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){return s.SetZero(),0}Dump(t){t("    const shape: b2EdgeShape = new b2EdgeShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_vertex0.Set(%.15f, %.15f);\n",this.m_vertex0.x,this.m_vertex0.y),t("    shape.m_vertex1.Set(%.15f, %.15f);\n",this.m_vertex1.x,this.m_vertex1.y),t("    shape.m_vertex2.Set(%.15f, %.15f);\n",this.m_vertex2.x,this.m_vertex2.y),t("    shape.m_vertex3.Set(%.15f, %.15f);\n",this.m_vertex3.x,this.m_vertex3.y),t("    shape.m_oneSided = %s;\n",this.m_oneSided)}}qc.ComputeDistance_s_v1=new Yh,qc.ComputeDistance_s_v2=new Yh,qc.ComputeDistance_s_d=new Yh,qc.ComputeDistance_s_s=new Yh,qc.RayCast_s_p1=new Yh,qc.RayCast_s_p2=new Yh,qc.RayCast_s_d=new Yh,qc.RayCast_s_e=new Yh,qc.RayCast_s_q=new Yh,qc.RayCast_s_r=new Yh,qc.ComputeAABB_s_v1=new Yh,qc.ComputeAABB_s_v2=new Yh;class Xc extends Hc{constructor(){super(jc.e_chainShape,Ih),this.m_vertices=[],this.m_count=0,this.m_prevVertex=new Yh,this.m_nextVertex=new Yh}CreateLoop(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._CreateLoop((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2)}{const e=t[0];return this._CreateLoop((t=>e[t]),e.length)}}_CreateLoop(t,e){if(e<3)return this;this.m_count=e+1,this.m_vertices=Yh.MakeArray(this.m_count);for(let i=0;i<e;++i)this.m_vertices[i].Copy(t(i));return this.m_vertices[e].Copy(this.m_vertices[0]),this.m_prevVertex.Copy(this.m_vertices[this.m_count-2]),this.m_nextVertex.Copy(this.m_vertices[1]),this}CreateChain(...t){if("number"==typeof t[0][0]){const e=t[0],i=t[1],s=t[2];if(e.length%2!=0)throw new Error;return this._CreateChain((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2,i,s)}{const e=t[0],i=t[1],s=t[2];return this._CreateChain((t=>e[t]),e.length,i,s)}}_CreateChain(t,e,i,s){this.m_count=e,this.m_vertices=Yh.MakeArray(e);for(let i=0;i<e;++i)this.m_vertices[i].Copy(t(i));return this.m_prevVertex.Copy(i),this.m_nextVertex.Copy(s),this}Clone(){return(new Xc).Copy(this)}Copy(t){return super.Copy(t),this._CreateChain((e=>t.m_vertices[e]),t.m_count,t.m_prevVertex,t.m_nextVertex),this.m_prevVertex.Copy(t.m_prevVertex),this.m_nextVertex.Copy(t.m_nextVertex),this}GetChildCount(){return this.m_count-1}GetChildEdge(t,e){t.m_radius=this.m_radius,t.m_vertex1.Copy(this.m_vertices[e]),t.m_vertex2.Copy(this.m_vertices[e+1]),t.m_oneSided=!0,e>0?t.m_vertex0.Copy(this.m_vertices[e-1]):t.m_vertex0.Copy(this.m_prevVertex),e<this.m_count-2?t.m_vertex3.Copy(this.m_vertices[e+2]):t.m_vertex3.Copy(this.m_nextVertex)}TestPoint(t,e){return!1}ComputeDistance(t,e,i,s){const n=Xc.ComputeDistance_s_edgeShape;return this.GetChildEdge(n,s),n.ComputeDistance(t,e,i,0)}RayCast(t,e,i,s){const n=Xc.RayCast_s_edgeShape;return n.m_vertex1.Copy(this.m_vertices[s]),n.m_vertex2.Copy(this.m_vertices[(s+1)%this.m_count]),n.RayCast(t,e,i,0)}ComputeAABB(t,e,i){const s=this.m_vertices[i],n=this.m_vertices[(i+1)%this.m_count],r=ic.MulXV(e,s,Xc.ComputeAABB_s_v1),o=ic.MulXV(e,n,Xc.ComputeAABB_s_v2),a=Yh.MinV(r,o,Xc.ComputeAABB_s_lower),l=Yh.MaxV(r,o,Xc.ComputeAABB_s_upper);t.lowerBound.x=a.x-this.m_radius,t.lowerBound.y=a.y-this.m_radius,t.upperBound.x=l.x+this.m_radius,t.upperBound.y=l.y+this.m_radius}ComputeMass(t,e){t.mass=0,t.center.SetZero(),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertices[e]),e+1<this.m_count?t.m_vertices[1].Copy(this.m_vertices[e+1]):t.m_vertices[1].Copy(this.m_vertices[0]),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){return s.SetZero(),0}Dump(t){t("    const shape: b2ChainShape = new b2ChainShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new bVec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.CreateChain(vs, %d);\n",this.m_count),t("    shape.m_prevVertex.Set(%.15f, %.15f);\n",this.m_prevVertex.x,this.m_prevVertex.y),t("    shape.m_nextVertex.Set(%.15f, %.15f);\n",this.m_nextVertex.x,this.m_nextVertex.y)}}Xc.ComputeDistance_s_edgeShape=new qc,Xc.RayCast_s_edgeShape=new qc,Xc.ComputeAABB_s_v1=new Yh,Xc.ComputeAABB_s_v2=new Yh,Xc.ComputeAABB_s_lower=new Yh,Xc.ComputeAABB_s_upper=new Yh;class Jc extends Hc{constructor(t=0){super(jc.e_circleShape,t),this.m_p=new Yh}Set(t,e=this.m_radius){return this.m_p.Copy(t),this.m_radius=e,this}Clone(){return(new Jc).Copy(this)}Copy(t){return super.Copy(t),this.m_p.Copy(t.m_p),this}GetChildCount(){return 1}TestPoint(t,e){const i=ic.MulXV(t,this.m_p,Jc.TestPoint_s_center),s=Yh.SubVV(e,i,Jc.TestPoint_s_d);return Yh.DotVV(s,s)<=Hh(this.m_radius)}ComputeDistance(t,e,i,s){const n=ic.MulXV(t,this.m_p,Jc.ComputeDistance_s_center);return Yh.SubVV(e,n,i),i.Normalize()-this.m_radius}RayCast(t,e,i,s){const n=ic.MulXV(i,this.m_p,Jc.RayCast_s_position),r=Yh.SubVV(e.p1,n,Jc.RayCast_s_s),o=Yh.DotVV(r,r)-Hh(this.m_radius),a=Yh.SubVV(e.p2,e.p1,Jc.RayCast_s_r),l=Yh.DotVV(r,a),h=Yh.DotVV(a,a),c=l*l-h*o;if(c<0||h<Mh)return!1;let m=-(l+Xh(c));return 0<=m&&m<=e.maxFraction*h&&(m/=h,t.fraction=m,Yh.AddVMulSV(r,m,a,t.normal).SelfNormalize(),!0)}ComputeAABB(t,e,i){const s=ic.MulXV(e,this.m_p,Jc.ComputeAABB_s_p);t.lowerBound.Set(s.x-this.m_radius,s.y-this.m_radius),t.upperBound.Set(s.x+this.m_radius,s.y+this.m_radius)}ComputeMass(t,e){const i=Hh(this.m_radius);t.mass=e*Th*i,t.center.Copy(this.m_p),t.I=t.mass*(.5*i+Yh.DotVV(this.m_p,this.m_p))}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_p),t.m_count=1,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){const n=ic.MulXV(i,this.m_p,new Yh),r=-(Yh.DotVV(t,n)-e);if(r<-this.m_radius+Mh)return 0;if(r>this.m_radius)return s.Copy(n),Th*this.m_radius*this.m_radius;const o=this.m_radius*this.m_radius,a=r*r,l=o*(Zh(r/this.m_radius)+1.570796326795)+r*Xh(o-a),h=-2/3*Jh(o-a,1.5)/l;return s.x=n.x+t.x*h,s.y=n.y+t.y*h,l}Dump(t){t("    const shape: b2CircleShape = new b2CircleShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_p.Set(%.15f, %.15f);\n",this.m_p.x,this.m_p.y)}}Jc.TestPoint_s_center=new Yh,Jc.TestPoint_s_d=new Yh,Jc.ComputeDistance_s_center=new Yh,Jc.RayCast_s_position=new Yh,Jc.RayCast_s_s=new Yh,Jc.RayCast_s_r=new Yh,Jc.ComputeAABB_s_p=new Yh;const Zc=new Yh,Yc=new Yh,Qc=new Yh,Kc=new Yh,$c=new Yh,tm=new Yh,em=new Yh,im=new Yh,sm=new Yh,nm=new Yh,rm=new Yh,om=new Yh,am=new Cc;function lm(t,e,i,s,n){t.pointCount=0;const r=ic.MulTXV(i,ic.MulXV(n,s.m_p,Yh.s_t0),tm),o=e.m_vertex1,a=e.m_vertex2,l=Yh.SubVV(a,o,em),h=om.Set(l.y,-l.x),c=Yh.DotVV(h,Yh.SubVV(r,o,Yh.s_t0));if(e.m_oneSided&&c<0)return;const m=Yh.DotVV(l,Yh.SubVV(a,r,Yh.s_t0)),u=Yh.DotVV(l,Yh.SubVV(r,o,Yh.s_t0)),_=e.m_radius+s.m_radius,d=am;if(d.cf.indexB=0,d.cf.typeB=vc.e_vertex,u<=0){const i=o,n=Yh.SubVV(r,i,im);if(Yh.DotVV(n,n)>_*_)return;if(e.m_oneSided){const t=e.m_vertex0,i=o,s=Yh.SubVV(i,t,sm);if(Yh.DotVV(s,Yh.SubVV(i,r,Yh.s_t0))>0)return}return d.cf.indexA=0,d.cf.typeA=vc.e_vertex,t.pointCount=1,t.type=Sc.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(i),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(s.m_p)}if(m<=0){const i=a,n=Yh.SubVV(r,i,im);if(Yh.DotVV(n,n)>_*_)return;if(e.m_oneSided){const t=e.m_vertex3,i=a,s=Yh.SubVV(t,i,nm);if(Yh.DotVV(s,Yh.SubVV(r,i,Yh.s_t0))>0)return}return d.cf.indexA=1,d.cf.typeA=vc.e_vertex,t.pointCount=1,t.type=Sc.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(i),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(s.m_p)}const p=Yh.DotVV(l,l),f=rm;f.x=1/p*(m*o.x+u*a.x),f.y=1/p*(m*o.y+u*a.y);const y=Yh.SubVV(r,f,im);Yh.DotVV(y,y)>_*_||(c<0&&h.Set(-h.x,-h.y),h.Normalize(),d.cf.indexA=0,d.cf.typeA=vc.e_face,t.pointCount=1,t.type=Sc.e_faceA,t.localNormal.Copy(h),t.localPoint.Copy(o),t.points[0].id.Copy(d),t.points[0].localPoint.Copy(s.m_p))}var hm;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(hm||(hm={}));class cm{constructor(){this.normal=new Yh,this.type=hm.e_unknown,this.index=0,this.separation=0}}const mm=new cm,um=[new Yh,new Yh],_m=new cm,dm=new Yh,pm=new ic,fm=new Yh,ym=new Yh,gm=new Yh,xm=new Yh,vm=new Yh,Sm=new Yh,wm=new Yh,bm=new class{constructor(){this.vertices=[],this.normals=[],this.count=0}},Cm=new class{constructor(){this.i1=0,this.i2=0,this.v1=new Yh,this.v2=new Yh,this.normal=new Yh,this.sideNormal1=new Yh,this.sideOffset1=0,this.sideNormal2=new Yh,this.sideOffset2=0}},Am=[new Vc,new Vc],Bm=[new Vc,new Vc],Mm=[new Vc,new Vc];function Vm(t,e,i,s,n){t.pointCount=0;const r=ic.MulTXX(i,n,pm),o=ic.MulXV(r,s.m_centroid,fm),a=e.m_vertex1,l=e.m_vertex2,h=Yh.SubVV(l,a,ym);h.Normalize();const c=gm.Set(h.y,-h.x),m=Yh.DotVV(c,Yh.SubVV(o,a,Yh.s_t0)),u=e.m_oneSided;if(u&&m<0)return;const _=bm;_.count=s.m_count;for(let t=0;t<s.m_count;++t)_.vertices.length<=t&&_.vertices.push(new Yh),_.normals.length<=t&&_.normals.push(new Yh),ic.MulXV(r,s.m_vertices[t],_.vertices[t]),ec.MulRV(r.q,s.m_normals[t],_.normals[t]);const d=s.m_radius+e.m_radius,p=function(t,e,i){const s=mm;s.type=hm.e_edgeA,s.index=-1,s.separation=-Number.MAX_VALUE,s.normal.SetZero();const n=um;n[0].Copy(i),n[1].Copy(i).SelfNeg();for(let i=0;i<2;++i){let r=Number.MAX_VALUE;for(let s=0;s<t.count;++s){const o=Yh.DotVV(n[i],Yh.SubVV(t.vertices[s],e,Yh.s_t0));o<r&&(r=o)}r>s.separation&&(s.index=i,s.separation=r,s.normal.Copy(n[i]))}return s}(_,a,c);if(p.separation>d)return;const f=function(t,e,i){const s=_m;s.type=hm.e_unknown,s.index=-1,s.separation=-Number.MAX_VALUE,s.normal.SetZero();for(let n=0;n<t.count;++n){const r=Yh.NegV(t.normals[n],dm),o=Uh(Yh.DotVV(r,Yh.SubVV(t.vertices[n],e,Yh.s_t0)),Yh.DotVV(r,Yh.SubVV(t.vertices[n],i,Yh.s_t0)));o>s.separation&&(s.type=hm.e_edgeB,s.index=n,s.separation=o,s.normal.Copy(r))}return s}(_,a,l);if(f.separation>d)return;let y;if(y=f.separation-d>.98*(p.separation-d)+.001?f:p,u){const t=Yh.SubVV(a,e.m_vertex0,xm);t.Normalize();const i=vm.Set(t.y,-t.x),s=Yh.CrossVV(t,h)>=0,n=Yh.SubVV(e.m_vertex3,l,Sm);n.Normalize();const r=wm.Set(n.y,-n.x),o=Yh.CrossVV(h,n)>=0,c=.1;if(Yh.DotVV(y.normal,h)<=0)if(s){if(Yh.CrossVV(y.normal,i)>c)return}else y=p;else if(o){if(Yh.CrossVV(r,y.normal)>c)return}else y=p}const g=Am,x=Cm;if(y.type===hm.e_edgeA){t.type=Sc.e_faceA;let e=0,i=Yh.DotVV(y.normal,_.normals[0]);for(let t=1;t<_.count;++t){const s=Yh.DotVV(y.normal,_.normals[t]);s<i&&(i=s,e=t)}const s=e,n=s+1<_.count?s+1:0;g[0].v.Copy(_.vertices[s]),g[0].id.cf.indexA=0,g[0].id.cf.indexB=s,g[0].id.cf.typeA=vc.e_face,g[0].id.cf.typeB=vc.e_vertex,g[1].v.Copy(_.vertices[n]),g[1].id.cf.indexA=0,g[1].id.cf.indexB=n,g[1].id.cf.typeA=vc.e_face,g[1].id.cf.typeB=vc.e_vertex,x.i1=0,x.i2=1,x.v1.Copy(a),x.v2.Copy(l),x.normal.Copy(y.normal),x.sideNormal1.Copy(h).SelfNeg(),x.sideNormal2.Copy(h)}else t.type=Sc.e_faceB,g[0].v.Copy(l),g[0].id.cf.indexA=1,g[0].id.cf.indexB=y.index,g[0].id.cf.typeA=vc.e_vertex,g[0].id.cf.typeB=vc.e_face,g[1].v.Copy(a),g[1].id.cf.indexA=0,g[1].id.cf.indexB=y.index,g[1].id.cf.typeA=vc.e_vertex,g[1].id.cf.typeB=vc.e_face,x.i1=y.index,x.i2=x.i1+1<_.count?x.i1+1:0,x.v1.Copy(_.vertices[x.i1]),x.v2.Copy(_.vertices[x.i2]),x.normal.Copy(_.normals[x.i1]),x.sideNormal1.Set(x.normal.y,-x.normal.x),x.sideNormal2.Copy(x.sideNormal1).SelfNeg();x.sideOffset1=Yh.DotVV(x.sideNormal1,x.v1),x.sideOffset2=Yh.DotVV(x.sideNormal2,x.v2);const v=Bm,S=Mm;let w;if(w=Ec(v,g,x.sideNormal1,x.sideOffset1,x.i1),w<2)return;if(w=Ec(S,v,x.sideNormal2,x.sideOffset2,x.i2),w<2)return;y.type===hm.e_edgeA?(t.localNormal.Copy(x.normal),t.localPoint.Copy(x.v1)):(t.localNormal.Copy(s.m_normals[x.i1]),t.localPoint.Copy(s.m_vertices[x.i1]));let b=0;for(let e=0;e<2;++e)if(Yh.DotVV(x.normal,Yh.SubVV(S[e].v,x.v1,Yh.s_t0))<=d){const i=t.points[b];y.type===hm.e_edgeA?(ic.MulTXV(r,S[e].v,i.localPoint),i.id.Copy(S[e].id)):(i.localPoint.Copy(S[e].v),i.id.cf.typeA=S[e].id.cf.typeB,i.id.cf.typeB=S[e].id.cf.typeA,i.id.cf.indexA=S[e].id.cf.indexB,i.id.cf.indexB=S[e].id.cf.indexA),++b}t.pointCount=b}const Tm=new ic,Pm=new Yh,Dm=new Yh;function Im(t,e,i,s,n){const r=e.m_count,o=s.m_count,a=e.m_normals,l=e.m_vertices,h=s.m_vertices,c=ic.MulTXX(n,i,Tm);let m=0,u=-Bh;for(let t=0;t<r;++t){const e=ec.MulRV(c.q,a[t],Pm),i=ic.MulXV(c,l[t],Dm);let s=Bh;for(let t=0;t<o;++t){const n=Yh.DotVV(e,Yh.SubVV(h[t],i,Yh.s_t0));n<s&&(s=n)}s>u&&(u=s,m=t)}return t[0]=m,u}const Em=new Yh,Rm=[new Vc,new Vc],Lm=[new Vc,new Vc],Gm=[new Vc,new Vc],Fm=[0],km=[0],zm=new Yh,Om=new Yh,Nm=new Yh,Um=new Yh,Wm=new Yh,jm=new Yh,Hm=new Yh,qm=new Yh;class Xm extends Hc{constructor(){super(jc.e_polygonShape,Ih),this.m_centroid=new Yh(0,0),this.m_vertices=[],this.m_normals=[],this.m_count=0}Clone(){return(new Xm).Copy(this)}Copy(t){super.Copy(t),this.m_centroid.Copy(t.m_centroid),this.m_count=t.m_count,this.m_vertices=Yh.MakeArray(this.m_count),this.m_normals=Yh.MakeArray(this.m_count);for(let e=0;e<this.m_count;++e)this.m_vertices[e].Copy(t.m_vertices[e]),this.m_normals[e].Copy(t.m_normals[e]);return this}GetChildCount(){return 1}Set(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._Set((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2)}{const e=t[0],i=t[1]||e.length;return this._Set((t=>e[t]),i)}}_Set(t,e){if(e<3)return this.SetAsBox(1,1);let i=e;const s=[];for(let e=0;e<i;++e){const i=t(e);let n=!0;for(let t=0;t<s.length;++t)if(Yh.DistanceSquaredVV(i,s[t])<625e-8){n=!1;break}n&&s.push(i)}if(i=s.length,i<3)return this.SetAsBox(1,1);let n=0,r=s[0].x;for(let t=1;t<i;++t){const e=s[t].x;(e>r||e===r&&s[t].y<s[n].y)&&(n=t,r=e)}const o=[];let a=0,l=n;for(;;){o[a]=l;let t=0;for(let e=1;e<i;++e){if(t===l){t=e;continue}const i=Yh.SubVV(s[t],s[o[a]],Xm.Set_s_r),n=Yh.SubVV(s[e],s[o[a]],Xm.Set_s_v),r=Yh.CrossVV(i,n);r<0&&(t=e),0===r&&n.LengthSquared()>i.LengthSquared()&&(t=e)}if(++a,l=t,t===n)break}this.m_count=a,this.m_vertices=Yh.MakeArray(this.m_count),this.m_normals=Yh.MakeArray(this.m_count);for(let t=0;t<a;++t)this.m_vertices[t].Copy(s[o[t]]);for(let t=0;t<a;++t){const e=this.m_vertices[t],i=this.m_vertices[(t+1)%a],s=Yh.SubVV(i,e,Yh.s_t0);Yh.CrossVOne(s,this.m_normals[t]).SelfNormalize()}return Xm.ComputeCentroid(this.m_vertices,a,this.m_centroid),this}SetAsBox(t,e,i,s=0){if(this.m_count=4,this.m_vertices=Yh.MakeArray(this.m_count),this.m_normals=Yh.MakeArray(this.m_count),this.m_vertices[0].Set(-t,-e),this.m_vertices[1].Set(t,-e),this.m_vertices[2].Set(t,e),this.m_vertices[3].Set(-t,e),this.m_normals[0].Set(0,-1),this.m_normals[1].Set(1,0),this.m_normals[2].Set(0,1),this.m_normals[3].Set(-1,0),this.m_centroid.SetZero(),i){this.m_centroid.Copy(i);const t=new ic;t.SetPosition(i),t.SetRotationAngle(s);for(let e=0;e<this.m_count;++e)ic.MulXV(t,this.m_vertices[e],this.m_vertices[e]),ec.MulRV(t.q,this.m_normals[e],this.m_normals[e])}return this}TestPoint(t,e){const i=ic.MulTXV(t,e,Xm.TestPoint_s_pLocal);for(let t=0;t<this.m_count;++t)if(Yh.DotVV(this.m_normals[t],Yh.SubVV(i,this.m_vertices[t],Yh.s_t0))>0)return!1;return!0}ComputeDistance(t,e,i,s){const n=ic.MulTXV(t,e,Xm.ComputeDistance_s_pLocal);let r=-Bh;const o=Xm.ComputeDistance_s_normalForMaxDistance.Copy(n);for(let t=0;t<this.m_count;++t){const e=Yh.DotVV(this.m_normals[t],Yh.SubVV(n,this.m_vertices[t],Yh.s_t0));e>r&&(r=e,o.Copy(this.m_normals[t]))}if(r>0){const e=Xm.ComputeDistance_s_minDistance.Copy(o);let s=r*r;for(let t=0;t<this.m_count;++t){const i=Yh.SubVV(n,this.m_vertices[t],Xm.ComputeDistance_s_distance),r=i.LengthSquared();s>r&&(e.Copy(i),s=r)}return ec.MulRV(t.q,e,i),i.Normalize(),Math.sqrt(s)}return ec.MulRV(t.q,o,i),r}RayCast(t,e,i,s){const n=ic.MulTXV(i,e.p1,Xm.RayCast_s_p1),r=ic.MulTXV(i,e.p2,Xm.RayCast_s_p2),o=Yh.SubVV(r,n,Xm.RayCast_s_d);let a=0,l=e.maxFraction,h=-1;for(let t=0;t<this.m_count;++t){const e=Yh.DotVV(this.m_normals[t],Yh.SubVV(this.m_vertices[t],n,Yh.s_t0)),i=Yh.DotVV(this.m_normals[t],o);if(0===i){if(e<0)return!1}else i<0&&e<a*i?(a=e/i,h=t):i>0&&e<l*i&&(l=e/i);if(l<a)return!1}return h>=0&&(t.fraction=a,ec.MulRV(i.q,this.m_normals[h],t.normal),!0)}ComputeAABB(t,e,i){const s=ic.MulXV(e,this.m_vertices[0],t.lowerBound),n=t.upperBound.Copy(s);for(let t=0;t<this.m_count;++t){const i=ic.MulXV(e,this.m_vertices[t],Xm.ComputeAABB_s_v);Yh.MinV(i,s,s),Yh.MaxV(i,n,n)}const r=this.m_radius;s.SelfSubXY(r,r),n.SelfAddXY(r,r)}ComputeMass(t,e){const i=Xm.ComputeMass_s_center.SetZero();let s=0,n=0;const r=Xm.ComputeMass_s_s.Copy(this.m_vertices[0]),o=1/3;for(let t=0;t<this.m_count;++t){const e=Yh.SubVV(this.m_vertices[t],r,Xm.ComputeMass_s_e1),a=Yh.SubVV(this.m_vertices[(t+1)%this.m_count],r,Xm.ComputeMass_s_e2),l=Yh.CrossVV(e,a),h=.5*l;s+=h,i.SelfAdd(Yh.MulSV(h*o,Yh.AddVV(e,a,Yh.s_t0),Yh.s_t1));const c=e.x,m=e.y,u=a.x,_=a.y;n+=.25*o*l*(c*c+u*c+u*u+(m*m+_*m+_*_))}t.mass=e*s,i.SelfMul(1/s),Yh.AddVV(i,r,t.center),t.I=e*n,t.I+=t.mass*(Yh.DotVV(t.center,t.center)-Yh.DotVV(i,i))}Validate(){for(let t=0;t<this.m_count;++t){const e=t,i=(t+1)%this.m_count,s=this.m_vertices[e],n=Yh.SubVV(this.m_vertices[i],s,Xm.Validate_s_e);for(let t=0;t<this.m_count;++t){if(t===e||t===i)continue;const r=Yh.SubVV(this.m_vertices[t],s,Xm.Validate_s_v);if(Yh.CrossVV(n,r)<0)return!1}}return!0}SetupDistanceProxy(t,e){t.m_vertices=this.m_vertices,t.m_count=this.m_count,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){const n=ec.MulTRV(i.q,t,Xm.ComputeSubmergedArea_s_normalL),r=e-Yh.DotVV(t,i.p),o=[];let a=0,l=-1,h=-1,c=!1;for(let t=0;t<this.m_count;++t){o[t]=Yh.DotVV(n,this.m_vertices[t])-r;const e=o[t]<-1e-5;t>0&&(e?c||(l=t-1,a++):c&&(h=t-1,a++)),c=e}switch(a){case 0:if(c){const t=Xm.ComputeSubmergedArea_s_md;return this.ComputeMass(t,1),ic.MulXV(i,t.center,s),t.mass}return 0;case 1:-1===l?l=this.m_count-1:h=this.m_count-1}const m=(l+1)%this.m_count,u=(h+1)%this.m_count,_=(0-o[l])/(o[m]-o[l]),d=(0-o[h])/(o[u]-o[h]),p=Xm.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[l].x*(1-_)+this.m_vertices[m].x*_,this.m_vertices[l].y*(1-_)+this.m_vertices[m].y*_),f=Xm.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[h].x*(1-d)+this.m_vertices[u].x*d,this.m_vertices[h].y*(1-d)+this.m_vertices[u].y*d);let y=0;const g=Xm.ComputeSubmergedArea_s_center.SetZero();let x,v=this.m_vertices[m],S=m;for(;S!==u;){S=(S+1)%this.m_count,x=S===u?f:this.m_vertices[S];const t=.5*((v.x-p.x)*(x.y-p.y)-(v.y-p.y)*(x.x-p.x));y+=t,g.x+=t*(p.x+v.x+x.x)/3,g.y+=t*(p.y+v.y+x.y)/3,v=x}return g.SelfMul(1/y),ic.MulXV(i,g,s),y}Dump(t){t("    const shape: b2PolygonShape = new b2PolygonShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new b2Vec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.Set(vs, %d);\n",this.m_count)}static ComputeCentroid(t,e,i){const s=i;s.SetZero();let n=0;const r=Xm.ComputeCentroid_s_s.Copy(t[0]),o=1/3;for(let i=0;i<e;++i){const a=Yh.SubVV(t[0],r,Xm.ComputeCentroid_s_p1),l=Yh.SubVV(t[i],r,Xm.ComputeCentroid_s_p2),h=Yh.SubVV(t[(i+1)%e],r,Xm.ComputeCentroid_s_p3),c=Yh.SubVV(l,a,Xm.ComputeCentroid_s_e1),m=Yh.SubVV(h,a,Xm.ComputeCentroid_s_e2),u=.5*Yh.CrossVV(c,m);n+=u,s.x+=u*o*(a.x+l.x+h.x),s.y+=u*o*(a.y+l.y+h.y)}return s.x=1/n*s.x+r.x,s.y=1/n*s.y+r.y,s}}Xm.Set_s_r=new Yh,Xm.Set_s_v=new Yh,Xm.TestPoint_s_pLocal=new Yh,Xm.ComputeDistance_s_pLocal=new Yh,Xm.ComputeDistance_s_normalForMaxDistance=new Yh,Xm.ComputeDistance_s_minDistance=new Yh,Xm.ComputeDistance_s_distance=new Yh,Xm.RayCast_s_p1=new Yh,Xm.RayCast_s_p2=new Yh,Xm.RayCast_s_d=new Yh,Xm.ComputeAABB_s_v=new Yh,Xm.ComputeMass_s_center=new Yh,Xm.ComputeMass_s_s=new Yh,Xm.ComputeMass_s_e1=new Yh,Xm.ComputeMass_s_e2=new Yh,Xm.Validate_s_e=new Yh,Xm.Validate_s_v=new Yh,Xm.ComputeSubmergedArea_s_normalL=new Yh,Xm.ComputeSubmergedArea_s_md=new Wc,Xm.ComputeSubmergedArea_s_intoVec=new Yh,Xm.ComputeSubmergedArea_s_outoVec=new Yh,Xm.ComputeSubmergedArea_s_center=new Yh,Xm.ComputeCentroid_s_s=new Yh,Xm.ComputeCentroid_s_p1=new Yh,Xm.ComputeCentroid_s_p2=new Yh,Xm.ComputeCentroid_s_p3=new Yh,Xm.ComputeCentroid_s_e1=new Yh,Xm.ComputeCentroid_s_e2=new Yh;class Jm{constructor(){this.m_start=Date.now()}Reset(){return this.m_start=Date.now(),this}GetMilliseconds(){return Date.now()-this.m_start}}let Zm=0,Ym=0,Qm=0,Km=0;const $m=new ic,tu=new ic,eu=new Yh,iu=new Yh,su=new Yh,nu=new Yh,ru=new Yh;class ou{constructor(){this.proxyA=new nc,this.proxyB=new nc,this.sweepA=new sc,this.sweepB=new sc,this.tMax=0}}var au,lu;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_failed=1]="e_failed",t[t.e_overlapped=2]="e_overlapped",t[t.e_touching=3]="e_touching",t[t.e_separated=4]="e_separated"}(au||(au={}));class hu{constructor(){this.state=au.e_unknown,this.t=0}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_points=0]="e_points",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(lu||(lu={}));const cu=new Jm,mu=new rc,uu=new oc,_u=new ac,du=new class{constructor(){this.m_sweepA=new sc,this.m_sweepB=new sc,this.m_type=lu.e_unknown,this.m_localPoint=new Yh,this.m_axis=new Yh}Initialize(t,e,i,s,n,r){this.m_proxyA=e,this.m_proxyB=s;const o=t.count;this.m_sweepA.Copy(i),this.m_sweepB.Copy(n);const a=$m,l=tu;if(this.m_sweepA.GetTransform(a,r),this.m_sweepB.GetTransform(l,r),1===o){this.m_type=lu.e_points;const e=this.m_proxyA.GetVertex(t.indexA[0]),i=this.m_proxyB.GetVertex(t.indexB[0]),s=ic.MulXV(a,e,eu),n=ic.MulXV(l,i,iu);Yh.SubVV(n,s,this.m_axis);const r=this.m_axis.Normalize();return this.m_localPoint.SetZero(),r}if(t.indexA[0]===t.indexA[1]){this.m_type=lu.e_faceB;const e=this.m_proxyB.GetVertex(t.indexB[0]),i=this.m_proxyB.GetVertex(t.indexB[1]);Yh.CrossVOne(Yh.SubVV(i,e,Yh.s_t0),this.m_axis).SelfNormalize();const s=ec.MulRV(l.q,this.m_axis,su);Yh.MidVV(e,i,this.m_localPoint);const n=ic.MulXV(l,this.m_localPoint,iu),r=this.m_proxyA.GetVertex(t.indexA[0]),o=ic.MulXV(a,r,eu);let h=Yh.DotVV(Yh.SubVV(o,n,Yh.s_t0),s);return h<0&&(this.m_axis.SelfNeg(),h=-h),h}{this.m_type=lu.e_faceA;const e=this.m_proxyA.GetVertex(t.indexA[0]),i=this.m_proxyA.GetVertex(t.indexA[1]);Yh.CrossVOne(Yh.SubVV(i,e,Yh.s_t0),this.m_axis).SelfNormalize();const s=ec.MulRV(a.q,this.m_axis,su);Yh.MidVV(e,i,this.m_localPoint);const n=ic.MulXV(a,this.m_localPoint,eu),r=this.m_proxyB.GetVertex(t.indexB[0]),o=ic.MulXV(l,r,iu);let h=Yh.DotVV(Yh.SubVV(o,n,Yh.s_t0),s);return h<0&&(this.m_axis.SelfNeg(),h=-h),h}}FindMinSeparation(t,e,i){const s=$m,n=tu;switch(this.m_sweepA.GetTransform(s,i),this.m_sweepB.GetTransform(n,i),this.m_type){case lu.e_points:{const i=ec.MulTRV(s.q,this.m_axis,nu),r=ec.MulTRV(n.q,Yh.NegV(this.m_axis,Yh.s_t0),ru);t[0]=this.m_proxyA.GetSupport(i),e[0]=this.m_proxyB.GetSupport(r);const o=this.m_proxyA.GetVertex(t[0]),a=this.m_proxyB.GetVertex(e[0]),l=ic.MulXV(s,o,eu),h=ic.MulXV(n,a,iu);return Yh.DotVV(Yh.SubVV(h,l,Yh.s_t0),this.m_axis)}case lu.e_faceA:{const i=ec.MulRV(s.q,this.m_axis,su),r=ic.MulXV(s,this.m_localPoint,eu),o=ec.MulTRV(n.q,Yh.NegV(i,Yh.s_t0),ru);t[0]=-1,e[0]=this.m_proxyB.GetSupport(o);const a=this.m_proxyB.GetVertex(e[0]),l=ic.MulXV(n,a,iu);return Yh.DotVV(Yh.SubVV(l,r,Yh.s_t0),i)}case lu.e_faceB:{const i=ec.MulRV(n.q,this.m_axis,su),r=ic.MulXV(n,this.m_localPoint,iu),o=ec.MulTRV(s.q,Yh.NegV(i,Yh.s_t0),nu);e[0]=-1,t[0]=this.m_proxyA.GetSupport(o);const a=this.m_proxyA.GetVertex(t[0]),l=ic.MulXV(s,a,eu);return Yh.DotVV(Yh.SubVV(l,r,Yh.s_t0),i)}default:return t[0]=-1,e[0]=-1,0}}Evaluate(t,e,i){const s=$m,n=tu;switch(this.m_sweepA.GetTransform(s,i),this.m_sweepB.GetTransform(n,i),this.m_type){case lu.e_points:{const i=this.m_proxyA.GetVertex(t),r=this.m_proxyB.GetVertex(e),o=ic.MulXV(s,i,eu),a=ic.MulXV(n,r,iu);return Yh.DotVV(Yh.SubVV(a,o,Yh.s_t0),this.m_axis)}case lu.e_faceA:{const t=ec.MulRV(s.q,this.m_axis,su),i=ic.MulXV(s,this.m_localPoint,eu),r=this.m_proxyB.GetVertex(e),o=ic.MulXV(n,r,iu);return Yh.DotVV(Yh.SubVV(o,i,Yh.s_t0),t)}case lu.e_faceB:{const e=ec.MulRV(n.q,this.m_axis,su),i=ic.MulXV(n,this.m_localPoint,iu),r=this.m_proxyA.GetVertex(t),o=ic.MulXV(s,r,eu);return Yh.DotVV(Yh.SubVV(o,i,Yh.s_t0),e)}default:return 0}}},pu=[0],fu=[0],yu=new sc,gu=new sc;function xu(t,e){const i=cu.Reset();t.state=au.e_unknown,t.t=e.tMax;const s=e.proxyA,n=e.proxyB,r=Wh(8,Wh(s.m_count,n.m_count)),o=yu.Copy(e.sweepA),a=gu.Copy(e.sweepB);o.Normalize(),a.Normalize();const l=e.tMax,h=s.m_radius+n.m_radius,c=Wh(Ph,h-.015),m=.00125;let u=0,_=0;const d=mu;d.count=0;const p=uu;for(p.proxyA.Copy(e.proxyA),p.proxyB.Copy(e.proxyB),p.useRadii=!1;;){const e=$m,i=tu;o.GetTransform(e,u),a.GetTransform(i,u),p.transformA.Copy(e),p.transformB.Copy(i);const h=_u;if(xc(h,d,p),h.distance<=0){t.state=au.e_overlapped,t.t=0;break}if(h.distance<c+m){t.state=au.e_touching,t.t=u;break}const f=du;f.Initialize(d,s,o,n,a,u);let y=!1,g=l,x=0;for(;;){const e=pu,i=fu;let s=f.FindMinSeparation(e,i,g);if(s>c+m){t.state=au.e_separated,t.t=l,y=!0;break}if(s>c-m){u=g;break}let n=f.Evaluate(e[0],i[0],u);if(n<c-m){t.state=au.e_failed,t.t=u,y=!0;break}if(n<=c+m){t.state=au.e_touching,t.t=u,y=!0;break}let o=0,a=u,h=g;for(;;){let t=0;t=1&o?a+(c-n)*(h-a)/(s-n):.5*(a+h),++o;const r=f.Evaluate(e[0],i[0],t);if(Nh(r-c)<m){g=t;break}if(r>c?(a=t,n=r):(h=t,s=r),50===o)break}if(Km=Wh(Km,o),++x,x===r)break}if(++_,y)break;if(20===_){t.state=au.e_failed,t.t=u;break}}Qm=Wh(Qm,_);const f=i.GetMilliseconds();Ym=Wh(Ym,f),Zm+=f}var vu,Su,wu;(wu=vu||(vu={}))[wu.e_unknownJoint=0]="e_unknownJoint",wu[wu.e_revoluteJoint=1]="e_revoluteJoint",wu[wu.e_prismaticJoint=2]="e_prismaticJoint",wu[wu.e_distanceJoint=3]="e_distanceJoint",wu[wu.e_pulleyJoint=4]="e_pulleyJoint",wu[wu.e_mouseJoint=5]="e_mouseJoint",wu[wu.e_gearJoint=6]="e_gearJoint",wu[wu.e_wheelJoint=7]="e_wheelJoint",wu[wu.e_weldJoint=8]="e_weldJoint",wu[wu.e_frictionJoint=9]="e_frictionJoint",wu[wu.e_ropeJoint=10]="e_ropeJoint",wu[wu.e_motorJoint=11]="e_motorJoint",wu[wu.e_areaJoint=12]="e_areaJoint";class bu{constructor(t){this._other=null,this.prev=null,this.next=null,this.joint=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Cu{constructor(t){this.m_type=vu.e_unknownJoint,this.m_prev=null,this.m_next=null,this.m_edgeA=new bu(this),this.m_edgeB=new bu(this),this.m_index=0,this.m_islandFlag=!1,this.m_collideConnected=!1,this.m_userData=null,this.m_type=t.type,this.m_edgeA.other=t.bodyB,this.m_edgeB.other=t.bodyA,this.m_bodyA=t.bodyA,this.m_bodyB=t.bodyB,this.m_collideConnected=Ah(t.collideConnected,!1),this.m_userData=Ah(t.userData,null)}GetType(){return this.m_type}GetBodyA(){return this.m_bodyA}GetBodyB(){return this.m_bodyB}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}IsEnabled(){return this.m_bodyA.IsEnabled()&&this.m_bodyB.IsEnabled()}GetCollideConnected(){return this.m_collideConnected}Dump(t){t("// Dump is not supported for this joint type.\n")}ShiftOrigin(t){}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=e.p,n=i.p,r=this.GetAnchorA(Cu.Draw_s_p1),o=this.GetAnchorB(Cu.Draw_s_p2),a=Cu.Draw_s_color.SetRGB(.5,.8,.8);switch(this.m_type){case vu.e_distanceJoint:t.DrawSegment(r,o,a);break;case vu.e_pulleyJoint:{const e=this,i=e.GetGroundAnchorA(),s=e.GetGroundAnchorB();t.DrawSegment(i,r,a),t.DrawSegment(s,o,a),t.DrawSegment(i,s,a)}break;case vu.e_mouseJoint:{const e=Cu.Draw_s_c;e.Set(0,1,0),t.DrawPoint(r,4,e),t.DrawPoint(o,4,e),e.Set(.8,.8,.8),t.DrawSegment(r,o,e)}break;default:t.DrawSegment(s,r,a),t.DrawSegment(r,o,a),t.DrawSegment(n,o,a)}}}Cu.Draw_s_p1=new Yh,Cu.Draw_s_p2=new Yh,Cu.Draw_s_color=new wh(.5,.8,.8),Cu.Draw_s_c=new wh;class Au extends class{constructor(t){this.type=vu.e_unknownJoint,this.userData=null,this.collideConnected=!1,this.type=t}}{constructor(){super(vu.e_distanceJoint),this.localAnchorA=new Yh,this.localAnchorB=new Yh,this.length=1,this.minLength=0,this.maxLength=Bh,this.stiffness=0,this.damping=0}Initialize(t,e,i,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(i,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.length=Wh(Yh.DistanceVV(i,s),Ph),this.minLength=this.length,this.maxLength=this.length}}class Bu extends Cu{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_length=0,this.m_minLength=0,this.m_maxLength=0,this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_gamma=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_u=new Yh,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_currentLength=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_softMass=0,this.m_mass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_length=Wh(Ah(t.length,this.GetCurrentLength()),Ph),this.m_minLength=Wh(Ah(t.minLength,this.m_length),Ph),this.m_maxLength=Wh(Ah(t.maxLength,this.m_length),this.m_minLength),this.m_stiffness=Ah(t.stiffness,0),this.m_damping=Ah(t.damping,0)}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.x,e.y=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.y,e}GetReactionTorque(t){return 0}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetLength(t){return this.m_impulse=0,this.m_length=Wh(Ph,t),this.m_length}GetLength(){return this.m_length}SetMinLength(t){return this.m_lowerImpulse=0,this.m_minLength=jh(t,Ph,this.m_maxLength),this.m_minLength}SetMaxLength(t){return this.m_upperImpulse=0,this.m_maxLength=Wh(t,this.m_minLength),this.m_maxLength}GetCurrentLength(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,new Yh),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,new Yh);return Yh.DistanceVV(t,e)}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.length = %.15f;\n",this.m_length),t("  jd.minLength = %.15f;\n",this.m_minLength),t("  jd.maxLength = %.15f;\n",this.m_maxLength),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),ec.MulRV(h,this.m_lalcA,this.m_rA),Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),ec.MulRV(c,this.m_lalcB,this.m_rB),this.m_u.x=r.x+this.m_rB.x-e.x-this.m_rA.x,this.m_u.y=r.y+this.m_rB.y-e.y-this.m_rA.y,this.m_currentLength=this.m_u.Length(),this.m_currentLength>Ph?this.m_u.SelfMul(1/this.m_currentLength):(this.m_u.SetZero(),this.m_mass=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0);const m=Yh.CrossVV(this.m_rA,this.m_u),u=Yh.CrossVV(this.m_rB,this.m_u);let _=this.m_invMassA+this.m_invIA*m*m+this.m_invMassB+this.m_invIB*u*u;if(this.m_mass=0!==_?1/_:0,this.m_stiffness>0&&this.m_minLength<this.m_maxLength){const e=this.m_currentLength-this.m_length,i=this.m_damping,s=this.m_stiffness,n=t.step.dt;this.m_gamma=n*(i+n*s),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=e*n*s*this.m_gamma,_+=this.m_gamma,this.m_softMass=0!==_?1/_:0}else this.m_gamma=0,this.m_bias=0,this.m_softMass=this.m_mass;if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=Yh.MulSV(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse,this.m_u,Bu.InitVelocityConstraints_s_P);s.SelfMulSub(this.m_invMassA,e),n-=this.m_invIA*Yh.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,e),l+=this.m_invIB*Yh.CrossVV(this.m_rB,e)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;if(this.m_minLength<this.m_maxLength){if(this.m_stiffness>0){const t=Yh.AddVCrossSV(e,i,this.m_rA,Bu.SolveVelocityConstraints_s_vpA),r=Yh.AddVCrossSV(s,n,this.m_rB,Bu.SolveVelocityConstraints_s_vpB),o=Yh.DotVV(this.m_u,Yh.SubVV(r,t,Yh.s_t0)),a=-this.m_softMass*(o+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=a;const l=Yh.MulSV(a,this.m_u,Bu.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),i-=this.m_invIA*Yh.CrossVV(this.m_rA,l),s.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*Yh.CrossVV(this.m_rB,l)}{const r=Wh(0,this.m_currentLength-this.m_minLength)*t.step.inv_dt,o=Yh.AddVCrossSV(e,i,this.m_rA,Bu.SolveVelocityConstraints_s_vpA),a=Yh.AddVCrossSV(s,n,this.m_rB,Bu.SolveVelocityConstraints_s_vpB),l=Yh.DotVV(this.m_u,Yh.SubVV(a,o,Yh.s_t0));let h=-this.m_mass*(l+r);const c=this.m_lowerImpulse;this.m_lowerImpulse=Wh(0,this.m_lowerImpulse+h),h=this.m_lowerImpulse-c;const m=Yh.MulSV(h,this.m_u,Bu.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),i-=this.m_invIA*Yh.CrossVV(this.m_rA,m),s.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*Yh.CrossVV(this.m_rB,m)}{const r=Wh(0,this.m_maxLength-this.m_currentLength)*t.step.inv_dt,o=Yh.AddVCrossSV(e,i,this.m_rA,Bu.SolveVelocityConstraints_s_vpA),a=Yh.AddVCrossSV(s,n,this.m_rB,Bu.SolveVelocityConstraints_s_vpB),l=Yh.DotVV(this.m_u,Yh.SubVV(o,a,Yh.s_t0));let h=-this.m_mass*(l+r);const c=this.m_upperImpulse;this.m_upperImpulse=Wh(0,this.m_upperImpulse+h),h=this.m_upperImpulse-c;const m=Yh.MulSV(-h,this.m_u,Bu.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),i-=this.m_invIA*Yh.CrossVV(this.m_rA,m),s.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*Yh.CrossVV(this.m_rB,m)}}else{const t=Yh.AddVCrossSV(e,i,this.m_rA,Bu.SolveVelocityConstraints_s_vpA),r=Yh.AddVCrossSV(s,n,this.m_rB,Bu.SolveVelocityConstraints_s_vpB),o=Yh.DotVV(this.m_u,Yh.SubVV(r,t,Yh.s_t0)),a=-this.m_mass*o;this.m_impulse+=a;const l=Yh.MulSV(a,this.m_u,Bu.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),i-=this.m_invIA*Yh.CrossVV(this.m_rA,l),s.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*Yh.CrossVV(this.m_rB,l)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=ec.MulRV(r,this.m_lalcA,this.m_rA),l=ec.MulRV(o,this.m_lalcB,this.m_rB),h=this.m_u;h.x=s.x+l.x-e.x-a.x,h.y=s.y+l.y-e.y-a.y;const c=this.m_u.Normalize();let m;if(this.m_minLength==this.m_maxLength)m=c-this.m_minLength;else if(c<this.m_minLength)m=c-this.m_minLength;else{if(!(this.m_maxLength<c))return!0;m=c-this.m_maxLength}const u=-this.m_mass*m,_=Yh.MulSV(u,h,Bu.SolvePositionConstraints_s_P);return e.SelfMulSub(this.m_invMassA,_),i-=this.m_invIA*Yh.CrossVV(a,_),s.SelfMulAdd(this.m_invMassB,_),n+=this.m_invIB*Yh.CrossVV(l,_),t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,Nh(m)<Ph}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ic.MulXV(e,this.m_localAnchorA,Bu.Draw_s_pA),n=ic.MulXV(i,this.m_localAnchorB,Bu.Draw_s_pB),r=Yh.SubVV(n,s,Bu.Draw_s_axis);r.Normalize();const o=Bu.Draw_s_c1,a=Bu.Draw_s_c2,l=Bu.Draw_s_c3,h=Bu.Draw_s_c4;t.DrawSegment(s,n,h);const c=Yh.AddVMulSV(s,this.m_length,r,Bu.Draw_s_pRest);if(t.DrawPoint(c,8,o),this.m_minLength!=this.m_maxLength){if(this.m_minLength>Ph){const e=Yh.AddVMulSV(s,this.m_minLength,r,Bu.Draw_s_pMin);t.DrawPoint(e,4,a)}if(this.m_maxLength<Bh){const e=Yh.AddVMulSV(s,this.m_maxLength,r,Bu.Draw_s_pMax);t.DrawPoint(e,4,l)}}}}Bu.InitVelocityConstraints_s_P=new Yh,Bu.SolveVelocityConstraints_s_vpA=new Yh,Bu.SolveVelocityConstraints_s_vpB=new Yh,Bu.SolveVelocityConstraints_s_P=new Yh,Bu.SolvePositionConstraints_s_P=new Yh,Bu.Draw_s_pA=new Yh,Bu.Draw_s_pB=new Yh,Bu.Draw_s_axis=new Yh,Bu.Draw_s_c1=new wh(.7,.7,.7),Bu.Draw_s_c2=new wh(.3,.9,.3),Bu.Draw_s_c3=new wh(.9,.3,.3),Bu.Draw_s_c4=new wh(.4,.4,.4),Bu.Draw_s_pRest=new Yh,Bu.Draw_s_pMin=new Yh,Bu.Draw_s_pMax=new Yh;class Mu extends Cu{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_impulse=0,this.m_targetArea=0,this.m_delta=new Yh,this.m_bodies=t.bodies,this.m_stiffness=Ah(t.stiffness,0),this.m_damping=Ah(t.damping,0),this.m_targetLengths=kh(t.bodies.length),this.m_normals=Yh.MakeArray(t.bodies.length),this.m_joints=[],this.m_deltas=Yh.MakeArray(t.bodies.length);const e=new Au;e.stiffness=this.m_stiffness,e.damping=this.m_damping,this.m_targetArea=0;for(let t=0;t<this.m_bodies.length;++t){const i=this.m_bodies[t],s=this.m_bodies[(t+1)%this.m_bodies.length],n=i.GetWorldCenter(),r=s.GetWorldCenter();this.m_targetLengths[t]=Yh.DistanceVV(n,r),this.m_targetArea+=Yh.CrossVV(n,r),e.Initialize(i,s,n,r),this.m_joints[t]=i.GetWorld().CreateJoint(e)}this.m_targetArea*=.5}GetAnchorA(t){return t}GetAnchorB(t){return t}GetReactionForce(t,e){return e}GetReactionTorque(t){return 0}SetStiffness(t){this.m_stiffness=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetStiffness(t)}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetDamping(t)}GetDamping(){return this.m_damping}Dump(t){t("Area joint dumping is not supported.\n")}InitVelocityConstraints(t){for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[(e+this.m_bodies.length-1)%this.m_bodies.length],s=this.m_bodies[(e+1)%this.m_bodies.length],n=t.positions[i.m_islandIndex].c,r=t.positions[s.m_islandIndex].c,o=this.m_deltas[e];Yh.SubVV(r,n,o)}if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],s=t.velocities[i.m_islandIndex].v,n=this.m_deltas[e];s.x+=i.m_invMass*n.y*.5*this.m_impulse,s.y+=i.m_invMass*-n.x*.5*this.m_impulse}}else this.m_impulse=0}SolveVelocityConstraints(t){let e=0,i=0;for(let s=0;s<this.m_bodies.length;++s){const n=this.m_bodies[s],r=t.velocities[n.m_islandIndex].v,o=this.m_deltas[s];e+=o.LengthSquared()/n.GetMass(),i+=Yh.CrossVV(r,o)}const s=-2*i/e;this.m_impulse+=s;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],n=t.velocities[i.m_islandIndex].v,r=this.m_deltas[e];n.x+=i.m_invMass*r.y*.5*s,n.y+=i.m_invMass*-r.x*.5*s}}SolvePositionConstraints(t){let e=0,i=0;for(let s=0;s<this.m_bodies.length;++s){const n=this.m_bodies[s],r=this.m_bodies[(s+1)%this.m_bodies.length],o=t.positions[n.m_islandIndex].c,a=t.positions[r.m_islandIndex].c,l=Yh.SubVV(a,o,this.m_delta);let h=l.Length();h<Mh&&(h=1),this.m_normals[s].x=l.y/h,this.m_normals[s].y=-l.x/h,e+=h,i+=Yh.CrossVV(o,a)}i*=.5;const s=.5*(this.m_targetArea-i)/e;let n=!0;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],r=t.positions[i.m_islandIndex].c,o=(e+1)%this.m_bodies.length,a=Yh.AddVV(this.m_normals[e],this.m_normals[o],this.m_delta);a.SelfMul(s);const l=a.LengthSquared();l>Hh(.2)&&a.SelfMul(.2/Xh(l)),l>Hh(Ph)&&(n=!1),r.x+=a.x,r.y+=a.y}return n}}class Vu{constructor(){this.categoryBits=1,this.maskBits=65535,this.groupIndex=0}Clone(){return(new Vu).Copy(this)}Copy(t){return this.categoryBits=t.categoryBits,this.maskBits=t.maskBits,this.groupIndex=t.groupIndex||0,this}}Vu.DEFAULT=new Vu;class Tu{constructor(t,e){this.aabb=new Dc,this.childIndex=0,this.fixture=t,this.childIndex=e,this.fixture.m_shape.ComputeAABB(this.aabb,this.fixture.m_body.GetTransform(),e),this.treeNode=this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb,this)}Reset(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode)}Touch(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode)}Synchronize(t,e){if(t===e)this.fixture.m_shape.ComputeAABB(this.aabb,t,this.childIndex),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,Yh.ZERO);else{const i=Tu.Synchronize_s_aabb1,s=Tu.Synchronize_s_aabb2;this.fixture.m_shape.ComputeAABB(i,t,this.childIndex),this.fixture.m_shape.ComputeAABB(s,e,this.childIndex),this.aabb.Combine2(i,s);const n=Tu.Synchronize_s_displacement;n.Copy(s.GetCenter()).SelfSub(i.GetCenter()),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,n)}}}Tu.Synchronize_s_aabb1=new Dc,Tu.Synchronize_s_aabb2=new Dc,Tu.Synchronize_s_displacement=new Yh;class Pu{constructor(t,e){this.m_density=0,this.m_next=null,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=1,this.m_proxies=[],this.m_filter=new Vu,this.m_isSensor=!1,this.m_userData=null,this.m_body=t,this.m_shape=e.shape.Clone(),this.m_userData=Ah(e.userData,null),this.m_friction=Ah(e.friction,.2),this.m_restitution=Ah(e.restitution,0),this.m_restitutionThreshold=Ah(e.restitutionThreshold,0),this.m_filter.Copy(Ah(e.filter,Vu.DEFAULT)),this.m_isSensor=Ah(e.isSensor,!1),this.m_density=Ah(e.density,0)}get m_proxyCount(){return this.m_proxies.length}Reset(){}GetType(){return this.m_shape.GetType()}GetShape(){return this.m_shape}SetSensor(t){t!==this.m_isSensor&&(this.m_body.SetAwake(!0),this.m_isSensor=t)}IsSensor(){return this.m_isSensor}SetFilterData(t){this.m_filter.Copy(t),this.Refilter()}GetFilterData(){return this.m_filter}Refilter(){let t=this.m_body.GetContactList();for(;t;){const e=t.contact,i=e.GetFixtureA(),s=e.GetFixtureB();i!==this&&s!==this||e.FlagForFiltering(),t=t.next}this.TouchProxies()}GetBody(){return this.m_body}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}TestPoint(t){return this.m_shape.TestPoint(this.m_body.GetTransform(),t)}ComputeDistance(t,e,i){return this.m_shape.ComputeDistance(this.m_body.GetTransform(),t,e,i)}RayCast(t,e,i){return this.m_shape.RayCast(t,e,this.m_body.GetTransform(),i)}GetMassData(t=new Wc){return this.m_shape.ComputeMass(t,this.m_density),t}SetDensity(t){this.m_density=t}GetDensity(){return this.m_density}GetFriction(){return this.m_friction}SetFriction(t){this.m_friction=t}GetRestitution(){return this.m_restitution}SetRestitution(t){this.m_restitution=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetAABB(t){return this.m_proxies[t].aabb}Dump(t,e){t("    const fd: b2FixtureDef = new b2FixtureDef();\n"),t("    fd.friction = %.15f;\n",this.m_friction),t("    fd.restitution = %.15f;\n",this.m_restitution),t("    fd.restitutionThreshold = %.15f;\n",this.m_restitutionThreshold),t("    fd.density = %.15f;\n",this.m_density),t("    fd.isSensor = %s;\n",this.m_isSensor?"true":"false"),t("    fd.filter.categoryBits = %d;\n",this.m_filter.categoryBits),t("    fd.filter.maskBits = %d;\n",this.m_filter.maskBits),t("    fd.filter.groupIndex = %d;\n",this.m_filter.groupIndex),this.m_shape.Dump(t),t("\n"),t("    fd.shape = shape;\n"),t("\n"),t("    bodies[%d].CreateFixture(fd);\n",e)}CreateProxies(){if(0!==this.m_proxies.length)throw new Error;for(let t=0;t<this.m_shape.GetChildCount();++t)this.m_proxies[t]=new Tu(this,t)}DestroyProxies(){for(const t of this.m_proxies)t.Reset();this.m_proxies.length=0}TouchProxies(){for(const t of this.m_proxies)t.Touch()}SynchronizeProxies(t,e){for(const i of this.m_proxies)i.Synchronize(t,e)}}!function(t){t[t.b2_unknown=-1]="b2_unknown",t[t.b2_staticBody=0]="b2_staticBody",t[t.b2_kinematicBody=1]="b2_kinematicBody",t[t.b2_dynamicBody=2]="b2_dynamicBody"}(Su||(Su={}));class Du{constructor(t,e){this.m_type=Su.b2_staticBody,this.m_islandFlag=!1,this.m_awakeFlag=!1,this.m_autoSleepFlag=!1,this.m_bulletFlag=!1,this.m_fixedRotationFlag=!1,this.m_enabledFlag=!1,this.m_toiFlag=!1,this.m_islandIndex=0,this.m_xf=new ic,this.m_xf0=new ic,this.m_sweep=new sc,this.m_linearVelocity=new Yh,this.m_angularVelocity=0,this.m_force=new Yh,this.m_torque=0,this.m_prev=null,this.m_next=null,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_jointList=null,this.m_contactList=null,this.m_mass=1,this.m_invMass=1,this.m_I=0,this.m_invI=0,this.m_linearDamping=0,this.m_angularDamping=0,this.m_gravityScale=1,this.m_sleepTime=0,this.m_userData=null,this.m_controllerList=null,this.m_controllerCount=0,this.m_bulletFlag=Ah(t.bullet,!1),this.m_fixedRotationFlag=Ah(t.fixedRotation,!1),this.m_autoSleepFlag=Ah(t.allowSleep,!0),Ah(t.awake,!0)&&Ah(t.type,Su.b2_staticBody)!==Su.b2_staticBody&&(this.m_awakeFlag=!0),this.m_enabledFlag=Ah(t.enabled,!0),this.m_world=e,this.m_xf.p.Copy(Ah(t.position,Yh.ZERO)),this.m_xf.q.SetAngle(Ah(t.angle,0)),this.m_xf0.Copy(this.m_xf),this.m_sweep.localCenter.SetZero(),this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle(),this.m_sweep.alpha0=0,this.m_linearVelocity.Copy(Ah(t.linearVelocity,Yh.ZERO)),this.m_angularVelocity=Ah(t.angularVelocity,0),this.m_linearDamping=Ah(t.linearDamping,0),this.m_angularDamping=Ah(t.angularDamping,0),this.m_gravityScale=Ah(t.gravityScale,1),this.m_force.SetZero(),this.m_torque=0,this.m_sleepTime=0,this.m_type=Ah(t.type,Su.b2_staticBody),this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_userData=t.userData,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_controllerList=null,this.m_controllerCount=0}CreateFixture(t,e=0){return t instanceof Hc?this.CreateFixtureShapeDensity(t,e):this.CreateFixtureDef(t)}CreateFixtureDef(t){if(this.m_world.IsLocked())throw new Error;const e=new Pu(this,t);return this.m_enabledFlag&&e.CreateProxies(),e.m_next=this.m_fixtureList,this.m_fixtureList=e,++this.m_fixtureCount,e.m_density>0&&this.ResetMassData(),this.m_world.m_newContacts=!0,e}CreateFixtureShapeDensity(t,e=0){const i=Du.CreateFixtureShapeDensity_s_def;return i.shape=t,i.density=e,this.CreateFixtureDef(i)}DestroyFixture(t){if(this.m_world.IsLocked())throw new Error;let e=this.m_fixtureList,i=null;for(;null!==e;){if(e===t){i?i.m_next=t.m_next:this.m_fixtureList=t.m_next;break}i=e,e=e.m_next}let s=this.m_contactList;for(;s;){const e=s.contact;s=s.next;const i=e.GetFixtureA(),n=e.GetFixtureB();t!==i&&t!==n||this.m_world.m_contactManager.Destroy(e)}this.m_enabledFlag&&t.DestroyProxies(),t.m_next=null,t.Reset(),--this.m_fixtureCount,this.ResetMassData()}SetTransformVec(t,e){this.SetTransformXY(t.x,t.y,e)}SetTransformXY(t,e,i){if(this.m_world.IsLocked())throw new Error;this.m_xf.q.SetAngle(i),this.m_xf.p.Set(t,e),this.m_xf0.Copy(this.m_xf),ic.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.a=i,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_sweep.a0=i;for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf);this.m_world.m_newContacts=!0}SetTransform(t){this.SetTransformVec(t.p,t.GetAngle())}GetTransform(){return this.m_xf}GetPosition(){return this.m_xf.p}SetPosition(t){this.SetTransformVec(t,this.GetAngle())}SetPositionXY(t,e){this.SetTransformXY(t,e,this.GetAngle())}GetAngle(){return this.m_sweep.a}SetAngle(t){this.SetTransformVec(this.GetPosition(),t)}GetWorldCenter(){return this.m_sweep.c}GetLocalCenter(){return this.m_sweep.localCenter}SetLinearVelocity(t){this.m_type!==Su.b2_staticBody&&(Yh.DotVV(t,t)>0&&this.SetAwake(!0),this.m_linearVelocity.Copy(t))}GetLinearVelocity(){return this.m_linearVelocity}SetAngularVelocity(t){this.m_type!==Su.b2_staticBody&&(t*t>0&&this.SetAwake(!0),this.m_angularVelocity=t)}GetAngularVelocity(){return this.m_angularVelocity}GetDefinition(t){return t.type=this.GetType(),t.allowSleep=this.m_autoSleepFlag,t.angle=this.GetAngle(),t.angularDamping=this.m_angularDamping,t.gravityScale=this.m_gravityScale,t.angularVelocity=this.m_angularVelocity,t.fixedRotation=this.m_fixedRotationFlag,t.bullet=this.m_bulletFlag,t.awake=this.m_awakeFlag,t.linearDamping=this.m_linearDamping,t.linearVelocity.Copy(this.GetLinearVelocity()),t.position.Copy(this.GetPosition()),t.userData=this.GetUserData(),t}ApplyForce(t,e,i=!0){this.m_type===Su.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y,this.m_torque+=(e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x))}ApplyForceToCenter(t,e=!0){this.m_type===Su.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y))}ApplyTorque(t,e=!0){this.m_type===Su.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_torque+=t))}ApplyLinearImpulse(t,e,i=!0){this.m_type===Su.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y,this.m_angularVelocity+=this.m_invI*((e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x)))}ApplyLinearImpulseToCenter(t,e=!0){this.m_type===Su.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y))}ApplyAngularImpulse(t,e=!0){this.m_type===Su.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*t))}GetMass(){return this.m_mass}GetInertia(){return this.m_I+this.m_mass*Yh.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter)}GetMassData(t){return t.mass=this.m_mass,t.I=this.m_I+this.m_mass*Yh.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter),t.center.Copy(this.m_sweep.localCenter),t}SetMassData(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type!==Su.b2_dynamicBody)return;this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=t.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,t.I>0&&!this.m_fixedRotationFlag&&(this.m_I=t.I-this.m_mass*Yh.DotVV(t.center,t.center),this.m_invI=1/this.m_I);const e=Du.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t.center),ic.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),Yh.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Yh.SubVV(this.m_sweep.c,e,Yh.s_t0),this.m_linearVelocity)}ResetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_sweep.localCenter.SetZero(),this.m_type===Su.b2_staticBody||this.m_type===Su.b2_kinematicBody)return this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);const t=Du.ResetMassData_s_localCenter.SetZero();for(let e=this.m_fixtureList;e;e=e.m_next){if(0===e.m_density)continue;const i=e.GetMassData(Du.ResetMassData_s_massData);this.m_mass+=i.mass,t.x+=i.center.x*i.mass,t.y+=i.center.y*i.mass,this.m_I+=i.I}this.m_mass>0&&(this.m_invMass=1/this.m_mass,t.x*=this.m_invMass,t.y*=this.m_invMass),this.m_I>0&&!this.m_fixedRotationFlag?(this.m_I-=this.m_mass*Yh.DotVV(t,t),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0);const e=Du.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t),ic.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),Yh.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Yh.SubVV(this.m_sweep.c,e,Yh.s_t0),this.m_linearVelocity)}GetWorldPoint(t,e){return ic.MulXV(this.m_xf,t,e)}GetWorldVector(t,e){return ec.MulRV(this.m_xf.q,t,e)}GetLocalPoint(t,e){return ic.MulTXV(this.m_xf,t,e)}GetLocalVector(t,e){return ec.MulTRV(this.m_xf.q,t,e)}GetLinearVelocityFromWorldPoint(t,e){return Yh.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Yh.SubVV(t,this.m_sweep.c,Yh.s_t0),e)}GetLinearVelocityFromLocalPoint(t,e){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t,e),e)}GetLinearDamping(){return this.m_linearDamping}SetLinearDamping(t){this.m_linearDamping=t}GetAngularDamping(){return this.m_angularDamping}SetAngularDamping(t){this.m_angularDamping=t}GetGravityScale(){return this.m_gravityScale}SetGravityScale(t){this.m_gravityScale=t}SetType(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type===t)return;this.m_type=t,this.ResetMassData(),this.m_type===Su.b2_staticBody&&(this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_sweep.a0=this.m_sweep.a,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_awakeFlag=!1,this.SynchronizeFixtures()),this.SetAwake(!0),this.m_force.SetZero(),this.m_torque=0;let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.m_contactManager.Destroy(t.contact)}this.m_contactList=null;for(let t=this.m_fixtureList;t;t=t.m_next)t.TouchProxies()}GetType(){return this.m_type}SetBullet(t){this.m_bulletFlag=t}IsBullet(){return this.m_bulletFlag}SetSleepingAllowed(t){this.m_autoSleepFlag=t,t||this.SetAwake(!0)}IsSleepingAllowed(){return this.m_autoSleepFlag}SetAwake(t){this.m_type!==Su.b2_staticBody&&(t?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_force.SetZero(),this.m_torque=0))}IsAwake(){return this.m_awakeFlag}SetEnabled(t){if(this.m_world.IsLocked())throw new Error;if(t!==this.IsEnabled())if(this.m_enabledFlag=t,t){for(let t=this.m_fixtureList;t;t=t.m_next)t.CreateProxies();this.m_world.m_newContacts=!0}else{for(let t=this.m_fixtureList;t;t=t.m_next)t.DestroyProxies();let t=this.m_contactList;for(;t;){const e=t;t=t.next,this.m_world.m_contactManager.Destroy(e.contact)}this.m_contactList=null}}IsEnabled(){return this.m_enabledFlag}SetFixedRotation(t){this.m_fixedRotationFlag!==t&&(this.m_fixedRotationFlag=t,this.m_angularVelocity=0,this.ResetMassData())}IsFixedRotation(){return this.m_fixedRotationFlag}GetFixtureList(){return this.m_fixtureList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactList}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}GetWorld(){return this.m_world}Dump(t){const e=this.m_islandIndex;t("{\n"),t("  const bd: b2BodyDef = new b2BodyDef();\n");let i="";switch(this.m_type){case Su.b2_staticBody:i="b2BodyType.b2_staticBody";break;case Su.b2_kinematicBody:i="b2BodyType.b2_kinematicBody";break;case Su.b2_dynamicBody:i="b2BodyType.b2_dynamicBody"}t("  bd.type = %s;\n",i),t("  bd.position.Set(%.15f, %.15f);\n",this.m_xf.p.x,this.m_xf.p.y),t("  bd.angle = %.15f;\n",this.m_sweep.a),t("  bd.linearVelocity.Set(%.15f, %.15f);\n",this.m_linearVelocity.x,this.m_linearVelocity.y),t("  bd.angularVelocity = %.15f;\n",this.m_angularVelocity),t("  bd.linearDamping = %.15f;\n",this.m_linearDamping),t("  bd.angularDamping = %.15f;\n",this.m_angularDamping),t("  bd.allowSleep = %s;\n",this.m_autoSleepFlag?"true":"false"),t("  bd.awake = %s;\n",this.m_awakeFlag?"true":"false"),t("  bd.fixedRotation = %s;\n",this.m_fixedRotationFlag?"true":"false"),t("  bd.bullet = %s;\n",this.m_bulletFlag?"true":"false"),t("  bd.active = %s;\n",this.m_enabledFlag?"true":"false"),t("  bd.gravityScale = %.15f;\n",this.m_gravityScale),t("\n"),t("  bodies[%d] = this.m_world.CreateBody(bd);\n",this.m_islandIndex),t("\n");for(let i=this.m_fixtureList;i;i=i.m_next)t("  {\n"),i.Dump(t,e),t("  }\n");t("}\n")}SynchronizeFixtures(){if(this.m_awakeFlag){const t=Du.SynchronizeFixtures_s_xf1;t.q.SetAngle(this.m_sweep.a0),ec.MulRV(t.q,this.m_sweep.localCenter,t.p),Yh.SubVV(this.m_sweep.c0,t.p,t.p);for(let e=this.m_fixtureList;e;e=e.m_next)e.SynchronizeProxies(t,this.m_xf)}else for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf)}SynchronizeTransform(){this.m_xf.q.SetAngle(this.m_sweep.a),ec.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),Yh.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}ShouldCollide(t){return(this.m_type!==Su.b2_staticBody||t.m_type!==Su.b2_staticBody)&&this.ShouldCollideConnected(t)}ShouldCollideConnected(t){for(let e=this.m_jointList;e;e=e.next)if(e.other===t&&!e.joint.m_collideConnected)return!1;return!0}Advance(t){this.m_sweep.Advance(t),this.m_sweep.c.Copy(this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_xf.q.SetAngle(this.m_sweep.a),ec.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),Yh.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}GetControllerList(){return this.m_controllerList}GetControllerCount(){return this.m_controllerCount}}function Iu(t,e){return Xh(t*e)}function Eu(t,e){return t>e?t:e}function Ru(t,e){return t<e?t:e}Du.CreateFixtureShapeDensity_s_def=new class{constructor(){this.userData=null,this.friction=.2,this.restitution=0,this.restitutionThreshold=1,this.density=0,this.isSensor=!1,this.filter=new Vu}},Du.SetMassData_s_oldCenter=new Yh,Du.ResetMassData_s_localCenter=new Yh,Du.ResetMassData_s_oldCenter=new Yh,Du.ResetMassData_s_massData=new Wc,Du.SynchronizeFixtures_s_xf1=new ic;class Lu{constructor(t){this._other=null,this.prev=null,this.next=null,this.contact=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Gu{constructor(){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_prev=null,this.m_next=null,this.m_nodeA=new Lu(this),this.m_nodeB=new Lu(this),this.m_indexA=0,this.m_indexB=0,this.m_manifold=new Bc,this.m_toiCount=0,this.m_toi=0,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_tangentSpeed=0,this.m_oldManifold=new Bc}GetManifold(){return this.m_manifold}GetWorldManifold(t){const e=this.m_fixtureA.GetBody(),i=this.m_fixtureB.GetBody(),s=this.GetShapeA(),n=this.GetShapeB();t.Initialize(this.m_manifold,e.GetTransform(),s.m_radius,i.GetTransform(),n.m_radius)}IsTouching(){return this.m_touchingFlag}SetEnabled(t){this.m_enabledFlag=t}IsEnabled(){return this.m_enabledFlag}GetNext(){return this.m_next}GetFixtureA(){return this.m_fixtureA}GetChildIndexA(){return this.m_indexA}GetShapeA(){return this.m_fixtureA.GetShape()}GetFixtureB(){return this.m_fixtureB}GetChildIndexB(){return this.m_indexB}GetShapeB(){return this.m_fixtureB.GetShape()}FlagForFiltering(){this.m_filterFlag=!0}SetFriction(t){this.m_friction=t}GetFriction(){return this.m_friction}ResetFriction(){this.m_friction=Iu(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction)}SetRestitution(t){this.m_restitution=t}GetRestitution(){return this.m_restitution}ResetRestitution(){this.m_restitution=Eu(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}ResetRestitutionThreshold(){this.m_restitutionThreshold=Ru(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}SetTangentSpeed(t){this.m_tangentSpeed=t}GetTangentSpeed(){return this.m_tangentSpeed}Reset(t,e,i,s){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!0,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_fixtureA=t,this.m_fixtureB=i,this.m_indexA=e,this.m_indexB=s,this.m_manifold.pointCount=0,this.m_prev=null,this.m_next=null,this.m_nodeA.Reset(),this.m_nodeB.Reset(),this.m_toiCount=0,this.m_friction=Iu(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=Eu(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution),this.m_restitutionThreshold=Ru(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}Update(t){const e=this.m_oldManifold;this.m_oldManifold=this.m_manifold,this.m_manifold=e,this.m_enabledFlag=!0;let i=!1;const s=this.m_touchingFlag,n=this.m_fixtureA.IsSensor(),r=this.m_fixtureB.IsSensor(),o=n||r,a=this.m_fixtureA.GetBody(),l=this.m_fixtureB.GetBody(),h=a.GetTransform(),c=l.GetTransform();if(o){const t=this.GetShapeA(),e=this.GetShapeB();i=Fc(t,this.m_indexA,e,this.m_indexB,h,c),this.m_manifold.pointCount=0}else{this.Evaluate(this.m_manifold,h,c),i=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;const i=e.id;for(let t=0;t<this.m_oldManifold.pointCount;++t){const s=this.m_oldManifold.points[t];if(s.id.key===i.key){e.normalImpulse=s.normalImpulse,e.tangentImpulse=s.tangentImpulse;break}}}i!==s&&(a.SetAwake(!0),l.SetAwake(!0))}this.m_touchingFlag=i,!s&&i&&t&&t.BeginContact(this),s&&!i&&t&&t.EndContact(this),!o&&i&&t&&t.PreSolve(this,this.m_oldManifold)}ComputeTOI(t,e){const i=Gu.ComputeTOI_s_input;i.proxyA.SetShape(this.GetShapeA(),this.m_indexA),i.proxyB.SetShape(this.GetShapeB(),this.m_indexB),i.sweepA.Copy(t),i.sweepB.Copy(e),i.tMax=Ph;const s=Gu.ComputeTOI_s_output;return xu(s,i),s.t}}Gu.ComputeTOI_s_input=new ou,Gu.ComputeTOI_s_output=new hu;class Fu extends Gu{static Create(){return new Fu}static Destroy(t){}Evaluate(t,e,i){const s=Fu.Evaluate_s_edge;this.GetShapeA().GetChildEdge(s,this.m_indexA),lm(t,s,e,this.GetShapeB(),i)}}Fu.Evaluate_s_edge=new qc;class ku extends Gu{static Create(){return new ku}static Destroy(t){}Evaluate(t,e,i){const s=ku.Evaluate_s_edge;this.GetShapeA().GetChildEdge(s,this.m_indexA),Vm(t,s,e,this.GetShapeB(),i)}}ku.Evaluate_s_edge=new qc;class zu extends Gu{static Create(){return new zu}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=ic.MulXV(i,e.m_p,Zc),o=ic.MulXV(n,s.m_p,Yc),a=Yh.DistanceSquaredVV(r,o),l=e.m_radius+s.m_radius;a>l*l||(t.type=Sc.e_circles,t.localPoint.Copy(e.m_p),t.localNormal.SetZero(),t.pointCount=1,t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0)}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class Ou extends Gu{static Create(){return new Ou}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=e.m_radius+s.m_radius,o=Fm;o[0]=0;const a=Im(o,e,i,s,n);if(a>r)return;const l=km;l[0]=0;const h=Im(l,s,n,e,i);if(h>r)return;let c,m,u,_,d=0,p=0;h>a+5e-4?(c=s,m=e,u=n,_=i,d=l[0],t.type=Sc.e_faceB,p=1):(c=e,m=s,u=i,_=n,d=o[0],t.type=Sc.e_faceA,p=0);const f=Rm;!function(t,e,i,s,n,r){const o=e.m_normals,a=n.m_count,l=n.m_vertices,h=n.m_normals,c=ec.MulTRV(r.q,ec.MulRV(i.q,o[s],Yh.s_t0),Em);let m=0,u=Bh;for(let t=0;t<a;++t){const e=Yh.DotVV(c,h[t]);e<u&&(u=e,m=t)}const _=m,d=_+1<a?_+1:0,p=t[0];ic.MulXV(r,l[_],p.v);const f=p.id.cf;f.indexA=s,f.indexB=_,f.typeA=vc.e_face,f.typeB=vc.e_vertex;const y=t[1];ic.MulXV(r,l[d],y.v);const g=y.id.cf;g.indexA=s,g.indexB=d,g.typeA=vc.e_face,g.typeB=vc.e_vertex}(f,c,u,d,m,_);const y=c.m_count,g=c.m_vertices,x=d,v=d+1<y?d+1:0,S=g[x],w=g[v],b=Yh.SubVV(w,S,zm);b.Normalize();const C=Yh.CrossVOne(b,Om),A=Yh.MidVV(S,w,Nm),B=ec.MulRV(u.q,b,Wm),M=Yh.CrossVOne(B,Um),V=ic.MulXV(u,S,Hm),T=ic.MulXV(u,w,qm),P=Yh.DotVV(M,V),D=-Yh.DotVV(B,V)+r,I=Yh.DotVV(B,T)+r,E=Lm,R=Gm;let L;if(L=Ec(E,f,Yh.NegV(B,jm),D,x),L<2)return;if(L=Ec(R,E,B,I,v),L<2)return;t.localNormal.Copy(C),t.localPoint.Copy(A);let G=0;for(let e=0;e<2;++e){const i=R[e];if(Yh.DotVV(M,i.v)-P<=r){const e=t.points[G];if(ic.MulTXV(_,i.v,e.localPoint),e.id.Copy(i.id),p){const t=e.id.cf;e.id.cf.indexA=t.indexB,e.id.cf.indexB=t.indexA,e.id.cf.typeA=t.typeB,e.id.cf.typeB=t.typeA}++G}}t.pointCount=G}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class Nu extends Gu{static Create(){return new Nu}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=ic.MulXV(n,s.m_p,Qc),o=ic.MulTXV(i,r,Kc);let a=0,l=-Bh;const h=e.m_radius+s.m_radius,c=e.m_count,m=e.m_vertices,u=e.m_normals;for(let t=0;t<c;++t){const e=Yh.DotVV(u[t],Yh.SubVV(o,m[t],Yh.s_t0));if(e>h)return;e>l&&(l=e,a=t)}const _=a,d=(_+1)%c,p=m[_],f=m[d];if(l<Mh)return t.pointCount=1,t.type=Sc.e_faceA,t.localNormal.Copy(u[a]),Yh.MidVV(p,f,t.localPoint),t.points[0].localPoint.Copy(s.m_p),void(t.points[0].id.key=0);const y=Yh.DotVV(Yh.SubVV(o,p,Yh.s_t0),Yh.SubVV(f,p,Yh.s_t1)),g=Yh.DotVV(Yh.SubVV(o,f,Yh.s_t0),Yh.SubVV(p,f,Yh.s_t1));if(y<=0){if(Yh.DistanceSquaredVV(o,p)>h*h)return;t.pointCount=1,t.type=Sc.e_faceA,Yh.SubVV(o,p,t.localNormal).SelfNormalize(),t.localPoint.Copy(p),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}else if(g<=0){if(Yh.DistanceSquaredVV(o,f)>h*h)return;t.pointCount=1,t.type=Sc.e_faceA,Yh.SubVV(o,f,t.localNormal).SelfNormalize(),t.localPoint.Copy(f),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}else{const e=Yh.MidVV(p,f,$c);if(Yh.DotVV(Yh.SubVV(o,e,Yh.s_t1),u[_])>h)return;t.pointCount=1,t.type=Sc.e_faceA,t.localNormal.Copy(u[_]).SelfNormalize(),t.localPoint.Copy(e),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class Uu extends Gu{static Create(){return new Uu}static Destroy(t){}Evaluate(t,e,i){lm(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class Wu extends Gu{static Create(){return new Wu}static Destroy(t){}Evaluate(t,e,i){Vm(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class ju{constructor(){this.pool=[],this.createFcn=null,this.destroyFcn=null,this.primary=!1}}class Hu{constructor(){this.m_registers=[],this.InitializeRegisters()}AddType(t,e,i,s){const n=[];function r(){return n.pop()||t()}function o(t){n.push(t)}this.m_registers[i][s].pool=n,this.m_registers[i][s].createFcn=r,this.m_registers[i][s].destroyFcn=o,this.m_registers[i][s].primary=!0,i!==s&&(this.m_registers[s][i].pool=n,this.m_registers[s][i].createFcn=r,this.m_registers[s][i].destroyFcn=o,this.m_registers[s][i].primary=!1)}InitializeRegisters(){for(let t=0;t<jc.e_shapeTypeCount;t++){this.m_registers[t]=[];for(let e=0;e<jc.e_shapeTypeCount;e++)this.m_registers[t][e]=new ju}this.AddType(zu.Create,zu.Destroy,jc.e_circleShape,jc.e_circleShape),this.AddType(Nu.Create,Nu.Destroy,jc.e_polygonShape,jc.e_circleShape),this.AddType(Ou.Create,Ou.Destroy,jc.e_polygonShape,jc.e_polygonShape),this.AddType(Uu.Create,Uu.Destroy,jc.e_edgeShape,jc.e_circleShape),this.AddType(Wu.Create,Wu.Destroy,jc.e_edgeShape,jc.e_polygonShape),this.AddType(Fu.Create,Fu.Destroy,jc.e_chainShape,jc.e_circleShape),this.AddType(ku.Create,ku.Destroy,jc.e_chainShape,jc.e_polygonShape)}Create(t,e,i,s){const n=t.GetType(),r=i.GetType(),o=this.m_registers[n][r];if(o.createFcn){const n=o.createFcn();return o.primary?n.Reset(t,e,i,s):n.Reset(i,s,t,e),n}return null}Destroy(t){const e=t.m_fixtureA.GetType(),i=t.m_fixtureB.GetType(),s=this.m_registers[e][i];s.destroyFcn&&s.destroyFcn(t)}}class qu{ShouldCollide(t,e){const i=t.GetBody(),s=e.GetBody();if(s.GetType()===Su.b2_staticBody&&i.GetType()===Su.b2_staticBody)return!1;if(!s.ShouldCollideConnected(i))return!1;const n=t.GetFilterData(),r=e.GetFilterData();return n.groupIndex===r.groupIndex&&0!==n.groupIndex?n.groupIndex>0:0!=(n.maskBits&r.categoryBits)&&0!=(n.categoryBits&r.maskBits)}ShouldCollideFixtureParticle(t,e,i){return!0}ShouldCollideParticleParticle(t,e,i){return!0}}qu.b2_defaultFilter=new qu;class Xu{BeginContact(t){}EndContact(t){}BeginContactFixtureParticle(t,e){}EndContactFixtureParticle(t,e){}BeginContactParticleParticle(t,e){}EndContactParticleParticle(t,e){}PreSolve(t,e){}PostSolve(t,e){}}Xu.b2_defaultListener=new Xu;class Ju{ReportFixture(t){return!0}ReportParticle(t,e){return!1}ShouldQueryParticleSystem(t){return!0}}class Zu{constructor(){this.m_broadPhase=new Uc,this.m_contactList=null,this.m_contactCount=0,this.m_contactFilter=qu.b2_defaultFilter,this.m_contactListener=Xu.b2_defaultListener,this.m_contactFactory=new Hu}AddPair(t,e){let i=t.fixture,s=e.fixture,n=t.childIndex,r=e.childIndex,o=i.GetBody(),a=s.GetBody();if(o===a)return;let l=a.GetContactList();for(;l;){if(l.other===o){const t=l.contact.GetFixtureA(),e=l.contact.GetFixtureB(),o=l.contact.GetChildIndexA(),a=l.contact.GetChildIndexB();if(t===i&&e===s&&o===n&&a===r)return;if(t===s&&e===i&&o===r&&a===n)return}l=l.next}if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(i,s))return;const h=this.m_contactFactory.Create(i,n,s,r);null!==h&&(i=h.GetFixtureA(),s=h.GetFixtureB(),n=h.GetChildIndexA(),r=h.GetChildIndexB(),o=i.m_body,a=s.m_body,h.m_prev=null,h.m_next=this.m_contactList,null!==this.m_contactList&&(this.m_contactList.m_prev=h),this.m_contactList=h,h.m_nodeA.other=a,h.m_nodeA.prev=null,h.m_nodeA.next=o.m_contactList,null!==o.m_contactList&&(o.m_contactList.prev=h.m_nodeA),o.m_contactList=h.m_nodeA,h.m_nodeB.other=o,h.m_nodeB.prev=null,h.m_nodeB.next=a.m_contactList,null!==a.m_contactList&&(a.m_contactList.prev=h.m_nodeB),a.m_contactList=h.m_nodeB,++this.m_contactCount)}FindNewContacts(){this.m_broadPhase.UpdatePairs(((t,e)=>{this.AddPair(t,e)}))}Destroy(t){const e=t.GetFixtureA(),i=t.GetFixtureB(),s=e.GetBody(),n=i.GetBody();this.m_contactListener&&t.IsTouching()&&this.m_contactListener.EndContact(t),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_contactList&&(this.m_contactList=t.m_next),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA===s.m_contactList&&(s.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB===n.m_contactList&&(n.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!e.IsSensor()&&!i.IsSensor()&&(e.GetBody().SetAwake(!0),i.GetBody().SetAwake(!0)),this.m_contactFactory.Destroy(t),--this.m_contactCount}Collide(){let t=this.m_contactList;for(;t;){const e=t.GetFixtureA(),i=t.GetFixtureB(),s=t.GetChildIndexA(),n=t.GetChildIndexB(),r=e.GetBody(),o=i.GetBody();if(t.m_filterFlag){if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(e,i)){const e=t;t=e.m_next,this.Destroy(e);continue}t.m_filterFlag=!1}const a=r.IsAwake()&&r.m_type!==Su.b2_staticBody,l=o.IsAwake()&&o.m_type!==Su.b2_staticBody;if(!a&&!l){t=t.m_next;continue}const h=e.m_proxies[s].treeNode,c=i.m_proxies[n].treeNode;if(Ic(h.aabb,c.aabb))t.Update(this.m_contactListener),t=t.m_next;else{const e=t;t=e.m_next,this.Destroy(e)}}}}class Yu{constructor(){this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0}Reset(){return this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0,this}}class Qu{constructor(){this.dt=0,this.inv_dt=0,this.dtRatio=0,this.velocityIterations=0,this.positionIterations=0,this.particleIterations=0,this.warmStarting=!1}Copy(t){return this.dt=t.dt,this.inv_dt=t.inv_dt,this.dtRatio=t.dtRatio,this.positionIterations=t.positionIterations,this.velocityIterations=t.velocityIterations,this.particleIterations=t.particleIterations,this.warmStarting=t.warmStarting,this}}class Ku{constructor(){this.c=new Yh,this.a=0}static MakeArray(t){return Fh(t,(t=>new Ku))}}class $u{constructor(){this.v=new Yh,this.w=0}static MakeArray(t){return Fh(t,(t=>new $u))}}class t_{constructor(){this.rA=new Yh,this.rB=new Yh,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}static MakeArray(t){return Fh(t,(t=>new t_))}}class e_{constructor(){this.points=t_.MakeArray(2),this.normal=new Yh,this.tangent=new Yh,this.normalMass=new $h,this.K=new $h,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.invIA=0,this.invIB=0,this.friction=0,this.restitution=0,this.threshold=0,this.tangentSpeed=0,this.pointCount=0,this.contactIndex=0}static MakeArray(t){return Fh(t,(t=>new e_))}}class i_{constructor(){this.localPoints=Yh.MakeArray(2),this.localNormal=new Yh,this.localPoint=new Yh,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.localCenterA=new Yh,this.localCenterB=new Yh,this.invIA=0,this.invIB=0,this.type=Sc.e_unknown,this.radiusA=0,this.radiusB=0,this.pointCount=0}static MakeArray(t){return Fh(t,(t=>new i_))}}class s_{constructor(){this.normal=new Yh,this.point=new Yh,this.separation=0}Initialize(t,e,i,s){const n=s_.Initialize_s_pointA,r=s_.Initialize_s_pointB,o=s_.Initialize_s_planePoint,a=s_.Initialize_s_clipPoint;switch(t.type){case Sc.e_circles:ic.MulXV(e,t.localPoint,n),ic.MulXV(i,t.localPoints[0],r),Yh.SubVV(r,n,this.normal).SelfNormalize(),Yh.MidVV(n,r,this.point),this.separation=Yh.DotVV(Yh.SubVV(r,n,Yh.s_t0),this.normal)-t.radiusA-t.radiusB;break;case Sc.e_faceA:ec.MulRV(e.q,t.localNormal,this.normal),ic.MulXV(e,t.localPoint,o),ic.MulXV(i,t.localPoints[s],a),this.separation=Yh.DotVV(Yh.SubVV(a,o,Yh.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a);break;case Sc.e_faceB:ec.MulRV(i.q,t.localNormal,this.normal),ic.MulXV(i,t.localPoint,o),ic.MulXV(e,t.localPoints[s],a),this.separation=Yh.DotVV(Yh.SubVV(a,o,Yh.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a),this.normal.SelfNeg()}}}s_.Initialize_s_pointA=new Yh,s_.Initialize_s_pointB=new Yh,s_.Initialize_s_planePoint=new Yh,s_.Initialize_s_clipPoint=new Yh;class n_{constructor(){this.m_step=new Qu,this.m_positionConstraints=i_.MakeArray(1024),this.m_velocityConstraints=e_.MakeArray(1024),this.m_count=0}Initialize(t){if(this.m_step.Copy(t.step),this.m_count=t.count,this.m_positionConstraints.length<this.m_count){const t=Wh(2*this.m_positionConstraints.length,this.m_count);for(;this.m_positionConstraints.length<t;)this.m_positionConstraints[this.m_positionConstraints.length]=new i_}if(this.m_velocityConstraints.length<this.m_count){const t=Wh(2*this.m_velocityConstraints.length,this.m_count);for(;this.m_velocityConstraints.length<t;)this.m_velocityConstraints[this.m_velocityConstraints.length]=new e_}this.m_positions=t.positions,this.m_velocities=t.velocities,this.m_contacts=t.contacts;for(let t=0;t<this.m_count;++t){const e=this.m_contacts[t],i=e.m_fixtureA,s=e.m_fixtureB,n=i.GetShape(),r=s.GetShape(),o=n.m_radius,a=r.m_radius,l=i.GetBody(),h=s.GetBody(),c=e.GetManifold(),m=c.pointCount,u=this.m_velocityConstraints[t];u.friction=e.m_friction,u.restitution=e.m_restitution,u.threshold=e.m_restitutionThreshold,u.tangentSpeed=e.m_tangentSpeed,u.indexA=l.m_islandIndex,u.indexB=h.m_islandIndex,u.invMassA=l.m_invMass,u.invMassB=h.m_invMass,u.invIA=l.m_invI,u.invIB=h.m_invI,u.contactIndex=t,u.pointCount=m,u.K.SetZero(),u.normalMass.SetZero();const _=this.m_positionConstraints[t];_.indexA=l.m_islandIndex,_.indexB=h.m_islandIndex,_.invMassA=l.m_invMass,_.invMassB=h.m_invMass,_.localCenterA.Copy(l.m_sweep.localCenter),_.localCenterB.Copy(h.m_sweep.localCenter),_.invIA=l.m_invI,_.invIB=h.m_invI,_.localNormal.Copy(c.localNormal),_.localPoint.Copy(c.localPoint),_.pointCount=m,_.radiusA=o,_.radiusB=a,_.type=c.type;for(let t=0;t<m;++t){const e=c.points[t],i=u.points[t];this.m_step.warmStarting?(i.normalImpulse=this.m_step.dtRatio*e.normalImpulse,i.tangentImpulse=this.m_step.dtRatio*e.tangentImpulse):(i.normalImpulse=0,i.tangentImpulse=0),i.rA.SetZero(),i.rB.SetZero(),i.normalMass=0,i.tangentMass=0,i.velocityBias=0,_.localPoints[t].Copy(e.localPoint)}}return this}InitializeVelocityConstraints(){const t=n_.InitializeVelocityConstraints_s_xfA,e=n_.InitializeVelocityConstraints_s_xfB,i=n_.InitializeVelocityConstraints_s_worldManifold;for(let s=0;s<this.m_count;++s){const n=this.m_velocityConstraints[s],r=this.m_positionConstraints[s],o=r.radiusA,a=r.radiusB,l=this.m_contacts[n.contactIndex].GetManifold(),h=n.indexA,c=n.indexB,m=n.invMassA,u=n.invMassB,_=n.invIA,d=n.invIB,p=r.localCenterA,f=r.localCenterB,y=this.m_positions[h].c,g=this.m_positions[h].a,x=this.m_velocities[h].v,v=this.m_velocities[h].w,S=this.m_positions[c].c,w=this.m_positions[c].a,b=this.m_velocities[c].v,C=this.m_velocities[c].w;t.q.SetAngle(g),e.q.SetAngle(w),Yh.SubVV(y,ec.MulRV(t.q,p,Yh.s_t0),t.p),Yh.SubVV(S,ec.MulRV(e.q,f,Yh.s_t0),e.p),i.Initialize(l,t,o,e,a),n.normal.Copy(i.normal),Yh.CrossVOne(n.normal,n.tangent);const A=n.pointCount;for(let t=0;t<A;++t){const e=n.points[t];Yh.SubVV(i.points[t],y,e.rA),Yh.SubVV(i.points[t],S,e.rB);const s=Yh.CrossVV(e.rA,n.normal),r=Yh.CrossVV(e.rB,n.normal),o=m+u+_*s*s+d*r*r;e.normalMass=o>0?1/o:0;const a=n.tangent,l=Yh.CrossVV(e.rA,a),h=Yh.CrossVV(e.rB,a),c=m+u+_*l*l+d*h*h;e.tangentMass=c>0?1/c:0,e.velocityBias=0;const p=Yh.DotVV(n.normal,Yh.SubVV(Yh.AddVCrossSV(b,C,e.rB,Yh.s_t0),Yh.AddVCrossSV(x,v,e.rA,Yh.s_t1),Yh.s_t0));p<-n.threshold&&(e.velocityBias+=-n.restitution*p)}n.pointCount,0}}WarmStart(){const t=n_.WarmStart_s_P;for(let e=0;e<this.m_count;++e){const i=this.m_velocityConstraints[e],s=i.indexA,n=i.indexB,r=i.invMassA,o=i.invIA,a=i.invMassB,l=i.invIB,h=i.pointCount,c=this.m_velocities[s].v;let m=this.m_velocities[s].w;const u=this.m_velocities[n].v;let _=this.m_velocities[n].w;const d=i.normal,p=i.tangent;for(let e=0;e<h;++e){const s=i.points[e];Yh.AddVV(Yh.MulSV(s.normalImpulse,d,Yh.s_t0),Yh.MulSV(s.tangentImpulse,p,Yh.s_t1),t),m-=o*Yh.CrossVV(s.rA,t),c.SelfMulSub(r,t),_+=l*Yh.CrossVV(s.rB,t),u.SelfMulAdd(a,t)}this.m_velocities[s].w=m,this.m_velocities[n].w=_}}SolveVelocityConstraints(){const t=n_.SolveVelocityConstraints_s_dv,e=(n_.SolveVelocityConstraints_s_dv1,n_.SolveVelocityConstraints_s_dv2,n_.SolveVelocityConstraints_s_P);n_.SolveVelocityConstraints_s_a,n_.SolveVelocityConstraints_s_b,n_.SolveVelocityConstraints_s_x,n_.SolveVelocityConstraints_s_d,n_.SolveVelocityConstraints_s_P1,n_.SolveVelocityConstraints_s_P2,n_.SolveVelocityConstraints_s_P1P2;for(let i=0;i<this.m_count;++i){const s=this.m_velocityConstraints[i],n=s.indexA,r=s.indexB,o=s.invMassA,a=s.invIA,l=s.invMassB,h=s.invIB,c=s.pointCount,m=this.m_velocities[n].v;let u=this.m_velocities[n].w;const _=this.m_velocities[r].v;let d=this.m_velocities[r].w;const p=s.normal,f=s.tangent,y=s.friction;for(let i=0;i<c;++i){const n=s.points[i];Yh.SubVV(Yh.AddVCrossSV(_,d,n.rB,Yh.s_t0),Yh.AddVCrossSV(m,u,n.rA,Yh.s_t1),t);const r=Yh.DotVV(t,f)-s.tangentSpeed;let c=n.tangentMass*-r;const p=y*n.normalImpulse,g=jh(n.tangentImpulse+c,-p,p);c=g-n.tangentImpulse,n.tangentImpulse=g,Yh.MulSV(c,f,e),m.SelfMulSub(o,e),u-=a*Yh.CrossVV(n.rA,e),_.SelfMulAdd(l,e),d+=h*Yh.CrossVV(n.rB,e)}s.pointCount;for(let i=0;i<c;++i){const n=s.points[i];Yh.SubVV(Yh.AddVCrossSV(_,d,n.rB,Yh.s_t0),Yh.AddVCrossSV(m,u,n.rA,Yh.s_t1),t);const r=Yh.DotVV(t,p);let c=-n.normalMass*(r-n.velocityBias);const f=Wh(n.normalImpulse+c,0);c=f-n.normalImpulse,n.normalImpulse=f,Yh.MulSV(c,p,e),m.SelfMulSub(o,e),u-=a*Yh.CrossVV(n.rA,e),_.SelfMulAdd(l,e),d+=h*Yh.CrossVV(n.rB,e)}this.m_velocities[n].w=u,this.m_velocities[r].w=d}}StoreImpulses(){for(let t=0;t<this.m_count;++t){const e=this.m_velocityConstraints[t],i=this.m_contacts[e.contactIndex].GetManifold();for(let t=0;t<e.pointCount;++t)i.points[t].normalImpulse=e.points[t].normalImpulse,i.points[t].tangentImpulse=e.points[t].tangentImpulse}}SolvePositionConstraints(){const t=n_.SolvePositionConstraints_s_xfA,e=n_.SolvePositionConstraints_s_xfB,i=n_.SolvePositionConstraints_s_psm,s=n_.SolvePositionConstraints_s_rA,n=n_.SolvePositionConstraints_s_rB,r=n_.SolvePositionConstraints_s_P;let o=0;for(let a=0;a<this.m_count;++a){const l=this.m_positionConstraints[a],h=l.indexA,c=l.indexB,m=l.localCenterA,u=l.invMassA,_=l.invIA,d=l.localCenterB,p=l.invMassB,f=l.invIB,y=l.pointCount,g=this.m_positions[h].c;let x=this.m_positions[h].a;const v=this.m_positions[c].c;let S=this.m_positions[c].a;for(let a=0;a<y;++a){t.q.SetAngle(x),e.q.SetAngle(S),Yh.SubVV(g,ec.MulRV(t.q,m,Yh.s_t0),t.p),Yh.SubVV(v,ec.MulRV(e.q,d,Yh.s_t0),e.p),i.Initialize(l,t,e,a);const h=i.normal,c=i.point,y=i.separation;Yh.SubVV(c,g,s),Yh.SubVV(c,v,n),o=Uh(o,y);const w=jh(.2*(y+Ph),-.2,0),b=Yh.CrossVV(s,h),C=Yh.CrossVV(n,h),A=u+p+_*b*b+f*C*C,B=A>0?-w/A:0;Yh.MulSV(B,h,r),g.SelfMulSub(u,r),x-=_*Yh.CrossVV(s,r),v.SelfMulAdd(p,r),S+=f*Yh.CrossVV(n,r)}this.m_positions[h].a=x,this.m_positions[c].a=S}return o>-.015}SolveTOIPositionConstraints(t,e){const i=n_.SolveTOIPositionConstraints_s_xfA,s=n_.SolveTOIPositionConstraints_s_xfB,n=n_.SolveTOIPositionConstraints_s_psm,r=n_.SolveTOIPositionConstraints_s_rA,o=n_.SolveTOIPositionConstraints_s_rB,a=n_.SolveTOIPositionConstraints_s_P;let l=0;for(let h=0;h<this.m_count;++h){const c=this.m_positionConstraints[h],m=c.indexA,u=c.indexB,_=c.localCenterA,d=c.localCenterB,p=c.pointCount;let f=0,y=0;m!==t&&m!==e||(f=c.invMassA,y=c.invIA);let g=0,x=0;u!==t&&u!==e||(g=c.invMassB,x=c.invIB);const v=this.m_positions[m].c;let S=this.m_positions[m].a;const w=this.m_positions[u].c;let b=this.m_positions[u].a;for(let t=0;t<p;++t){i.q.SetAngle(S),s.q.SetAngle(b),Yh.SubVV(v,ec.MulRV(i.q,_,Yh.s_t0),i.p),Yh.SubVV(w,ec.MulRV(s.q,d,Yh.s_t0),s.p),n.Initialize(c,i,s,t);const e=n.normal,h=n.point,m=n.separation;Yh.SubVV(h,v,r),Yh.SubVV(h,w,o),l=Uh(l,m);const u=jh(.75*(m+Ph),-.2,0),p=Yh.CrossVV(r,e),C=Yh.CrossVV(o,e),A=f+g+y*p*p+x*C*C,B=A>0?-u/A:0;Yh.MulSV(B,e,a),v.SelfMulSub(f,a),S-=y*Yh.CrossVV(r,a),w.SelfMulAdd(g,a),b+=x*Yh.CrossVV(o,a)}this.m_positions[m].a=S,this.m_positions[u].a=b}return l>=-.0075}}n_.InitializeVelocityConstraints_s_xfA=new ic,n_.InitializeVelocityConstraints_s_xfB=new ic,n_.InitializeVelocityConstraints_s_worldManifold=new Mc,n_.WarmStart_s_P=new Yh,n_.SolveVelocityConstraints_s_dv=new Yh,n_.SolveVelocityConstraints_s_dv1=new Yh,n_.SolveVelocityConstraints_s_dv2=new Yh,n_.SolveVelocityConstraints_s_P=new Yh,n_.SolveVelocityConstraints_s_a=new Yh,n_.SolveVelocityConstraints_s_b=new Yh,n_.SolveVelocityConstraints_s_x=new Yh,n_.SolveVelocityConstraints_s_d=new Yh,n_.SolveVelocityConstraints_s_P1=new Yh,n_.SolveVelocityConstraints_s_P2=new Yh,n_.SolveVelocityConstraints_s_P1P2=new Yh,n_.SolvePositionConstraints_s_xfA=new ic,n_.SolvePositionConstraints_s_xfB=new ic,n_.SolvePositionConstraints_s_psm=new s_,n_.SolvePositionConstraints_s_rA=new Yh,n_.SolvePositionConstraints_s_rB=new Yh,n_.SolvePositionConstraints_s_P=new Yh,n_.SolveTOIPositionConstraints_s_xfA=new ic,n_.SolveTOIPositionConstraints_s_xfB=new ic,n_.SolveTOIPositionConstraints_s_psm=new s_,n_.SolveTOIPositionConstraints_s_rA=new Yh,n_.SolveTOIPositionConstraints_s_rB=new Yh,n_.SolveTOIPositionConstraints_s_P=new Yh;class r_ extends Cu{constructor(t){super(t),this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_linearImpulse=new Yh,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new $h,this.m_angularMass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_K=new $h,this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=Ah(t.maxForce,0),this.m_maxTorque=Ah(t.maxTorque,0),this.m_linearMass.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const h=ec.MulRV(a,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const c=ec.MulRV(l,this.m_lalcB,this.m_rB),m=this.m_invMassA,u=this.m_invMassB,_=this.m_invIA,d=this.m_invIB,p=this.m_K;if(p.ex.x=m+u+_*h.y*h.y+d*c.y*c.y,p.ex.y=-_*h.x*h.y-d*c.x*c.y,p.ey.x=p.ex.y,p.ey.y=m+u+_*h.x*h.x+d*c.x*c.x,p.GetInverse(this.m_linearMass),this.m_angularMass=_+d,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;i.SelfMulSub(m,e),s-=_*(Yh.CrossVV(this.m_rA,e)+this.m_angularImpulse),r.SelfMulAdd(u,e),o+=d*(Yh.CrossVV(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=t.step.dt;{const t=n-i;let e=-this.m_angularMass*t;const s=this.m_angularImpulse,r=h*this.m_maxTorque;this.m_angularImpulse=jh(this.m_angularImpulse+e,-r,r),e=this.m_angularImpulse-s,i-=a*e,n+=l*e}{const t=Yh.SubVV(Yh.AddVCrossSV(s,n,this.m_rB,Yh.s_t0),Yh.AddVCrossSV(e,i,this.m_rA,Yh.s_t1),r_.SolveVelocityConstraints_s_Cdot_v2),c=$h.MulMV(this.m_linearMass,t,r_.SolveVelocityConstraints_s_impulseV).SelfNeg(),m=r_.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(c);const u=h*this.m_maxForce;this.m_linearImpulse.LengthSquared()>u*u&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(u)),Yh.SubVV(this.m_linearImpulse,m,c),e.SelfMulSub(r,c),i-=a*Yh.CrossVV(this.m_rA,c),s.SelfMulAdd(o,c),n+=l*Yh.CrossVV(this.m_rB,c)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_linearImpulse.x,e.y=t*this.m_linearImpulse.y,e}GetReactionTorque(t){return t*this.m_angularImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}r_.SolveVelocityConstraints_s_Cdot_v2=new Yh,r_.SolveVelocityConstraints_s_impulseV=new Yh,r_.SolveVelocityConstraints_s_oldImpulseV=new Yh;class o_ extends Cu{constructor(t){let e,i;super(t),this.m_typeA=vu.e_unknownJoint,this.m_typeB=vu.e_unknownJoint,this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_localAnchorC=new Yh,this.m_localAnchorD=new Yh,this.m_localAxisC=new Yh,this.m_localAxisD=new Yh,this.m_referenceAngleA=0,this.m_referenceAngleB=0,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_indexC=0,this.m_indexD=0,this.m_lcA=new Yh,this.m_lcB=new Yh,this.m_lcC=new Yh,this.m_lcD=new Yh,this.m_mA=0,this.m_mB=0,this.m_mC=0,this.m_mD=0,this.m_iA=0,this.m_iB=0,this.m_iC=0,this.m_iD=0,this.m_JvAC=new Yh,this.m_JvBD=new Yh,this.m_JwA=0,this.m_JwB=0,this.m_JwC=0,this.m_JwD=0,this.m_mass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_qC=new ec,this.m_qD=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_lalcC=new Yh,this.m_lalcD=new Yh,this.m_joint1=t.joint1,this.m_joint2=t.joint2,this.m_typeA=this.m_joint1.GetType(),this.m_typeB=this.m_joint2.GetType(),this.m_bodyC=this.m_joint1.GetBodyA(),this.m_bodyA=this.m_joint1.GetBodyB();const s=this.m_bodyA.m_xf,n=this.m_bodyA.m_sweep.a,r=this.m_bodyC.m_xf,o=this.m_bodyC.m_sweep.a;if(this.m_typeA===vu.e_revoluteJoint){const i=t.joint1;this.m_localAnchorC.Copy(i.m_localAnchorA),this.m_localAnchorA.Copy(i.m_localAnchorB),this.m_referenceAngleA=i.m_referenceAngle,this.m_localAxisC.SetZero(),e=n-o-this.m_referenceAngleA}else{const i=t.joint1;this.m_localAnchorC.Copy(i.m_localAnchorA),this.m_localAnchorA.Copy(i.m_localAnchorB),this.m_referenceAngleA=i.m_referenceAngle,this.m_localAxisC.Copy(i.m_localXAxisA);const n=this.m_localAnchorC,o=ec.MulTRV(r.q,Yh.AddVV(ec.MulRV(s.q,this.m_localAnchorA,Yh.s_t0),Yh.SubVV(s.p,r.p,Yh.s_t1),Yh.s_t0),Yh.s_t0);e=Yh.DotVV(Yh.SubVV(o,n,Yh.s_t0),this.m_localAxisC)}this.m_bodyD=this.m_joint2.GetBodyA(),this.m_bodyB=this.m_joint2.GetBodyB();const a=this.m_bodyB.m_xf,l=this.m_bodyB.m_sweep.a,h=this.m_bodyD.m_xf,c=this.m_bodyD.m_sweep.a;if(this.m_typeB===vu.e_revoluteJoint){const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.SetZero(),i=l-c-this.m_referenceAngleB}else{const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.Copy(e.m_localXAxisA);const s=this.m_localAnchorD,n=ec.MulTRV(h.q,Yh.AddVV(ec.MulRV(a.q,this.m_localAnchorB,Yh.s_t0),Yh.SubVV(a.p,h.p,Yh.s_t1),Yh.s_t0),Yh.s_t0);i=Yh.DotVV(Yh.SubVV(n,s,Yh.s_t0),this.m_localAxisD)}this.m_ratio=Ah(t.ratio,1),this.m_constant=e+this.m_ratio*i,this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_indexC=this.m_bodyC.m_islandIndex,this.m_indexD=this.m_bodyD.m_islandIndex,this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter),this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter),this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=t.positions[this.m_indexC].a,l=t.velocities[this.m_indexC].v;let h=t.velocities[this.m_indexC].w;const c=t.positions[this.m_indexD].a,m=t.velocities[this.m_indexD].v;let u=t.velocities[this.m_indexD].w;const _=this.m_qA.SetAngle(e),d=this.m_qB.SetAngle(n),p=this.m_qC.SetAngle(a),f=this.m_qD.SetAngle(c);if(this.m_mass=0,this.m_typeA===vu.e_revoluteJoint)this.m_JvAC.SetZero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const t=ec.MulRV(p,this.m_localAxisC,o_.InitVelocityConstraints_s_u);Yh.SubVV(this.m_localAnchorC,this.m_lcC,this.m_lalcC);const e=ec.MulRV(p,this.m_lalcC,o_.InitVelocityConstraints_s_rC);Yh.SubVV(this.m_localAnchorA,this.m_lcA,this.m_lalcA);const i=ec.MulRV(_,this.m_lalcA,o_.InitVelocityConstraints_s_rA);this.m_JvAC.Copy(t),this.m_JwC=Yh.CrossVV(e,t),this.m_JwA=Yh.CrossVV(i,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_typeB===vu.e_revoluteJoint)this.m_JvBD.SetZero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const t=ec.MulRV(f,this.m_localAxisD,o_.InitVelocityConstraints_s_u);Yh.SubVV(this.m_localAnchorD,this.m_lcD,this.m_lalcD);const e=ec.MulRV(f,this.m_lalcD,o_.InitVelocityConstraints_s_rD);Yh.SubVV(this.m_localAnchorB,this.m_lcB,this.m_lalcB);const i=ec.MulRV(d,this.m_lalcB,o_.InitVelocityConstraints_s_rB);Yh.MulSV(this.m_ratio,t,this.m_JvBD),this.m_JwD=this.m_ratio*Yh.CrossVV(e,t),this.m_JwB=this.m_ratio*Yh.CrossVV(i,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,t.step.warmStarting?(i.SelfMulAdd(this.m_mA*this.m_impulse,this.m_JvAC),s+=this.m_iA*this.m_impulse*this.m_JwA,r.SelfMulAdd(this.m_mB*this.m_impulse,this.m_JvBD),o+=this.m_iB*this.m_impulse*this.m_JwB,l.SelfMulSub(this.m_mC*this.m_impulse,this.m_JvAC),h-=this.m_iC*this.m_impulse*this.m_JwC,m.SelfMulSub(this.m_mD*this.m_impulse,this.m_JvBD),u-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o,t.velocities[this.m_indexC].w=h,t.velocities[this.m_indexD].w=u}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=t.velocities[this.m_indexC].v;let o=t.velocities[this.m_indexC].w;const a=t.velocities[this.m_indexD].v;let l=t.velocities[this.m_indexD].w,h=Yh.DotVV(this.m_JvAC,Yh.SubVV(e,r,Yh.s_t0))+Yh.DotVV(this.m_JvBD,Yh.SubVV(s,a,Yh.s_t0));h+=this.m_JwA*i-this.m_JwC*o+(this.m_JwB*n-this.m_JwD*l);const c=-this.m_mass*h;this.m_impulse+=c,e.SelfMulAdd(this.m_mA*c,this.m_JvAC),i+=this.m_iA*c*this.m_JwA,s.SelfMulAdd(this.m_mB*c,this.m_JvBD),n+=this.m_iB*c*this.m_JwB,r.SelfMulSub(this.m_mC*c,this.m_JvAC),o-=this.m_iC*c*this.m_JwC,a.SelfMulSub(this.m_mD*c,this.m_JvBD),l-=this.m_iD*c*this.m_JwD,t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n,t.velocities[this.m_indexC].w=o,t.velocities[this.m_indexD].w=l}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=t.positions[this.m_indexC].c;let o=t.positions[this.m_indexC].a;const a=t.positions[this.m_indexD].c;let l=t.positions[this.m_indexD].a;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(n),m=this.m_qC.SetAngle(o),u=this.m_qD.SetAngle(l);let _,d;const p=this.m_JvAC,f=this.m_JvBD;let y,g,x,v,S=0;if(this.m_typeA===vu.e_revoluteJoint)p.SetZero(),y=1,x=1,S+=this.m_iA+this.m_iC,_=i-o-this.m_referenceAngleA;else{const t=ec.MulRV(m,this.m_localAxisC,o_.SolvePositionConstraints_s_u),i=ec.MulRV(m,this.m_lalcC,o_.SolvePositionConstraints_s_rC),s=ec.MulRV(h,this.m_lalcA,o_.SolvePositionConstraints_s_rA);p.Copy(t),x=Yh.CrossVV(i,t),y=Yh.CrossVV(s,t),S+=this.m_mC+this.m_mA+this.m_iC*x*x+this.m_iA*y*y;const n=this.m_lalcC,o=ec.MulTRV(m,Yh.AddVV(s,Yh.SubVV(e,r,Yh.s_t0),Yh.s_t0),Yh.s_t0);_=Yh.DotVV(Yh.SubVV(o,n,Yh.s_t0),this.m_localAxisC)}if(this.m_typeB===vu.e_revoluteJoint)f.SetZero(),g=this.m_ratio,v=this.m_ratio,S+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),d=n-l-this.m_referenceAngleB;else{const t=ec.MulRV(u,this.m_localAxisD,o_.SolvePositionConstraints_s_u),e=ec.MulRV(u,this.m_lalcD,o_.SolvePositionConstraints_s_rD),i=ec.MulRV(c,this.m_lalcB,o_.SolvePositionConstraints_s_rB);Yh.MulSV(this.m_ratio,t,f),v=this.m_ratio*Yh.CrossVV(e,t),g=this.m_ratio*Yh.CrossVV(i,t),S+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*v*v+this.m_iB*g*g;const n=this.m_lalcD,r=ec.MulTRV(u,Yh.AddVV(i,Yh.SubVV(s,a,Yh.s_t0),Yh.s_t0),Yh.s_t0);d=Yh.DotVV(Yh.SubVV(r,n,Yh.s_t0),this.m_localAxisD)}const w=_+this.m_ratio*d-this.m_constant;let b=0;return S>0&&(b=-w/S),e.SelfMulAdd(this.m_mA*b,p),i+=this.m_iA*b*y,s.SelfMulAdd(this.m_mB*b,f),n+=this.m_iB*b*g,r.SelfMulSub(this.m_mC*b,p),o-=this.m_iC*b*x,a.SelfMulSub(this.m_mD*b,f),l-=this.m_iD*b*v,t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,t.positions[this.m_indexC].a=o,t.positions[this.m_indexD].a=l,!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return Yh.MulSV(t*this.m_impulse,this.m_JvAC,e)}GetReactionTorque(t){return t*this.m_impulse*this.m_JwA}GetJoint1(){return this.m_joint1}GetJoint2(){return this.m_joint2}GetRatio(){return this.m_ratio}SetRatio(t){this.m_ratio=t}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex,s=this.m_joint1.m_index,n=this.m_joint2.m_index;t("  const jd: b2GearJointDef = new b2GearJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.joint1 = joints[%d];\n",s),t("  jd.joint2 = joints[%d];\n",n),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}o_.InitVelocityConstraints_s_u=new Yh,o_.InitVelocityConstraints_s_rA=new Yh,o_.InitVelocityConstraints_s_rB=new Yh,o_.InitVelocityConstraints_s_rC=new Yh,o_.InitVelocityConstraints_s_rD=new Yh,o_.SolvePositionConstraints_s_u=new Yh,o_.SolvePositionConstraints_s_rA=new Yh,o_.SolvePositionConstraints_s_rB=new Yh,o_.SolvePositionConstraints_s_rC=new Yh,o_.SolvePositionConstraints_s_rD=new Yh;class a_{constructor(){this.m_bodies=[],this.m_contacts=[],this.m_joints=[],this.m_positions=Ku.MakeArray(1024),this.m_velocities=$u.MakeArray(1024),this.m_bodyCount=0,this.m_jointCount=0,this.m_contactCount=0,this.m_bodyCapacity=0,this.m_contactCapacity=0,this.m_jointCapacity=0}Initialize(t,e,i,s){if(this.m_bodyCapacity=t,this.m_contactCapacity=e,this.m_jointCapacity=i,this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0,this.m_listener=s,this.m_positions.length<t){const e=Wh(2*this.m_positions.length,t);for(;this.m_positions.length<e;)this.m_positions[this.m_positions.length]=new Ku}if(this.m_velocities.length<t){const e=Wh(2*this.m_velocities.length,t);for(;this.m_velocities.length<e;)this.m_velocities[this.m_velocities.length]=new $u}}Clear(){this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0}AddBody(t){t.m_islandIndex=this.m_bodyCount,this.m_bodies[this.m_bodyCount++]=t}AddContact(t){this.m_contacts[this.m_contactCount++]=t}AddJoint(t){this.m_joints[this.m_jointCount++]=t}Solve(t,e,i,s){const n=a_.s_timer.Reset(),r=e.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c);const s=e.m_sweep.a,n=this.m_velocities[t].v.Copy(e.m_linearVelocity);let o=e.m_angularVelocity;e.m_sweep.c0.Copy(e.m_sweep.c),e.m_sweep.a0=e.m_sweep.a,e.m_type===Su.b2_dynamicBody&&(n.x+=r*e.m_invMass*(e.m_gravityScale*e.m_mass*i.x+e.m_force.x),n.y+=r*e.m_invMass*(e.m_gravityScale*e.m_mass*i.y+e.m_force.y),o+=r*e.m_invI*e.m_torque,n.SelfMul(1/(1+r*e.m_linearDamping)),o*=1/(1+r*e.m_angularDamping)),this.m_positions[t].a=s,this.m_velocities[t].w=o}n.Reset();const o=a_.s_solverData;o.step.Copy(e),o.positions=this.m_positions,o.velocities=this.m_velocities;const a=a_.s_contactSolverDef;a.step.Copy(e),a.contacts=this.m_contacts,a.count=this.m_contactCount,a.positions=this.m_positions,a.velocities=this.m_velocities;const l=a_.s_contactSolver.Initialize(a);l.InitializeVelocityConstraints(),e.warmStarting&&l.WarmStart();for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].InitVelocityConstraints(o);t.solveInit=n.GetMilliseconds(),n.Reset();for(let t=0;t<e.velocityIterations;++t){for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].SolveVelocityConstraints(o);l.SolveVelocityConstraints()}l.StoreImpulses(),t.solveVelocity=n.GetMilliseconds();for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let i=this.m_positions[t].a;const s=this.m_velocities[t].v;let n=this.m_velocities[t].w;const o=Yh.MulSV(r,s,a_.s_translation);if(Yh.DotVV(o,o)>4){const t=2/o.Length();s.SelfMul(t)}const a=r*n;a*a>Lh&&(n*=Rh/Nh(a)),e.x+=r*s.x,e.y+=r*s.y,i+=r*n,this.m_positions[t].a=i,this.m_velocities[t].w=n}n.Reset();let h=!1;for(let t=0;t<e.positionIterations;++t){const t=l.SolvePositionConstraints();let e=!0;for(let t=0;t<this.m_jointCount;++t){const i=this.m_joints[t].SolvePositionConstraints(o);e=e&&i}if(t&&e){h=!0;break}}for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];e.m_sweep.c.Copy(this.m_positions[t].c),e.m_sweep.a=this.m_positions[t].a,e.m_linearVelocity.Copy(this.m_velocities[t].v),e.m_angularVelocity=this.m_velocities[t].w,e.SynchronizeTransform()}if(t.solvePosition=n.GetMilliseconds(),this.Report(l.m_velocityConstraints),s){let t=Bh;const e=1e-4,i=.0012184696791469947;for(let s=0;s<this.m_bodyCount;++s){const n=this.m_bodies[s];n.GetType()!==Su.b2_staticBody&&(!n.m_autoSleepFlag||n.m_angularVelocity*n.m_angularVelocity>i||Yh.DotVV(n.m_linearVelocity,n.m_linearVelocity)>e?(n.m_sleepTime=0,t=0):(n.m_sleepTime+=r,t=Uh(t,n.m_sleepTime)))}if(t>=.5&&h)for(let t=0;t<this.m_bodyCount;++t)this.m_bodies[t].SetAwake(!1)}}SolveTOI(t,e,i){for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c),this.m_positions[t].a=e.m_sweep.a,this.m_velocities[t].v.Copy(e.m_linearVelocity),this.m_velocities[t].w=e.m_angularVelocity}const s=a_.s_contactSolverDef;s.contacts=this.m_contacts,s.count=this.m_contactCount,s.step.Copy(t),s.positions=this.m_positions,s.velocities=this.m_velocities;const n=a_.s_contactSolver.Initialize(s);for(let s=0;s<t.positionIterations&&!n.SolveTOIPositionConstraints(e,i);++s);this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c),this.m_bodies[e].m_sweep.a0=this.m_positions[e].a,this.m_bodies[i].m_sweep.c0.Copy(this.m_positions[i].c),this.m_bodies[i].m_sweep.a0=this.m_positions[i].a,n.InitializeVelocityConstraints();for(let e=0;e<t.velocityIterations;++e)n.SolveVelocityConstraints();const r=t.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let i=this.m_positions[t].a;const s=this.m_velocities[t].v;let n=this.m_velocities[t].w;const o=Yh.MulSV(r,s,a_.s_translation);if(Yh.DotVV(o,o)>4){const t=2/o.Length();s.SelfMul(t)}const a=r*n;a*a>Lh&&(n*=Rh/Nh(a)),e.SelfMulAdd(r,s),i+=r*n,this.m_positions[t].a=i,this.m_velocities[t].w=n;const l=this.m_bodies[t];l.m_sweep.c.Copy(e),l.m_sweep.a=i,l.m_linearVelocity.Copy(s),l.m_angularVelocity=n,l.SynchronizeTransform()}this.Report(n.m_velocityConstraints)}Report(t){if(null!==this.m_listener)for(let e=0;e<this.m_contactCount;++e){const i=this.m_contacts[e];if(!i)continue;const s=t[e],n=a_.s_impulse;n.count=s.pointCount;for(let t=0;t<s.pointCount;++t)n.normalImpulses[t]=s.points[t].normalImpulse,n.tangentImpulses[t]=s.points[t].tangentImpulse;this.m_listener.PostSolve(i,n)}}}a_.s_timer=new Jm,a_.s_solverData=new class{constructor(){this.step=new Qu}},a_.s_contactSolverDef=new class{constructor(){this.step=new Qu,this.count=0}},a_.s_contactSolver=new n_,a_.s_translation=new Yh,a_.s_impulse=new class{constructor(){this.normalImpulses=kh(2),this.tangentImpulses=kh(2),this.count=0}};class l_ extends Cu{constructor(t){super(t),this.m_linearOffset=new Yh,this.m_angularOffset=0,this.m_linearImpulse=new Yh,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_correctionFactor=.3,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_linearError=new Yh,this.m_angularError=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new $h,this.m_angularMass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_K=new $h,this.m_linearOffset.Copy(Ah(t.linearOffset,Yh.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=Ah(t.maxForce,0),this.m_maxTorque=Ah(t.maxTorque,0),this.m_correctionFactor=Ah(t.correctionFactor,.3)}GetAnchorA(t){const e=this.m_bodyA.GetPosition();return t.x=e.x,t.y=e.y,t}GetAnchorB(t){const e=this.m_bodyB.GetPosition();return t.x=e.x,t.y=e.y,t}GetReactionForce(t,e){return Yh.MulSV(t,this.m_linearImpulse,e)}GetReactionTorque(t){return t*this.m_angularImpulse}SetLinearOffset(t){Yh.IsEqualToV(t,this.m_linearOffset)||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_linearOffset.Copy(t))}GetLinearOffset(){return this.m_linearOffset}SetAngularOffset(t){t!==this.m_angularOffset&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_angularOffset=t)}GetAngularOffset(){return this.m_angularOffset}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o),m=ec.MulRV(h,Yh.SubVV(this.m_linearOffset,this.m_localCenterA,Yh.s_t0),this.m_rA),u=ec.MulRV(c,Yh.NegV(this.m_localCenterB,Yh.s_t0),this.m_rB),_=this.m_invMassA,d=this.m_invMassB,p=this.m_invIA,f=this.m_invIB,y=this.m_K;if(y.ex.x=_+d+p*m.y*m.y+f*u.y*u.y,y.ex.y=-p*m.x*m.y-f*u.x*u.y,y.ey.x=y.ex.y,y.ey.y=_+d+p*m.x*m.x+f*u.x*u.x,y.GetInverse(this.m_linearMass),this.m_angularMass=p+f,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),Yh.SubVV(Yh.AddVV(r,u,Yh.s_t0),Yh.AddVV(e,m,Yh.s_t1),this.m_linearError),this.m_angularError=o-i-this.m_angularOffset,t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;s.SelfMulSub(_,e),n-=p*(Yh.CrossVV(m,e)+this.m_angularImpulse),a.SelfMulAdd(d,e),l+=f*(Yh.CrossVV(u,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=t.step.dt,c=t.step.inv_dt;{const t=n-i+c*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const s=this.m_angularImpulse,r=h*this.m_maxTorque;this.m_angularImpulse=jh(this.m_angularImpulse+e,-r,r),e=this.m_angularImpulse-s,i-=a*e,n+=l*e}{const t=this.m_rA,m=this.m_rB,u=Yh.AddVV(Yh.SubVV(Yh.AddVV(s,Yh.CrossSV(n,m,Yh.s_t0),Yh.s_t0),Yh.AddVV(e,Yh.CrossSV(i,t,Yh.s_t1),Yh.s_t1),Yh.s_t2),Yh.MulSV(c*this.m_correctionFactor,this.m_linearError,Yh.s_t3),l_.SolveVelocityConstraints_s_Cdot_v2),_=$h.MulMV(this.m_linearMass,u,l_.SolveVelocityConstraints_s_impulse_v2).SelfNeg(),d=l_.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(_);const p=h*this.m_maxForce;this.m_linearImpulse.LengthSquared()>p*p&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(p)),Yh.SubVV(this.m_linearImpulse,d,_),e.SelfMulSub(r,_),i-=a*Yh.CrossVV(t,_),s.SelfMulAdd(o,_),n+=l*Yh.CrossVV(m,_)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2MotorJointDef = new b2MotorJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.linearOffset.Set(%.15f, %.15f);\n",this.m_linearOffset.x,this.m_linearOffset.y),t("  jd.angularOffset = %.15f;\n",this.m_angularOffset),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  jd.correctionFactor = %.15f;\n",this.m_correctionFactor),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}l_.SolveVelocityConstraints_s_Cdot_v2=new Yh,l_.SolveVelocityConstraints_s_impulse_v2=new Yh,l_.SolveVelocityConstraints_s_oldImpulse_v2=new Yh;class h_ extends Cu{constructor(t){super(t),this.m_localAnchorB=new Yh,this.m_targetA=new Yh,this.m_stiffness=0,this.m_damping=0,this.m_beta=0,this.m_impulse=new Yh,this.m_maxForce=0,this.m_gamma=0,this.m_indexA=0,this.m_indexB=0,this.m_rB=new Yh,this.m_localCenterB=new Yh,this.m_invMassB=0,this.m_invIB=0,this.m_mass=new $h,this.m_C=new Yh,this.m_qB=new ec,this.m_lalcB=new Yh,this.m_K=new $h,this.m_targetA.Copy(Ah(t.target,Yh.ZERO)),ic.MulTXV(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB),this.m_maxForce=Ah(t.maxForce,0),this.m_impulse.SetZero(),this.m_stiffness=Ah(t.stiffness,0),this.m_damping=Ah(t.damping,0),this.m_beta=0,this.m_gamma=0}SetTarget(t){this.m_bodyB.IsAwake()||this.m_bodyB.SetAwake(!0),this.m_targetA.Copy(t)}GetTarget(){return this.m_targetA}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexB].c,i=t.positions[this.m_indexB].a,s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_qB.SetAngle(i),o=this.m_bodyB.GetMass(),a=6.28318530718*this.m_stiffness,l=2*o*this.m_damping*a,h=o*(a*a),c=t.step.dt;this.m_gamma=c*(l+c*h),0!==this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=c*h*this.m_gamma,Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),ec.MulRV(r,this.m_lalcB,this.m_rB);const m=this.m_K;m.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,m.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,m.ey.x=m.ex.y,m.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,m.GetInverse(this.m_mass),this.m_C.x=e.x+this.m_rB.x-this.m_targetA.x,this.m_C.y=e.y+this.m_rB.y-this.m_targetA.y,this.m_C.SelfMul(this.m_beta),n*=.98,t.step.warmStarting?(this.m_impulse.SelfMul(t.step.dtRatio),s.x+=this.m_invMassB*this.m_impulse.x,s.y+=this.m_invMassB*this.m_impulse.y,n+=this.m_invIB*Yh.CrossVV(this.m_rB,this.m_impulse)):this.m_impulse.SetZero(),t.velocities[this.m_indexB].w=n}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexB].v;let i=t.velocities[this.m_indexB].w;const s=Yh.AddVCrossSV(e,i,this.m_rB,h_.SolveVelocityConstraints_s_Cdot),n=$h.MulMV(this.m_mass,Yh.AddVV(s,Yh.AddVV(this.m_C,Yh.MulSV(this.m_gamma,this.m_impulse,Yh.s_t0),Yh.s_t0),Yh.s_t0).SelfNeg(),h_.SolveVelocityConstraints_s_impulse),r=h_.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);this.m_impulse.SelfAdd(n);const o=t.step.dt*this.m_maxForce;this.m_impulse.LengthSquared()>o*o&&this.m_impulse.SelfMul(o/this.m_impulse.Length()),Yh.SubVV(this.m_impulse,r,n),e.SelfMulAdd(this.m_invMassB,n),i+=this.m_invIB*Yh.CrossVV(this.m_rB,n),t.velocities[this.m_indexB].w=i}SolvePositionConstraints(t){return!0}GetAnchorA(t){return t.x=this.m_targetA.x,t.y=this.m_targetA.y,t}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return Yh.MulSV(t,this.m_impulse,e)}GetReactionTorque(t){return 0}Dump(t){t("Mouse joint dumping is not supported.\n")}ShiftOrigin(t){this.m_targetA.SelfSub(t)}}h_.SolveVelocityConstraints_s_Cdot=new Yh,h_.SolveVelocityConstraints_s_impulse=new Yh,h_.SolveVelocityConstraints_s_oldImpulse=new Yh;class c_ extends Cu{constructor(t){super(t),this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_localXAxisA=new Yh,this.m_localYAxisA=new Yh,this.m_referenceAngle=0,this.m_impulse=new Yh(0,0),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorForce=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_axis=new Yh(0,0),this.m_perp=new Yh(0,0),this.m_s1=0,this.m_s2=0,this.m_a1=0,this.m_a2=0,this.m_K=new $h,this.m_K3=new tc,this.m_K2=new $h,this.m_translation=0,this.m_axialMass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_localXAxisA.Copy(Ah(t.localAxisA,new Yh(1,0))).SelfNormalize(),Yh.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_referenceAngle=Ah(t.referenceAngle,0),this.m_lowerTranslation=Ah(t.lowerTranslation,0),this.m_upperTranslation=Ah(t.upperTranslation,0),this.m_maxMotorForce=Ah(t.maxMotorForce,0),this.m_motorSpeed=Ah(t.motorSpeed,0),this.m_enableLimit=Ah(t.enableLimit,!1),this.m_enableMotor=Ah(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=ec.MulRV(h,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const u=ec.MulRV(c,this.m_lalcB,this.m_rB),_=Yh.AddVV(Yh.SubVV(r,e,Yh.s_t0),Yh.SubVV(u,m,Yh.s_t1),c_.InitVelocityConstraints_s_d),d=this.m_invMassA,p=this.m_invMassB,f=this.m_invIA,y=this.m_invIB;if(ec.MulRV(h,this.m_localXAxisA,this.m_axis),this.m_a1=Yh.CrossVV(Yh.AddVV(_,m,Yh.s_t0),this.m_axis),this.m_a2=Yh.CrossVV(u,this.m_axis),this.m_axialMass=d+p+f*this.m_a1*this.m_a1+y*this.m_a2*this.m_a2,this.m_axialMass>0&&(this.m_axialMass=1/this.m_axialMass),ec.MulRV(h,this.m_localYAxisA,this.m_perp),this.m_s1=Yh.CrossVV(Yh.AddVV(_,m,Yh.s_t0),this.m_perp),this.m_s2=Yh.CrossVV(u,this.m_perp),this.m_K.ex.x=d+p+f*this.m_s1*this.m_s1+y*this.m_s2*this.m_s2,this.m_K.ex.y=f*this.m_s1+y*this.m_s2,this.m_K.ey.x=this.m_K.ex.y,this.m_K.ey.y=f+y,0===this.m_K.ey.y&&(this.m_K.ey.y=1),this.m_enableLimit?this.m_translation=Yh.DotVV(this.m_axis,_):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor||(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,i=Yh.AddVV(Yh.MulSV(this.m_impulse.x,this.m_perp,Yh.s_t0),Yh.MulSV(e,this.m_axis,Yh.s_t1),c_.InitVelocityConstraints_s_P),r=this.m_impulse.x*this.m_s1+this.m_impulse.y+e*this.m_a1,o=this.m_impulse.x*this.m_s2+this.m_impulse.y+e*this.m_a2;s.SelfMulSub(d,i),n-=f*r,a.SelfMulAdd(p,i),l+=y*o}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB;if(this.m_enableMotor){const h=Yh.DotVV(this.m_axis,Yh.SubVV(s,e,Yh.s_t0))+this.m_a2*n-this.m_a1*i;let c=this.m_axialMass*(this.m_motorSpeed-h);const m=this.m_motorImpulse,u=t.step.dt*this.m_maxMotorForce;this.m_motorImpulse=jh(this.m_motorImpulse+c,-u,u),c=this.m_motorImpulse-m;const _=Yh.MulSV(c,this.m_axis,c_.SolveVelocityConstraints_s_P),d=c*this.m_a1,p=c*this.m_a2;e.SelfMulSub(r,_),i-=a*d,s.SelfMulAdd(o,_),n+=l*p}if(this.m_enableLimit){{const h=this.m_translation-this.m_lowerTranslation,c=Yh.DotVV(this.m_axis,Yh.SubVV(s,e,Yh.s_t0))+this.m_a2*n-this.m_a1*i;let m=-this.m_axialMass*(c+Wh(h,0)*t.step.inv_dt);const u=this.m_lowerImpulse;this.m_lowerImpulse=Wh(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-u;const _=Yh.MulSV(m,this.m_axis,c_.SolveVelocityConstraints_s_P),d=m*this.m_a1,p=m*this.m_a2;e.SelfMulSub(r,_),i-=a*d,s.SelfMulAdd(o,_),n+=l*p}{const h=this.m_upperTranslation-this.m_translation,c=Yh.DotVV(this.m_axis,Yh.SubVV(e,s,Yh.s_t0))+this.m_a1*i-this.m_a2*n;let m=-this.m_axialMass*(c+Wh(h,0)*t.step.inv_dt);const u=this.m_upperImpulse;this.m_upperImpulse=Wh(this.m_upperImpulse+m,0),m=this.m_upperImpulse-u;const _=Yh.MulSV(m,this.m_axis,c_.SolveVelocityConstraints_s_P),d=m*this.m_a1,p=m*this.m_a2;e.SelfMulAdd(r,_),i+=a*d,s.SelfMulSub(o,_),n-=l*p}}{const t=Yh.DotVV(this.m_perp,Yh.SubVV(s,e,Yh.s_t0))+this.m_s2*n-this.m_s1*i,h=n-i,c=this.m_K.Solve(-t,-h,c_.SolveVelocityConstraints_s_df);this.m_impulse.SelfAdd(c);const m=Yh.MulSV(c.x,this.m_perp,c_.SolveVelocityConstraints_s_P),u=c.x*this.m_s1+c.y,_=c.x*this.m_s2+c.y;e.SelfMulSub(r,m),i-=a*u,s.SelfMulAdd(o,m),n+=l*_}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=this.m_invMassA,l=this.m_invMassB,h=this.m_invIA,c=this.m_invIB,m=ec.MulRV(r,this.m_lalcA,this.m_rA),u=ec.MulRV(o,this.m_lalcB,this.m_rB),_=Yh.SubVV(Yh.AddVV(s,u,Yh.s_t0),Yh.AddVV(e,m,Yh.s_t1),c_.SolvePositionConstraints_s_d),d=ec.MulRV(r,this.m_localXAxisA,this.m_axis),p=Yh.CrossVV(Yh.AddVV(_,m,Yh.s_t0),d),f=Yh.CrossVV(u,d),y=ec.MulRV(r,this.m_localYAxisA,this.m_perp),g=Yh.CrossVV(Yh.AddVV(_,m,Yh.s_t0),y),x=Yh.CrossVV(u,y);let v=c_.SolvePositionConstraints_s_impulse;const S=Yh.DotVV(y,_),w=n-i-this.m_referenceAngle;let b=Nh(S);const C=Nh(w);let A=!1,B=0;if(this.m_enableLimit){const t=Yh.DotVV(d,_);Nh(this.m_upperTranslation-this.m_lowerTranslation)<.01?(B=t,b=Wh(b,Nh(t)),A=!0):t<=this.m_lowerTranslation?(B=Uh(t-this.m_lowerTranslation,0),b=Wh(b,this.m_lowerTranslation-t),A=!0):t>=this.m_upperTranslation&&(B=Wh(t-this.m_upperTranslation,0),b=Wh(b,t-this.m_upperTranslation),A=!0)}if(A){const t=a+l+h*g*g+c*x*x,e=h*g+c*x,i=h*g*p+c*x*f;let s=h+c;0===s&&(s=1);const n=h*p+c*f,r=a+l+h*p*p+c*f*f,o=this.m_K3;o.ex.SetXYZ(t,e,i),o.ey.SetXYZ(e,s,n),o.ez.SetXYZ(i,n,r),v=o.Solve33(-S,-w,-B,v)}else{const t=a+l+h*g*g+c*x*x,e=h*g+c*x;let i=h+c;0===i&&(i=1);const s=this.m_K2;s.ex.Set(t,e),s.ey.Set(e,i);const n=s.Solve(-S,-w,c_.SolvePositionConstraints_s_impulse1);v.x=n.x,v.y=n.y,v.z=0}const M=Yh.AddVV(Yh.MulSV(v.x,y,Yh.s_t0),Yh.MulSV(v.z,d,Yh.s_t1),c_.SolvePositionConstraints_s_P),V=v.x*g+v.y+v.z*p,T=v.x*x+v.y+v.z*f;return e.SelfMulSub(a,M),i-=h*V,s.SelfMulAdd(l,M),n+=c*T,t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,b<=Ph&&C<=Dh}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.x),e.y=t*(this.m_impulse.y*this.m_perp.y+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.y),e}GetReactionTorque(t){return t*this.m_impulse.y}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetReferenceAngle(){return this.m_referenceAngle}GetJointTranslation(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,c_.GetJointTranslation_s_pA),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,c_.GetJointTranslation_s_pB),i=Yh.SubVV(e,t,c_.GetJointTranslation_s_d),s=this.m_bodyA.GetWorldVector(this.m_localXAxisA,c_.GetJointTranslation_s_axis);return Yh.DotVV(i,s)}GetJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;Yh.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const i=ec.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const s=ec.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=Yh.AddVV(t.m_sweep.c,i,Yh.s_t0),r=Yh.AddVV(e.m_sweep.c,s,Yh.s_t1),o=Yh.SubVV(r,n,Yh.s_t2),a=t.GetWorldVector(this.m_localXAxisA,this.m_axis),l=t.m_linearVelocity,h=e.m_linearVelocity,c=t.m_angularVelocity,m=e.m_angularVelocity;return Yh.DotVV(o,Yh.CrossSV(c,a,Yh.s_t0))+Yh.DotVV(a,Yh.SubVV(Yh.AddVCrossSV(h,m,s,Yh.s_t0),Yh.AddVCrossSV(l,c,i,Yh.s_t1),Yh.s_t0))}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorForce(t){t!==this.m_maxMotorForce&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorForce=t)}GetMaxMotorForce(){return this.m_maxMotorForce}GetMotorForce(t){return t*this.m_motorImpulse}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerTranslation = %.15f;\n",this.m_lowerTranslation),t("  jd.upperTranslation = %.15f;\n",this.m_upperTranslation),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorForce = %.15f;\n",this.m_maxMotorForce),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ic.MulXV(e,this.m_localAnchorA,c_.Draw_s_pA),n=ic.MulXV(i,this.m_localAnchorB,c_.Draw_s_pB),r=ec.MulRV(e.q,this.m_localXAxisA,c_.Draw_s_axis),o=c_.Draw_s_c1,a=c_.Draw_s_c2,l=c_.Draw_s_c3,h=c_.Draw_s_c4,c=c_.Draw_s_c5;if(t.DrawSegment(s,n,c),this.m_enableLimit){const i=Yh.AddVMulSV(s,this.m_lowerTranslation,r,c_.Draw_s_lower),n=Yh.AddVMulSV(s,this.m_upperTranslation,r,c_.Draw_s_upper),h=ec.MulRV(e.q,this.m_localYAxisA,c_.Draw_s_perp);t.DrawSegment(i,n,o),t.DrawSegment(Yh.AddVMulSV(i,-.5,h,Yh.s_t0),Yh.AddVMulSV(i,.5,h,Yh.s_t1),a),t.DrawSegment(Yh.AddVMulSV(n,-.5,h,Yh.s_t0),Yh.AddVMulSV(n,.5,h,Yh.s_t1),l)}else t.DrawSegment(Yh.AddVMulSV(s,-1,r,Yh.s_t0),Yh.AddVMulSV(s,1,r,Yh.s_t1),o);t.DrawPoint(s,5,o),t.DrawPoint(n,5,h)}}c_.InitVelocityConstraints_s_d=new Yh,c_.InitVelocityConstraints_s_P=new Yh,c_.SolveVelocityConstraints_s_P=new Yh,c_.SolveVelocityConstraints_s_df=new Yh,c_.SolvePositionConstraints_s_d=new Yh,c_.SolvePositionConstraints_s_impulse=new Kh,c_.SolvePositionConstraints_s_impulse1=new Yh,c_.SolvePositionConstraints_s_P=new Yh,c_.GetJointTranslation_s_pA=new Yh,c_.GetJointTranslation_s_pB=new Yh,c_.GetJointTranslation_s_d=new Yh,c_.GetJointTranslation_s_axis=new Yh,c_.Draw_s_pA=new Yh,c_.Draw_s_pB=new Yh,c_.Draw_s_axis=new Yh,c_.Draw_s_c1=new wh(.7,.7,.7),c_.Draw_s_c2=new wh(.3,.9,.3),c_.Draw_s_c3=new wh(.9,.3,.3),c_.Draw_s_c4=new wh(.3,.3,.9),c_.Draw_s_c5=new wh(.4,.4,.4),c_.Draw_s_lower=new Yh,c_.Draw_s_upper=new Yh,c_.Draw_s_perp=new Yh;class m_ extends Cu{constructor(t){super(t),this.m_groundAnchorA=new Yh,this.m_groundAnchorB=new Yh,this.m_lengthA=0,this.m_lengthB=0,this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_uA=new Yh,this.m_uB=new Yh,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_groundAnchorA.Copy(Ah(t.groundAnchorA,new Yh(-1,1))),this.m_groundAnchorB.Copy(Ah(t.groundAnchorB,new Yh(1,0))),this.m_localAnchorA.Copy(Ah(t.localAnchorA,new Yh(-1,0))),this.m_localAnchorB.Copy(Ah(t.localAnchorB,new Yh(1,0))),this.m_lengthA=Ah(t.lengthA,0),this.m_lengthB=Ah(t.lengthB,0),this.m_ratio=Ah(t.ratio,1),this.m_constant=Ah(t.lengthA,0)+this.m_ratio*Ah(t.lengthB,0),this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),ec.MulRV(h,this.m_lalcA,this.m_rA),Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),ec.MulRV(c,this.m_lalcB,this.m_rB),this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA),this.m_uB.Copy(r).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);const m=this.m_uA.Length(),u=this.m_uB.Length();m>.05?this.m_uA.SelfMul(1/m):this.m_uA.SetZero(),u>.05?this.m_uB.SelfMul(1/u):this.m_uB.SetZero();const _=Yh.CrossVV(this.m_rA,this.m_uA),d=Yh.CrossVV(this.m_rB,this.m_uB),p=this.m_invMassA+this.m_invIA*_*_,f=this.m_invMassB+this.m_invIB*d*d;if(this.m_mass=p+this.m_ratio*this.m_ratio*f,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.step.warmStarting){this.m_impulse*=t.step.dtRatio;const e=Yh.MulSV(-this.m_impulse,this.m_uA,m_.InitVelocityConstraints_s_PA),i=Yh.MulSV(-this.m_ratio*this.m_impulse,this.m_uB,m_.InitVelocityConstraints_s_PB);s.SelfMulAdd(this.m_invMassA,e),n+=this.m_invIA*Yh.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,i),l+=this.m_invIB*Yh.CrossVV(this.m_rB,i)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=Yh.AddVCrossSV(e,i,this.m_rA,m_.SolveVelocityConstraints_s_vpA),o=Yh.AddVCrossSV(s,n,this.m_rB,m_.SolveVelocityConstraints_s_vpB),a=-Yh.DotVV(this.m_uA,r)-this.m_ratio*Yh.DotVV(this.m_uB,o),l=-this.m_mass*a;this.m_impulse+=l;const h=Yh.MulSV(-l,this.m_uA,m_.SolveVelocityConstraints_s_PA),c=Yh.MulSV(-this.m_ratio*l,this.m_uB,m_.SolveVelocityConstraints_s_PB);e.SelfMulAdd(this.m_invMassA,h),i+=this.m_invIA*Yh.CrossVV(this.m_rA,h),s.SelfMulAdd(this.m_invMassB,c),n+=this.m_invIB*Yh.CrossVV(this.m_rB,c),t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=ec.MulRV(r,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=ec.MulRV(o,this.m_lalcB,this.m_rB),h=this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),c=this.m_uB.Copy(s).SelfAdd(l).SelfSub(this.m_groundAnchorB),m=h.Length(),u=c.Length();m>.05?h.SelfMul(1/m):h.SetZero(),u>.05?c.SelfMul(1/u):c.SetZero();const _=Yh.CrossVV(a,h),d=Yh.CrossVV(l,c),p=this.m_invMassA+this.m_invIA*_*_,f=this.m_invMassB+this.m_invIB*d*d;let y=p+this.m_ratio*this.m_ratio*f;y>0&&(y=1/y);const g=this.m_constant-m-this.m_ratio*u,x=Nh(g),v=-y*g,S=Yh.MulSV(-v,h,m_.SolvePositionConstraints_s_PA),w=Yh.MulSV(-this.m_ratio*v,c,m_.SolvePositionConstraints_s_PB);return e.SelfMulAdd(this.m_invMassA,S),i+=this.m_invIA*Yh.CrossVV(a,S),s.SelfMulAdd(this.m_invMassB,w),n+=this.m_invIB*Yh.CrossVV(l,w),t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,x<Ph}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse*this.m_uB.x,e.y=t*this.m_impulse*this.m_uB.y,e}GetReactionTorque(t){return 0}GetGroundAnchorA(){return this.m_groundAnchorA}GetGroundAnchorB(){return this.m_groundAnchorB}GetLengthA(){return this.m_lengthA}GetLengthB(){return this.m_lengthB}GetRatio(){return this.m_ratio}GetCurrentLengthA(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,m_.GetCurrentLengthA_s_p),e=this.m_groundAnchorA;return Yh.DistanceVV(t,e)}GetCurrentLengthB(){const t=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,m_.GetCurrentLengthB_s_p),e=this.m_groundAnchorB;return Yh.DistanceVV(t,e)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.groundAnchorA.Set(%.15f, %.15f);\n",this.m_groundAnchorA.x,this.m_groundAnchorA.y),t("  jd.groundAnchorB.Set(%.15f, %.15f);\n",this.m_groundAnchorB.x,this.m_groundAnchorB.y),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.lengthA = %.15f;\n",this.m_lengthA),t("  jd.lengthB = %.15f;\n",this.m_lengthB),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}ShiftOrigin(t){this.m_groundAnchorA.SelfSub(t),this.m_groundAnchorB.SelfSub(t)}}m_.InitVelocityConstraints_s_PA=new Yh,m_.InitVelocityConstraints_s_PB=new Yh,m_.SolveVelocityConstraints_s_vpA=new Yh,m_.SolveVelocityConstraints_s_vpB=new Yh,m_.SolveVelocityConstraints_s_PA=new Yh,m_.SolveVelocityConstraints_s_PB=new Yh,m_.SolvePositionConstraints_s_PA=new Yh,m_.SolvePositionConstraints_s_PB=new Yh,m_.GetCurrentLengthA_s_p=new Yh,m_.GetCurrentLengthB_s_p=new Yh;class u_ extends Cu{constructor(t){super(t),this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_impulse=new Yh,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_enableMotor=!1,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_referenceAngle=0,this.m_lowerAngle=0,this.m_upperAngle=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_K=new $h,this.m_angle=0,this.m_axialMass=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_referenceAngle=Ah(t.referenceAngle,0),this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerAngle=Ah(t.lowerAngle,0),this.m_upperAngle=Ah(t.upperAngle,0),this.m_maxMotorTorque=Ah(t.maxMotorTorque,0),this.m_motorSpeed=Ah(t.motorSpeed,0),this.m_enableLimit=Ah(t.enableLimit,!1),this.m_enableMotor=Ah(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),ec.MulRV(a,this.m_lalcA,this.m_rA),Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),ec.MulRV(l,this.m_lalcB,this.m_rB);const h=this.m_invMassA,c=this.m_invMassB,m=this.m_invIA,u=this.m_invIB;let _;if(this.m_K.ex.x=h+c+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*u,this.m_K.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*u,this.m_K.ex.y=this.m_K.ey.x,this.m_K.ey.y=h+c+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*u,this.m_axialMass=m+u,this.m_axialMass>0?(this.m_axialMass=1/this.m_axialMass,_=!1):_=!0,this.m_angle=n-e-this.m_referenceAngle,(!1===this.m_enableLimit||_)&&(this.m_lowerImpulse=0,this.m_upperImpulse=0),(!1===this.m_enableMotor||_)&&(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,n=u_.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);i.SelfMulSub(h,n),s-=m*(Yh.CrossVV(this.m_rA,n)+e),r.SelfMulAdd(c,n),o+=u*(Yh.CrossVV(this.m_rB,n)+e)}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=a+l===0;if(this.m_enableMotor&&!h){const e=n-i-this.m_motorSpeed;let s=-this.m_axialMass*e;const r=this.m_motorImpulse,o=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=jh(this.m_motorImpulse+s,-o,o),s=this.m_motorImpulse-r,i-=a*s,n+=l*s}if(this.m_enableLimit&&!h){{const e=this.m_angle-this.m_lowerAngle,s=n-i;let r=-this.m_axialMass*(s+Wh(e,0)*t.step.inv_dt);const o=this.m_lowerImpulse;this.m_lowerImpulse=Wh(this.m_lowerImpulse+r,0),r=this.m_lowerImpulse-o,i-=a*r,n+=l*r}{const e=this.m_upperAngle-this.m_angle,s=i-n;let r=-this.m_axialMass*(s+Wh(e,0)*t.step.inv_dt);const o=this.m_upperImpulse;this.m_upperImpulse=Wh(this.m_upperImpulse+r,0),r=this.m_upperImpulse-o,i+=a*r,n-=l*r}}{const t=Yh.SubVV(Yh.AddVCrossSV(s,n,this.m_rB,Yh.s_t0),Yh.AddVCrossSV(e,i,this.m_rA,Yh.s_t1),u_.SolveVelocityConstraints_s_Cdot_v2),h=this.m_K.Solve(-t.x,-t.y,u_.SolveVelocityConstraints_s_impulse_v2);this.m_impulse.x+=h.x,this.m_impulse.y+=h.y,e.SelfMulSub(r,h),i-=a*Yh.CrossVV(this.m_rA,h),s.SelfMulAdd(o,h),n+=l*Yh.CrossVV(this.m_rB,h)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);let a=0,l=0;const h=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&!h){const t=n-i-this.m_referenceAngle;let e=0;Nh(this.m_upperAngle-this.m_lowerAngle)<2*Dh?e=jh(t-this.m_lowerAngle,-.13962634015955555,Eh):t<=this.m_lowerAngle?e=jh(t-this.m_lowerAngle+Dh,-.13962634015955555,0):t>=this.m_upperAngle&&(e=jh(t-this.m_upperAngle-Dh,0,Eh));const s=-this.m_axialMass*e;i-=this.m_invIA*s,n+=this.m_invIB*s,a=Nh(e)}{r.SetAngle(i),o.SetAngle(n),Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const t=ec.MulRV(r,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const a=ec.MulRV(o,this.m_lalcB,this.m_rB),h=Yh.SubVV(Yh.AddVV(s,a,Yh.s_t0),Yh.AddVV(e,t,Yh.s_t1),u_.SolvePositionConstraints_s_C_v2);l=h.Length();const c=this.m_invMassA,m=this.m_invMassB,u=this.m_invIA,_=this.m_invIB,d=this.m_K;d.ex.x=c+m+u*t.y*t.y+_*a.y*a.y,d.ex.y=-u*t.x*t.y-_*a.x*a.y,d.ey.x=d.ex.y,d.ey.y=c+m+u*t.x*t.x+_*a.x*a.x;const p=d.Solve(h.x,h.y,u_.SolvePositionConstraints_s_impulse).SelfNeg();e.SelfMulSub(c,p),i-=u*Yh.CrossVV(t,p),s.SelfMulAdd(m,p),n+=_*Yh.CrossVV(a,p)}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,l<=Ph&&a<=Dh}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*(this.m_lowerImpulse-this.m_upperImpulse)}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}GetMotorTorque(t){return t*this.m_motorImpulse}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMaxMotorTorque(){return this.m_maxMotorTorque}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerAngle}GetUpperLimit(){return this.m_upperAngle}SetLimits(t,e){t===this.m_lowerAngle&&e===this.m_upperAngle||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerAngle=t,this.m_upperAngle=e)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerAngle = %.15f;\n",this.m_lowerAngle),t("  jd.upperAngle = %.15f;\n",this.m_upperAngle),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ic.MulXV(e,this.m_localAnchorA,u_.Draw_s_pA),n=ic.MulXV(i,this.m_localAnchorB,u_.Draw_s_pB),r=u_.Draw_s_c1,o=u_.Draw_s_c2,a=u_.Draw_s_c3,l=u_.Draw_s_c4,h=u_.Draw_s_c5;t.DrawPoint(s,5,l),t.DrawPoint(n,5,h);const c=this.m_bodyA.GetAngle(),m=this.m_bodyB.GetAngle()-c-this.m_referenceAngle,u=.5,_=u_.Draw_s_r.Set(u*Math.cos(m),u*Math.sin(m));if(t.DrawSegment(n,Yh.AddVV(n,_,Yh.s_t0),r),t.DrawCircle(n,u,r),this.m_enableLimit){const e=u_.Draw_s_rlo.Set(u*Math.cos(this.m_lowerAngle),u*Math.sin(this.m_lowerAngle)),i=u_.Draw_s_rhi.Set(u*Math.cos(this.m_upperAngle),u*Math.sin(this.m_upperAngle));t.DrawSegment(n,Yh.AddVV(n,e,Yh.s_t0),o),t.DrawSegment(n,Yh.AddVV(n,i,Yh.s_t0),a)}const d=u_.Draw_s_color_;t.DrawSegment(e.p,s,d),t.DrawSegment(s,n,d),t.DrawSegment(i.p,n,d)}}u_.InitVelocityConstraints_s_P=new Yh,u_.SolveVelocityConstraints_s_Cdot_v2=new Yh,u_.SolveVelocityConstraints_s_impulse_v2=new Yh,u_.SolvePositionConstraints_s_C_v2=new Yh,u_.SolvePositionConstraints_s_impulse=new Yh,u_.Draw_s_pA=new Yh,u_.Draw_s_pB=new Yh,u_.Draw_s_c1=new wh(.7,.7,.7),u_.Draw_s_c2=new wh(.3,.9,.3),u_.Draw_s_c3=new wh(.9,.3,.3),u_.Draw_s_c4=new wh(.3,.3,.9),u_.Draw_s_c5=new wh(.4,.4,.4),u_.Draw_s_color_=new wh(.5,.8,.8),u_.Draw_s_r=new Yh,u_.Draw_s_rlo=new Yh,u_.Draw_s_rhi=new Yh;class __ extends Cu{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_referenceAngle=0,this.m_gamma=0,this.m_impulse=new Kh(0,0,0),this.m_indexA=0,this.m_indexB=0,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=new tc,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_K=new tc,this.m_stiffness=Ah(t.stiffness,0),this.m_damping=Ah(t.damping,0),this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_referenceAngle=Ah(t.referenceAngle,0),this.m_impulse.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),ec.MulRV(a,this.m_lalcA,this.m_rA),Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),ec.MulRV(l,this.m_lalcB,this.m_rB);const h=this.m_invMassA,c=this.m_invMassB,m=this.m_invIA,u=this.m_invIB,_=this.m_K;if(_.ex.x=h+c+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*u,_.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*u,_.ez.x=-this.m_rA.y*m-this.m_rB.y*u,_.ex.y=_.ey.x,_.ey.y=h+c+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*u,_.ez.y=this.m_rA.x*m+this.m_rB.x*u,_.ex.z=_.ez.x,_.ey.z=_.ez.y,_.ez.z=m+u,this.m_stiffness>0){_.GetInverse22(this.m_mass);let i=m+u;const s=n-e-this.m_referenceAngle,r=this.m_damping,o=this.m_stiffness,a=t.step.dt;this.m_gamma=a*(r+a*o),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=s*a*o*this.m_gamma,i+=this.m_gamma,this.m_mass.ez.z=0!==i?1/i:0}else _.GetSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0;if(t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio);const e=__.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);i.SelfMulSub(h,e),s-=m*(Yh.CrossVV(this.m_rA,e)+this.m_impulse.z),r.SelfMulAdd(c,e),o+=u*(Yh.CrossVV(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.SetZero();t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB;if(this.m_stiffness>0){const t=n-i,h=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=h,i-=a*h,n+=l*h;const c=Yh.SubVV(Yh.AddVCrossSV(s,n,this.m_rB,Yh.s_t0),Yh.AddVCrossSV(e,i,this.m_rA,Yh.s_t1),__.SolveVelocityConstraints_s_Cdot1),m=tc.MulM33XY(this.m_mass,c.x,c.y,__.SolveVelocityConstraints_s_impulse1).SelfNeg();this.m_impulse.x+=m.x,this.m_impulse.y+=m.y;const u=m;e.SelfMulSub(r,u),i-=a*Yh.CrossVV(this.m_rA,u),s.SelfMulAdd(o,u),n+=l*Yh.CrossVV(this.m_rB,u)}else{const t=Yh.SubVV(Yh.AddVCrossSV(s,n,this.m_rB,Yh.s_t0),Yh.AddVCrossSV(e,i,this.m_rA,Yh.s_t1),__.SolveVelocityConstraints_s_Cdot1),h=n-i,c=tc.MulM33XYZ(this.m_mass,t.x,t.y,h,__.SolveVelocityConstraints_s_impulse).SelfNeg();this.m_impulse.SelfAdd(c);const m=__.SolveVelocityConstraints_s_P.Set(c.x,c.y);e.SelfMulSub(r,m),i-=a*(Yh.CrossVV(this.m_rA,m)+c.z),s.SelfMulAdd(o,m),n+=l*(Yh.CrossVV(this.m_rB,m)+c.z)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=this.m_invMassA,l=this.m_invMassB,h=this.m_invIA,c=this.m_invIB;Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=ec.MulRV(r,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const u=ec.MulRV(o,this.m_lalcB,this.m_rB);let _,d;const p=this.m_K;if(p.ex.x=a+l+m.y*m.y*h+u.y*u.y*c,p.ey.x=-m.y*m.x*h-u.y*u.x*c,p.ez.x=-m.y*h-u.y*c,p.ex.y=p.ey.x,p.ey.y=a+l+m.x*m.x*h+u.x*u.x*c,p.ez.y=m.x*h+u.x*c,p.ex.z=p.ez.x,p.ey.z=p.ez.y,p.ez.z=h+c,this.m_stiffness>0){const t=Yh.SubVV(Yh.AddVV(s,u,Yh.s_t0),Yh.AddVV(e,m,Yh.s_t1),__.SolvePositionConstraints_s_C1);_=t.Length(),d=0;const r=p.Solve22(t.x,t.y,__.SolvePositionConstraints_s_P).SelfNeg();e.SelfMulSub(a,r),i-=h*Yh.CrossVV(m,r),s.SelfMulAdd(l,r),n+=c*Yh.CrossVV(u,r)}else{const t=Yh.SubVV(Yh.AddVV(s,u,Yh.s_t0),Yh.AddVV(e,m,Yh.s_t1),__.SolvePositionConstraints_s_C1),r=n-i-this.m_referenceAngle;_=t.Length(),d=Nh(r);const o=p.Solve33(t.x,t.y,r,__.SolvePositionConstraints_s_impulse).SelfNeg(),f=__.SolvePositionConstraints_s_P.Set(o.x,o.y);e.SelfMulSub(a,f),i-=h*(Yh.CrossVV(this.m_rA,f)+o.z),s.SelfMulAdd(l,f),n+=c*(Yh.CrossVV(this.m_rB,f)+o.z)}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,_<=Ph&&d<=Dh}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*this.m_impulse.z}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2WeldJointDef = new b2WeldJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}__.InitVelocityConstraints_s_P=new Yh,__.SolveVelocityConstraints_s_Cdot1=new Yh,__.SolveVelocityConstraints_s_impulse1=new Yh,__.SolveVelocityConstraints_s_impulse=new Kh,__.SolveVelocityConstraints_s_P=new Yh,__.SolvePositionConstraints_s_C1=new Yh,__.SolvePositionConstraints_s_P=new Yh,__.SolvePositionConstraints_s_impulse=new Kh;class d_ extends Cu{constructor(t){super(t),this.m_localAnchorA=new Yh,this.m_localAnchorB=new Yh,this.m_localXAxisA=new Yh,this.m_localYAxisA=new Yh,this.m_impulse=0,this.m_motorImpulse=0,this.m_springImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_translation=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_stiffness=0,this.m_damping=0,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new Yh,this.m_localCenterB=new Yh,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_ax=new Yh,this.m_ay=new Yh,this.m_sAx=0,this.m_sBx=0,this.m_sAy=0,this.m_sBy=0,this.m_mass=0,this.m_motorMass=0,this.m_axialMass=0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_qA=new ec,this.m_qB=new ec,this.m_lalcA=new Yh,this.m_lalcB=new Yh,this.m_rA=new Yh,this.m_rB=new Yh,this.m_localAnchorA.Copy(Ah(t.localAnchorA,Yh.ZERO)),this.m_localAnchorB.Copy(Ah(t.localAnchorB,Yh.ZERO)),this.m_localXAxisA.Copy(Ah(t.localAxisA,Yh.UNITX)),Yh.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_lowerTranslation=Ah(t.lowerTranslation,0),this.m_upperTranslation=Ah(t.upperTranslation,0),this.m_enableLimit=Ah(t.enableLimit,!1),this.m_maxMotorTorque=Ah(t.maxMotorTorque,0),this.m_motorSpeed=Ah(t.motorSpeed,0),this.m_enableMotor=Ah(t.enableMotor,!1),this.m_ax.SetZero(),this.m_ay.SetZero(),this.m_stiffness=Ah(t.stiffness,0),this.m_damping=Ah(t.damping,0)}GetMotorSpeed(){return this.m_motorSpeed}GetMaxMotorTorque(){return this.m_maxMotorTorque}SetSpringFrequencyHz(t){this.m_stiffness=t}GetSpringFrequencyHz(){return this.m_stiffness}SetSpringDampingRatio(t){this.m_damping=t}GetSpringDampingRatio(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,i=this.m_invMassB,s=this.m_invIA,n=this.m_invIB,r=t.positions[this.m_indexA].c,o=t.positions[this.m_indexA].a,a=t.velocities[this.m_indexA].v;let l=t.velocities[this.m_indexA].w;const h=t.positions[this.m_indexB].c,c=t.positions[this.m_indexB].a,m=t.velocities[this.m_indexB].v;let u=t.velocities[this.m_indexB].w;const _=this.m_qA.SetAngle(o),d=this.m_qB.SetAngle(c);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const p=ec.MulRV(_,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const f=ec.MulRV(d,this.m_lalcB,this.m_rB),y=Yh.SubVV(Yh.AddVV(h,f,Yh.s_t0),Yh.AddVV(r,p,Yh.s_t1),d_.InitVelocityConstraints_s_d);ec.MulRV(_,this.m_localYAxisA,this.m_ay),this.m_sAy=Yh.CrossVV(Yh.AddVV(y,p,Yh.s_t0),this.m_ay),this.m_sBy=Yh.CrossVV(f,this.m_ay),this.m_mass=e+i+s*this.m_sAy*this.m_sAy+n*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),ec.MulRV(_,this.m_localXAxisA,this.m_ax),this.m_sAx=Yh.CrossVV(Yh.AddVV(y,p,Yh.s_t0),this.m_ax),this.m_sBx=Yh.CrossVV(f,this.m_ax);const g=e+i+s*this.m_sAx*this.m_sAx+n*this.m_sBx*this.m_sBx;if(this.m_axialMass=g>0?1/g:0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_stiffness>0&&g>0){this.m_springMass=1/g;const e=Yh.DotVV(y,this.m_ax),i=t.step.dt;this.m_gamma=i*(this.m_damping+i*this.m_stiffness),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*i*this.m_stiffness*this.m_gamma,this.m_springMass=g+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}else this.m_springImpulse=0;if(this.m_enableLimit?this.m_translation=Yh.DotVV(this.m_ax,y):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor?(this.m_motorMass=s+n,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_springImpulse*=t.step.dtRatio,this.m_motorImpulse*=t.step.dtRatio;const e=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse,i=Yh.AddVV(Yh.MulSV(this.m_impulse,this.m_ay,Yh.s_t0),Yh.MulSV(e,this.m_ax,Yh.s_t1),d_.InitVelocityConstraints_s_P),s=this.m_impulse*this.m_sAy+e*this.m_sAx+this.m_motorImpulse,n=this.m_impulse*this.m_sBy+e*this.m_sBx+this.m_motorImpulse;a.SelfMulSub(this.m_invMassA,i),l-=this.m_invIA*s,m.SelfMulAdd(this.m_invMassB,i),u+=this.m_invIB*n}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=l,t.velocities[this.m_indexB].w=u}SolveVelocityConstraints(t){const e=this.m_invMassA,i=this.m_invMassB,s=this.m_invIA,n=this.m_invIB,r=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;{const t=Yh.DotVV(this.m_ax,Yh.SubVV(a,r,Yh.s_t0))+this.m_sBx*l-this.m_sAx*o,h=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=h;const c=Yh.MulSV(h,this.m_ax,d_.SolveVelocityConstraints_s_P),m=h*this.m_sAx,u=h*this.m_sBx;r.SelfMulSub(e,c),o-=s*m,a.SelfMulAdd(i,c),l+=n*u}{const e=l-o-this.m_motorSpeed;let i=-this.m_motorMass*e;const r=this.m_motorImpulse,a=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=jh(this.m_motorImpulse+i,-a,a),i=this.m_motorImpulse-r,o-=s*i,l+=n*i}if(this.m_enableLimit){{const h=this.m_translation-this.m_lowerTranslation,c=Yh.DotVV(this.m_ax,Yh.SubVV(a,r,Yh.s_t0))+this.m_sBx*l-this.m_sAx*o;let m=-this.m_axialMass*(c+Wh(h,0)*t.step.inv_dt);const u=this.m_lowerImpulse;this.m_lowerImpulse=Wh(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-u;const _=Yh.MulSV(m,this.m_ax,d_.SolveVelocityConstraints_s_P),d=m*this.m_sAx,p=m*this.m_sBx;r.SelfMulSub(e,_),o-=s*d,a.SelfMulAdd(i,_),l+=n*p}{const h=this.m_upperTranslation-this.m_translation,c=Yh.DotVV(this.m_ax,Yh.SubVV(r,a,Yh.s_t0))+this.m_sAx*o-this.m_sBx*l;let m=-this.m_axialMass*(c+Wh(h,0)*t.step.inv_dt);const u=this.m_upperImpulse;this.m_upperImpulse=Wh(this.m_upperImpulse+m,0),m=this.m_upperImpulse-u;const _=Yh.MulSV(m,this.m_ax,d_.SolveVelocityConstraints_s_P),d=m*this.m_sAx,p=m*this.m_sBx;r.SelfMulAdd(e,_),o+=s*d,a.SelfMulSub(i,_),l-=n*p}}{const t=Yh.DotVV(this.m_ay,Yh.SubVV(a,r,Yh.s_t0))+this.m_sBy*l-this.m_sAy*o,h=-this.m_mass*t;this.m_impulse+=h;const c=Yh.MulSV(h,this.m_ay,d_.SolveVelocityConstraints_s_P),m=h*this.m_sAy,u=h*this.m_sBy;r.SelfMulSub(e,c),o-=s*m,a.SelfMulAdd(i,c),l+=n*u}t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=l}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a,r=0;if(this.m_enableLimit){const t=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=ec.MulRV(t,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=ec.MulRV(o,this.m_lalcB,this.m_rB),h=Yh.AddVV(Yh.SubVV(s,e,Yh.s_t0),Yh.SubVV(l,a,Yh.s_t1),d_.SolvePositionConstraints_s_d),c=ec.MulRV(t,this.m_localXAxisA,this.m_ax),m=Yh.CrossVV(Yh.AddVV(h,a,Yh.s_t0),this.m_ax),u=Yh.CrossVV(l,this.m_ax);let _=0;const d=Yh.DotVV(c,h);if(Nh(this.m_upperTranslation-this.m_lowerTranslation)<.01?_=d:d<=this.m_lowerTranslation?_=Uh(d-this.m_lowerTranslation,0):d>=this.m_upperTranslation&&(_=Wh(d-this.m_upperTranslation,0)),0!==_){const t=this.m_invMassA+this.m_invMassB+this.m_invIA*m*m+this.m_invIB*u*u;let o=0;0!==t&&(o=-_/t);const a=Yh.MulSV(o,c,d_.SolvePositionConstraints_s_P),l=o*m,h=o*u;e.SelfMulSub(this.m_invMassA,a),i-=this.m_invIA*l,s.SelfMulAdd(this.m_invMassB,a),n+=this.m_invIB*h,r=Nh(_)}}{const t=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);Yh.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=ec.MulRV(t,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=ec.MulRV(o,this.m_lalcB,this.m_rB),h=Yh.AddVV(Yh.SubVV(s,e,Yh.s_t0),Yh.SubVV(l,a,Yh.s_t1),d_.SolvePositionConstraints_s_d),c=ec.MulRV(t,this.m_localYAxisA,this.m_ay),m=Yh.CrossVV(Yh.AddVV(h,a,Yh.s_t0),c),u=Yh.CrossVV(l,c),_=Yh.DotVV(h,c),d=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let p=0;0!==d&&(p=-_/d);const f=Yh.MulSV(p,c,d_.SolvePositionConstraints_s_P),y=p*m,g=p*u;e.SelfMulSub(this.m_invMassA,f),i-=this.m_invIA*y,s.SelfMulAdd(this.m_invMassB,f),n+=this.m_invIB*g,r=Wh(r,Nh(_))}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,r<=Ph}GetDefinition(t){return t}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse*this.m_ay.x+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.x),e.y=t*(this.m_impulse*this.m_ay.y+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.y),e}GetReactionTorque(t){return t*this.m_motorImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetJointTranslation(){return this.GetPrismaticJointTranslation()}GetJointLinearSpeed(){return this.GetPrismaticJointSpeed()}GetJointAngle(){return this.GetRevoluteJointAngle()}GetJointAngularSpeed(){return this.GetRevoluteJointSpeed()}GetPrismaticJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,i=t.GetWorldPoint(this.m_localAnchorA,new Yh),s=e.GetWorldPoint(this.m_localAnchorB,new Yh),n=Yh.SubVV(s,i,new Yh),r=t.GetWorldVector(this.m_localXAxisA,new Yh);return Yh.DotVV(n,r)}GetPrismaticJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;Yh.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const i=ec.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);Yh.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const s=ec.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=Yh.AddVV(t.m_sweep.c,i,Yh.s_t0),r=Yh.AddVV(e.m_sweep.c,s,Yh.s_t1),o=Yh.SubVV(r,n,Yh.s_t2),a=t.GetWorldVector(this.m_localXAxisA,new Yh),l=t.m_linearVelocity,h=e.m_linearVelocity,c=t.m_angularVelocity,m=e.m_angularVelocity;return Yh.DotVV(o,Yh.CrossSV(c,a,Yh.s_t0))+Yh.DotVV(a,Yh.SubVV(Yh.AddVCrossSV(h,m,s,Yh.s_t0),Yh.AddVCrossSV(l,c,i,Yh.s_t1),Yh.s_t0))}GetRevoluteJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a}GetRevoluteJointSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMotorTorque(t){return t*this.m_motorImpulse}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2WheelJointDef = new b2WheelJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ic.MulXV(e,this.m_localAnchorA,d_.Draw_s_pA),n=ic.MulXV(i,this.m_localAnchorB,d_.Draw_s_pB),r=ec.MulRV(e.q,this.m_localXAxisA,d_.Draw_s_axis),o=d_.Draw_s_c1,a=d_.Draw_s_c2,l=d_.Draw_s_c3,h=d_.Draw_s_c4,c=d_.Draw_s_c5;if(t.DrawSegment(s,n,c),this.m_enableLimit){const i=Yh.AddVMulSV(s,this.m_lowerTranslation,r,d_.Draw_s_lower),n=Yh.AddVMulSV(s,this.m_upperTranslation,r,d_.Draw_s_upper),h=ec.MulRV(e.q,this.m_localYAxisA,d_.Draw_s_perp);t.DrawSegment(i,n,o),t.DrawSegment(Yh.AddVMulSV(i,-.5,h,Yh.s_t0),Yh.AddVMulSV(i,.5,h,Yh.s_t1),a),t.DrawSegment(Yh.AddVMulSV(n,-.5,h,Yh.s_t0),Yh.AddVMulSV(n,.5,h,Yh.s_t1),l)}else t.DrawSegment(Yh.AddVMulSV(s,-1,r,Yh.s_t0),Yh.AddVMulSV(s,1,r,Yh.s_t1),o);t.DrawPoint(s,5,o),t.DrawPoint(n,5,h)}}var p_,f_,y_,g_;d_.InitVelocityConstraints_s_d=new Yh,d_.InitVelocityConstraints_s_P=new Yh,d_.SolveVelocityConstraints_s_P=new Yh,d_.SolvePositionConstraints_s_d=new Yh,d_.SolvePositionConstraints_s_P=new Yh,d_.Draw_s_pA=new Yh,d_.Draw_s_pB=new Yh,d_.Draw_s_axis=new Yh,d_.Draw_s_c1=new wh(.7,.7,.7),d_.Draw_s_c2=new wh(.3,.9,.3),d_.Draw_s_c3=new wh(.9,.3,.3),d_.Draw_s_c4=new wh(.3,.3,.9),d_.Draw_s_c5=new wh(.4,.4,.4),d_.Draw_s_lower=new Yh,d_.Draw_s_upper=new Yh,d_.Draw_s_perp=new Yh,function(t){t[t.b2_waterParticle=0]="b2_waterParticle",t[t.b2_zombieParticle=2]="b2_zombieParticle",t[t.b2_wallParticle=4]="b2_wallParticle",t[t.b2_springParticle=8]="b2_springParticle",t[t.b2_elasticParticle=16]="b2_elasticParticle",t[t.b2_viscousParticle=32]="b2_viscousParticle",t[t.b2_powderParticle=64]="b2_powderParticle",t[t.b2_tensileParticle=128]="b2_tensileParticle",t[t.b2_colorMixingParticle=256]="b2_colorMixingParticle",t[t.b2_destructionListenerParticle=512]="b2_destructionListenerParticle",t[t.b2_barrierParticle=1024]="b2_barrierParticle",t[t.b2_staticPressureParticle=2048]="b2_staticPressureParticle",t[t.b2_reactiveParticle=4096]="b2_reactiveParticle",t[t.b2_repulsiveParticle=8192]="b2_repulsiveParticle",t[t.b2_fixtureContactListenerParticle=16384]="b2_fixtureContactListenerParticle",t[t.b2_particleContactListenerParticle=32768]="b2_particleContactListenerParticle",t[t.b2_fixtureContactFilterParticle=65536]="b2_fixtureContactFilterParticle",t[t.b2_particleContactFilterParticle=131072]="b2_particleContactFilterParticle"}(p_||(p_={}));class x_{constructor(){this.flags=0,this.position=new Yh,this.velocity=new Yh,this.color=new wh(0,0,0,0),this.lifetime=0,this.userData=null,this.group=null}}class v_{constructor(){this.m_index=Gh}GetIndex(){return this.m_index}SetIndex(t){this.m_index=t}}!function(t){t[t.b2_solidParticleGroup=1]="b2_solidParticleGroup",t[t.b2_rigidParticleGroup=2]="b2_rigidParticleGroup",t[t.b2_particleGroupCanBeEmpty=4]="b2_particleGroupCanBeEmpty",t[t.b2_particleGroupWillBeDestroyed=8]="b2_particleGroupWillBeDestroyed",t[t.b2_particleGroupNeedsUpdateDepth=16]="b2_particleGroupNeedsUpdateDepth",t[t.b2_particleGroupInternalMask=24]="b2_particleGroupInternalMask"}(f_||(f_={}));class S_{constructor(){this.flags=0,this.groupFlags=0,this.position=new Yh,this.angle=0,this.linearVelocity=new Yh,this.angularVelocity=0,this.color=new wh,this.strength=1,this.shapeCount=0,this.stride=0,this.particleCount=0,this.lifetime=0,this.userData=null,this.group=null}}class w_{constructor(t){this.m_firstIndex=0,this.m_lastIndex=0,this.m_groupFlags=0,this.m_strength=1,this.m_prev=null,this.m_next=null,this.m_timestamp=-1,this.m_mass=0,this.m_inertia=0,this.m_center=new Yh,this.m_linearVelocity=new Yh,this.m_angularVelocity=0,this.m_transform=new ic,this.m_userData=null,this.m_system=t}GetNext(){return this.m_next}GetParticleSystem(){return this.m_system}GetParticleCount(){return this.m_lastIndex-this.m_firstIndex}GetBufferIndex(){return this.m_firstIndex}ContainsParticle(t){return this.m_firstIndex<=t&&t<this.m_lastIndex}GetAllParticleFlags(){if(!this.m_system.m_flagsBuffer.data)throw new Error;let t=0;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)t|=this.m_system.m_flagsBuffer.data[e];return t}GetGroupFlags(){return this.m_groupFlags}SetGroupFlags(t){t|=this.m_groupFlags&f_.b2_particleGroupInternalMask,this.m_system.SetGroupFlags(this,t)}GetMass(){return this.UpdateStatistics(),this.m_mass}GetInertia(){return this.UpdateStatistics(),this.m_inertia}GetCenter(){return this.UpdateStatistics(),this.m_center}GetLinearVelocity(){return this.UpdateStatistics(),this.m_linearVelocity}GetAngularVelocity(){return this.UpdateStatistics(),this.m_angularVelocity}GetTransform(){return this.m_transform}GetPosition(){return this.m_transform.p}GetAngle(){return this.m_transform.q.GetAngle()}GetLinearVelocityFromWorldPoint(t,e){const i=w_.GetLinearVelocityFromWorldPoint_s_t0;return this.UpdateStatistics(),Yh.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Yh.SubVV(t,this.m_center,i),e)}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}ApplyForce(t){this.m_system.ApplyForce(this.m_firstIndex,this.m_lastIndex,t)}ApplyLinearImpulse(t){this.m_system.ApplyLinearImpulse(this.m_firstIndex,this.m_lastIndex,t)}DestroyParticles(t){if(this.m_system.m_world.IsLocked())throw new Error;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)this.m_system.DestroyParticle(e,t)}UpdateStatistics(){if(!this.m_system.m_positionBuffer.data)throw new Error;if(!this.m_system.m_velocityBuffer.data)throw new Error;const t=new Yh,e=new Yh;if(this.m_timestamp!==this.m_system.m_timestamp){const i=this.m_system.GetParticleMass();this.m_mass=i*(this.m_lastIndex-this.m_firstIndex),this.m_center.SetZero(),this.m_linearVelocity.SetZero();for(let t=this.m_firstIndex;t<this.m_lastIndex;t++)this.m_center.SelfMulAdd(i,this.m_system.m_positionBuffer.data[t]),this.m_linearVelocity.SelfMulAdd(i,this.m_system.m_velocityBuffer.data[t]);if(this.m_mass>0){const t=1/this.m_mass;this.m_center.SelfMul(t),this.m_linearVelocity.SelfMul(t)}this.m_inertia=0,this.m_angularVelocity=0;for(let s=this.m_firstIndex;s<this.m_lastIndex;s++)Yh.SubVV(this.m_system.m_positionBuffer.data[s],this.m_center,t),Yh.SubVV(this.m_system.m_velocityBuffer.data[s],this.m_linearVelocity,e),this.m_inertia+=i*Yh.DotVV(t,t),this.m_angularVelocity+=i*Yh.CrossVV(t,e);this.m_inertia>0&&(this.m_angularVelocity*=1/this.m_inertia),this.m_timestamp=this.m_system.m_timestamp}}}w_.GetLinearVelocityFromWorldPoint_s_t0=new Yh;class b_{constructor(t){this.m_buffer=[],this.m_front=0,this.m_back=0,this.m_buffer.fill(null,0,t)}get m_capacity(){return this.m_buffer.length}Push(t){if(this.m_back>=this.m_capacity){for(let t=this.m_front;t<this.m_back;t++)this.m_buffer[t-this.m_front]=this.m_buffer[t];this.m_back-=this.m_front,this.m_front=0}this.m_buffer[this.m_back]=t,this.m_back++}Pop(){this.m_buffer[this.m_front]=null,this.m_front++}Empty(){return this.m_front===this.m_back}Front(){const t=this.m_buffer[this.m_front];if(!t)throw new Error;return t}}class C_{constructor(t){this.m_generatorCapacity=0,this.m_generatorCount=0,this.m_countX=0,this.m_countY=0,this.m_diagram=[],this.m_generatorBuffer=Fh(t,(t=>new A_)),this.m_generatorCapacity=t}AddGenerator(t,e,i){const s=this.m_generatorBuffer[this.m_generatorCount++];s.center.Copy(t),s.tag=e,s.necessary=i}Generate(t,e){const i=1/t,s=new Yh(+Bh,+Bh),n=new Yh(-Bh,-Bh);let r=0;for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.necessary&&(Yh.MinV(s,e.center,s),Yh.MaxV(n,e.center,n),++r)}if(0===r)return this.m_countX=0,void(this.m_countY=0);s.x-=e,s.y-=e,n.x+=e,n.y+=e,this.m_countX=1+Math.floor(i*(n.x-s.x)),this.m_countY=1+Math.floor(i*(n.y-s.y)),this.m_diagram=[];const o=new b_(4*this.m_countX*this.m_countY);for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.center.SelfSub(s).SelfMul(i);const n=Math.floor(e.center.x),r=Math.floor(e.center.y);n>=0&&r>=0&&n<this.m_countX&&r<this.m_countY&&o.Push(new B_(n,r,n+r*this.m_countX,e))}for(;!o.Empty();){const t=o.Front(),e=t.m_x,i=t.m_y,s=t.m_i,n=t.m_generator;o.Pop(),this.m_diagram[s]||(this.m_diagram[s]=n,e>0&&o.Push(new B_(e-1,i,s-1,n)),i>0&&o.Push(new B_(e,i-1,s-this.m_countX,n)),e<this.m_countX-1&&o.Push(new B_(e+1,i,s+1,n)),i<this.m_countY-1&&o.Push(new B_(e,i+1,s+this.m_countX,n)))}for(let t=0;t<this.m_countY;t++)for(let e=0;e<this.m_countX-1;e++){const i=e+t*this.m_countX,s=this.m_diagram[i],n=this.m_diagram[i+1];s!==n&&(o.Push(new B_(e,t,i,n)),o.Push(new B_(e+1,t,i+1,s)))}for(let t=0;t<this.m_countY-1;t++)for(let e=0;e<this.m_countX;e++){const i=e+t*this.m_countX,s=this.m_diagram[i],n=this.m_diagram[i+this.m_countX];s!==n&&(o.Push(new B_(e,t,i,n)),o.Push(new B_(e,t+1,i+this.m_countX,s)))}for(;!o.Empty();){const t=o.Front(),e=t.m_x,i=t.m_y,s=t.m_i,n=t.m_generator;o.Pop();const r=this.m_diagram[s],a=n;if(r!==a){const t=r.center.x-e,n=r.center.y-i,l=a.center.x-e,h=a.center.y-i;t*t+n*n>l*l+h*h&&(this.m_diagram[s]=a,e>0&&o.Push(new B_(e-1,i,s-1,a)),i>0&&o.Push(new B_(e,i-1,s-this.m_countX,a)),e<this.m_countX-1&&o.Push(new B_(e+1,i,s+1,a)),i<this.m_countY-1&&o.Push(new B_(e,i+1,s+this.m_countX,a)))}}}GetNodes(t){for(let e=0;e<this.m_countY-1;e++)for(let i=0;i<this.m_countX-1;i++){const s=i+e*this.m_countX,n=this.m_diagram[s],r=this.m_diagram[s+1],o=this.m_diagram[s+this.m_countX],a=this.m_diagram[s+1+this.m_countX];r!==o&&(n!==r&&n!==o&&(n.necessary||r.necessary||o.necessary)&&t(n.tag,r.tag,o.tag),a!==r&&a!==o&&(n.necessary||r.necessary||o.necessary)&&t(r.tag,a.tag,o.tag))}}}class A_{constructor(){this.center=new Yh,this.tag=0,this.necessary=!1}}class B_{constructor(t,e,i,s){this.m_x=t,this.m_y=e,this.m_i=i,this.m_generator=s}}function M_(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}function V_(t,e){return t<e}function T_(t,e=0,i=t.length-e,s=V_){let n=e;const r=[];let o=0;for(;;){for(;n+1<i;i++){const e=t[n+Math.floor(Math.random()*(i-n))];r[o++]=i;for(let r=n-1;;){for(;s(t[++r],e););for(;s(e,t[--i]););if(r>=i)break;M_(t,r,i)}}if(0===o)break;n=i,i=r[--o]}return t}function P_(t,e=0,i=t.length-e,s=V_){return T_(t,e,i,s)}function D_(t,e,i=t.length){let s=0;for(let n=0;n<i;++n)e(t[n])||(n!==s?M_(t,s++,n):++s);return s}function I_(t,e,i,s,n){let r=i-e;for(;r>0;){const i=Math.floor(r/2);let o=e+i;n(t[o],s)?(e=++o,r-=i+1):r=i}return e}function E_(t,e,i,s,n){let r=i-e;for(;r>0;){const i=Math.floor(r/2);let o=e+i;n(s,t[o])?r=i:(e=++o,r-=i+1)}return e}function R_(t,e,i,s){let n=i;for(;e!==n;)M_(t,e++,n++),n===s?n=i:e===i&&(i=n)}class L_{constructor(t){this.data=[],this.count=0,this.capacity=0,this.allocator=t}Append(){return this.count>=this.capacity&&this.Grow(),this.count++}Reserve(t){if(!(this.capacity>=t)){for(let e=this.capacity;e<t;++e)this.data[e]=this.allocator();this.capacity=t}}Grow(){const t=this.capacity?2*this.capacity:256;this.Reserve(t)}Free(){0!==this.data.length&&(this.data=[],this.capacity=0,this.count=0)}Shorten(t){}Data(){return this.data}GetCount(){return this.count}SetCount(t){this.count=t}GetCapacity(){return this.capacity}RemoveIf(t){this.count=D_(this.data,t,this.count)}Unique(t){this.count=function(t,e,i,s){if(e===i)return i;let n=e;for(;++e!==i;)s(t[n],t[e])||M_(t,++n,e);return++n}(this.data,0,this.count,t)}}class G_ extends Ju{constructor(t){super(),this.m_system=t}ShouldQueryParticleSystem(t){return!1}ReportFixture(t){if(t.IsSensor())return!0;const e=t.GetShape().GetChildCount();for(let i=0;i<e;i++){const e=t.GetAABB(i),s=this.m_system.GetInsideBoundsEnumerator(e);let n;for(;(n=s.GetNext())>=0;)this.ReportFixtureAndParticle(t,i,n)}return!0}ReportParticle(t,e){return!1}ReportFixtureAndParticle(t,e,i){}}class F_{constructor(){this.indexA=0,this.indexB=0,this.weight=0,this.normal=new Yh,this.flags=0}SetIndices(t,e){this.indexA=t,this.indexB=e}SetWeight(t){this.weight=t}SetNormal(t){this.normal.Copy(t)}SetFlags(t){this.flags=t}GetIndexA(){return this.indexA}GetIndexB(){return this.indexB}GetWeight(){return this.weight}GetNormal(){return this.normal}GetFlags(){return this.flags}IsEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&this.weight===t.weight&&this.normal.x===t.normal.x&&this.normal.y===t.normal.y}IsNotEqual(t){return!this.IsEqual(t)}ApproximatelyEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&Nh(this.weight-t.weight)<.01&&Yh.DistanceSquaredVV(this.normal,t.normal)<1e-4}}class k_{constructor(){this.index=0,this.weight=0,this.normal=new Yh,this.mass=0}}class z_{constructor(){this.indexA=0,this.indexB=0,this.flags=0,this.strength=0,this.distance=0}}class O_{constructor(){this.indexA=0,this.indexB=0,this.indexC=0,this.flags=0,this.strength=0,this.pa=new Yh(0,0),this.pb=new Yh(0,0),this.pc=new Yh(0,0),this.ka=0,this.kb=0,this.kc=0,this.s=0}}class N_{constructor(){this.strictContactCheck=!1,this.density=1,this.gravityScale=1,this.radius=1,this.maxCount=0,this.pressureStrength=.005,this.dampingStrength=1,this.elasticStrength=.25,this.springStrength=.25,this.viscousStrength=.25,this.surfaceTensionPressureStrength=.2,this.surfaceTensionNormalStrength=.2,this.repulsiveStrength=1,this.powderStrength=.5,this.ejectionStrength=.5,this.staticPressureStrength=.2,this.staticPressureRelaxation=.2,this.staticPressureIterations=8,this.colorMixingStrength=.5,this.destroyByAge=!0,this.lifetimeGranularity=1/60}Copy(t){return this.strictContactCheck=t.strictContactCheck,this.density=t.density,this.gravityScale=t.gravityScale,this.radius=t.radius,this.maxCount=t.maxCount,this.pressureStrength=t.pressureStrength,this.dampingStrength=t.dampingStrength,this.elasticStrength=t.elasticStrength,this.springStrength=t.springStrength,this.viscousStrength=t.viscousStrength,this.surfaceTensionPressureStrength=t.surfaceTensionPressureStrength,this.surfaceTensionNormalStrength=t.surfaceTensionNormalStrength,this.repulsiveStrength=t.repulsiveStrength,this.powderStrength=t.powderStrength,this.ejectionStrength=t.ejectionStrength,this.staticPressureStrength=t.staticPressureStrength,this.staticPressureRelaxation=t.staticPressureRelaxation,this.staticPressureIterations=t.staticPressureIterations,this.colorMixingStrength=t.colorMixingStrength,this.destroyByAge=t.destroyByAge,this.lifetimeGranularity=t.lifetimeGranularity,this}Clone(){return(new N_).Copy(this)}}class U_{constructor(t,e){this.m_paused=!1,this.m_timestamp=0,this.m_allParticleFlags=0,this.m_needsUpdateAllParticleFlags=!1,this.m_allGroupFlags=0,this.m_needsUpdateAllGroupFlags=!1,this.m_hasForce=!1,this.m_iterationIndex=0,this.m_inverseDensity=0,this.m_particleDiameter=0,this.m_inverseDiameter=0,this.m_squaredDiameter=0,this.m_count=0,this.m_internalAllocatedCapacity=0,this.m_handleIndexBuffer=new W_,this.m_flagsBuffer=new W_,this.m_positionBuffer=new W_,this.m_velocityBuffer=new W_,this.m_forceBuffer=[],this.m_weightBuffer=[],this.m_staticPressureBuffer=[],this.m_accumulationBuffer=[],this.m_accumulation2Buffer=[],this.m_depthBuffer=[],this.m_colorBuffer=new W_,this.m_groupBuffer=[],this.m_userDataBuffer=new W_,this.m_stuckThreshold=0,this.m_lastBodyContactStepBuffer=new W_,this.m_bodyContactCountBuffer=new W_,this.m_consecutiveContactStepsBuffer=new W_,this.m_stuckParticleBuffer=new L_((()=>0)),this.m_proxyBuffer=new L_((()=>new j_)),this.m_contactBuffer=new L_((()=>new F_)),this.m_bodyContactBuffer=new L_((()=>new k_)),this.m_pairBuffer=new L_((()=>new z_)),this.m_triadBuffer=new L_((()=>new O_)),this.m_expirationTimeBuffer=new W_,this.m_indexByExpirationTimeBuffer=new W_,this.m_timeElapsed=0,this.m_expirationTimeBufferRequiresSorting=!1,this.m_groupCount=0,this.m_groupList=null,this.m_def=new N_,this.m_prev=null,this.m_next=null,this.UpdateBodyContacts_callback=null,this.SolveCollision_callback=null,this.SetStrictContactCheck(t.strictContactCheck),this.SetDensity(t.density),this.SetGravityScale(t.gravityScale),this.SetRadius(t.radius),this.SetMaxParticleCount(t.maxCount),this.m_def=t.Clone(),this.m_world=e,this.SetDestructionByAge(this.m_def.destroyByAge)}static computeTag(t,e){return(e+U_.yOffset>>>0<<U_.yShift)+(U_.xScale*t+U_.xOffset>>>0)>>>0}static computeRelativeTag(t,e,i){return t+(i<<U_.yShift)+(e<<U_.xShift)>>>0}Drop(){for(;this.m_groupList;)this.DestroyParticleGroup(this.m_groupList);this.FreeUserOverridableBuffer(this.m_handleIndexBuffer),this.FreeUserOverridableBuffer(this.m_flagsBuffer),this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer),this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer),this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer),this.FreeUserOverridableBuffer(this.m_positionBuffer),this.FreeUserOverridableBuffer(this.m_velocityBuffer),this.FreeUserOverridableBuffer(this.m_colorBuffer),this.FreeUserOverridableBuffer(this.m_userDataBuffer),this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer),this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer),this.FreeBuffer(this.m_forceBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_weightBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_staticPressureBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulationBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulation2Buffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_depthBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_groupBuffer,this.m_internalAllocatedCapacity)}CreateParticle(t){if(this.m_world.IsLocked())throw new Error;if(this.m_count>=this.m_internalAllocatedCapacity){const t=this.m_count?2*this.m_count:256;this.ReallocateInternalAllocatedBuffers(t)}if(this.m_count>=this.m_internalAllocatedCapacity){if(!this.m_def.destroyByAge)return Gh;this.DestroyOldestParticle(0,!1),this.SolveZombie()}const e=this.m_count++;this.m_flagsBuffer.data[e]=0,this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[e]=0),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[e]=0),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[e]=0),this.m_positionBuffer.data[e]=(this.m_positionBuffer.data[e]||new Yh).Copy(Ah(t.position,Yh.ZERO)),this.m_velocityBuffer.data[e]=(this.m_velocityBuffer.data[e]||new Yh).Copy(Ah(t.velocity,Yh.ZERO)),this.m_weightBuffer[e]=0,this.m_forceBuffer[e]=(this.m_forceBuffer[e]||new Yh).SetZero(),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[e]=0),this.m_depthBuffer&&(this.m_depthBuffer[e]=0);const i=(new wh).Copy(Ah(t.color,wh.ZERO));!this.m_colorBuffer.data&&i.IsZero()||(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data[e]=(this.m_colorBuffer.data[e]||new wh).Copy(i)),(this.m_userDataBuffer.data||t.userData)&&(this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data[e]=t.userData),this.m_handleIndexBuffer.data&&(this.m_handleIndexBuffer.data[e]=null);const s=this.m_proxyBuffer.data[this.m_proxyBuffer.Append()],n=Ah(t.lifetime,0),r=n>0;(this.m_expirationTimeBuffer.data||r)&&(this.SetParticleLifetime(e,r?n:this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed())),this.m_indexByExpirationTimeBuffer.data[e]=e),s.index=e;const o=Ah(t.group,null);return this.m_groupBuffer[e]=o,o&&(o.m_firstIndex<o.m_lastIndex?(this.RotateBuffer(o.m_firstIndex,o.m_lastIndex,e),o.m_lastIndex=e+1):(o.m_firstIndex=e,o.m_lastIndex=e+1)),this.SetParticleFlags(e,Ah(t.flags,0)),e}GetParticleHandleFromIndex(t){this.m_handleIndexBuffer.data=this.RequestBuffer(this.m_handleIndexBuffer.data);let e=this.m_handleIndexBuffer.data[t];return e||(e=new v_,e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e,e)}DestroyParticle(t,e=!1){let i=p_.b2_zombieParticle;e&&(i|=p_.b2_destructionListenerParticle),this.SetParticleFlags(t,this.m_flagsBuffer.data[t]|i)}DestroyOldestParticle(t,e=!1){const i=this.GetParticleCount(),s=this.m_indexByExpirationTimeBuffer.data[i-(t+1)],n=this.m_indexByExpirationTimeBuffer.data[t];this.DestroyParticle(this.m_expirationTimeBuffer.data[s]>0?s:n,e)}DestroyParticlesInShape(t,e,i=!1){const s=U_.DestroyParticlesInShape_s_aabb;if(this.m_world.IsLocked())throw new Error;const n=new Q_(this,t,e,i),r=s;return t.ComputeAABB(r,e,0),this.m_world.QueryAABB(n,r),n.Destroyed()}CreateParticleGroup(t){const e=U_.CreateParticleGroup_s_transform;if(this.m_world.IsLocked())throw new Error;const i=e;i.SetPositionAngle(Ah(t.position,Yh.ZERO),Ah(t.angle,0));const s=this.m_count;if(t.shape&&this.CreateParticlesWithShapeForGroup(t.shape,t,i),t.shapes&&this.CreateParticlesWithShapesForGroup(t.shapes,Ah(t.shapeCount,t.shapes.length),t,i),t.positionData){const e=Ah(t.particleCount,t.positionData.length);for(let s=0;s<e;s++){const e=t.positionData[s];this.CreateParticleForGroup(t,i,e)}}const n=this.m_count;let r=new w_(this);r.m_firstIndex=s,r.m_lastIndex=n,r.m_strength=Ah(t.strength,1),r.m_userData=t.userData,r.m_transform.Copy(i),r.m_prev=null,r.m_next=this.m_groupList,this.m_groupList&&(this.m_groupList.m_prev=r),this.m_groupList=r,++this.m_groupCount;for(let t=s;t<n;t++)this.m_groupBuffer[t]=r;this.SetGroupFlags(r,Ah(t.groupFlags,0));const o=new Y_;return this.UpdateContacts(!0),this.UpdatePairsAndTriads(s,n,o),t.group&&(this.JoinParticleGroups(t.group,r),r=t.group),r}JoinParticleGroups(t,e){if(this.m_world.IsLocked())throw new Error;this.RotateBuffer(e.m_firstIndex,e.m_lastIndex,this.m_count),this.RotateBuffer(t.m_firstIndex,t.m_lastIndex,e.m_firstIndex);const i=new K_(e.m_firstIndex);this.UpdateContacts(!0),this.UpdatePairsAndTriads(t.m_firstIndex,e.m_lastIndex,i);for(let i=e.m_firstIndex;i<e.m_lastIndex;i++)this.m_groupBuffer[i]=t;const s=t.m_groupFlags|e.m_groupFlags;this.SetGroupFlags(t,s),t.m_lastIndex=e.m_lastIndex,e.m_firstIndex=e.m_lastIndex,this.DestroyParticleGroup(e)}SplitParticleGroup(t){this.UpdateContacts(!0);const e=Fh(t.GetParticleCount(),(t=>new q_));U_.InitializeParticleLists(t,e),this.MergeParticleListsInContact(t,e);const i=U_.FindLongestParticleList(t,e);this.MergeZombieParticleListNodes(t,e,i),this.CreateParticleGroupsFromParticleList(t,e,i),this.UpdatePairsAndTriadsWithParticleList(t,e)}GetParticleGroupList(){return this.m_groupList}GetParticleGroupCount(){return this.m_groupCount}GetParticleCount(){return this.m_count}GetMaxParticleCount(){return this.m_def.maxCount}SetMaxParticleCount(t){this.m_def.maxCount=t}GetAllParticleFlags(){return this.m_allParticleFlags}GetAllGroupFlags(){return this.m_allGroupFlags}SetPaused(t){this.m_paused=t}GetPaused(){return this.m_paused}SetDensity(t){this.m_def.density=t,this.m_inverseDensity=1/this.m_def.density}GetDensity(){return this.m_def.density}SetGravityScale(t){this.m_def.gravityScale=t}GetGravityScale(){return this.m_def.gravityScale}SetDamping(t){this.m_def.dampingStrength=t}GetDamping(){return this.m_def.dampingStrength}SetStaticPressureIterations(t){this.m_def.staticPressureIterations=t}GetStaticPressureIterations(){return this.m_def.staticPressureIterations}SetRadius(t){this.m_particleDiameter=2*t,this.m_squaredDiameter=this.m_particleDiameter*this.m_particleDiameter,this.m_inverseDiameter=1/this.m_particleDiameter}GetRadius(){return this.m_particleDiameter/2}GetPositionBuffer(){return this.m_positionBuffer.data}GetVelocityBuffer(){return this.m_velocityBuffer.data}GetColorBuffer(){return this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data}GetGroupBuffer(){return this.m_groupBuffer}GetWeightBuffer(){return this.m_weightBuffer}GetUserDataBuffer(){return this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data}GetFlagsBuffer(){return this.m_flagsBuffer.data}SetParticleFlags(t,e){this.m_flagsBuffer.data[t]&~e&&(this.m_needsUpdateAllParticleFlags=!0),~this.m_allParticleFlags&e&&(e&p_.b2_tensileParticle&&(this.m_accumulation2Buffer=this.RequestBuffer(this.m_accumulation2Buffer)),e&p_.b2_colorMixingParticle&&(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data)),this.m_allParticleFlags|=e),this.m_flagsBuffer.data[t]=e}GetParticleFlags(t){return this.m_flagsBuffer.data[t]}SetFlagsBuffer(t){this.SetUserOverridableBuffer(this.m_flagsBuffer,t)}SetPositionBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,i=new Array(e);for(let s=0;s<e;++s)i[s]=new Qh(t.subarray(2*s,2*s+2));t=i}this.SetUserOverridableBuffer(this.m_positionBuffer,t)}SetVelocityBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,i=new Array(e);for(let s=0;s<e;++s)i[s]=new Qh(t.subarray(2*s,2*s+2));t=i}this.SetUserOverridableBuffer(this.m_velocityBuffer,t)}SetColorBuffer(t){if(t instanceof Float32Array){if(t.length%4!=0)throw new Error;const e=t.length/4,i=new Array(e);for(let s=0;s<e;++s)i[s]=new bh(t.subarray(4*s,4*s+4));t=i}this.SetUserOverridableBuffer(this.m_colorBuffer,t)}SetUserDataBuffer(t){this.SetUserOverridableBuffer(this.m_userDataBuffer,t)}GetContacts(){return this.m_contactBuffer.data}GetContactCount(){return this.m_contactBuffer.count}GetBodyContacts(){return this.m_bodyContactBuffer.data}GetBodyContactCount(){return this.m_bodyContactBuffer.count}GetPairs(){return this.m_pairBuffer.data}GetPairCount(){return this.m_pairBuffer.count}GetTriads(){return this.m_triadBuffer.data}GetTriadCount(){return this.m_triadBuffer.count}SetStuckThreshold(t){this.m_stuckThreshold=t,t>0&&(this.m_lastBodyContactStepBuffer.data=this.RequestBuffer(this.m_lastBodyContactStepBuffer.data),this.m_bodyContactCountBuffer.data=this.RequestBuffer(this.m_bodyContactCountBuffer.data),this.m_consecutiveContactStepsBuffer.data=this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data))}GetStuckCandidates(){return this.m_stuckParticleBuffer.Data()}GetStuckCandidateCount(){return this.m_stuckParticleBuffer.GetCount()}ComputeCollisionEnergy(){const t=U_.ComputeCollisionEnergy_s_v,e=this.m_velocityBuffer.data;let i=0;for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,o=n.indexB,a=n.normal,l=Yh.SubVV(e[o],e[r],t),h=Yh.DotVV(l,a);h<0&&(i+=h*h)}return.5*this.GetParticleMass()*i}SetStrictContactCheck(t){this.m_def.strictContactCheck=t}GetStrictContactCheck(){return this.m_def.strictContactCheck}SetParticleLifetime(t,e){const i=null===this.m_indexByExpirationTimeBuffer.data;if(this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),i){const t=this.GetParticleCount();for(let e=0;e<t;++e)this.m_indexByExpirationTimeBuffer.data[e]=e}const s=e/this.m_def.lifetimeGranularity,n=s>0?this.GetQuantizedTimeElapsed()+s:s;n!==this.m_expirationTimeBuffer.data[t]&&(this.m_expirationTimeBuffer.data[t]=n,this.m_expirationTimeBufferRequiresSorting=!0)}GetParticleLifetime(t){return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[t])}SetDestructionByAge(t){t&&this.GetExpirationTimeBuffer(),this.m_def.destroyByAge=t}GetDestructionByAge(){return this.m_def.destroyByAge}GetExpirationTimeBuffer(){return this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_expirationTimeBuffer.data}ExpirationTimeToLifetime(t){return(t>0?t-this.GetQuantizedTimeElapsed():t)*this.m_def.lifetimeGranularity}GetIndexByExpirationTimeBuffer(){return this.GetParticleCount()?this.SetParticleLifetime(0,this.GetParticleLifetime(0)):this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data}ParticleApplyLinearImpulse(t,e){this.ApplyLinearImpulse(t,t+1,e)}ApplyLinearImpulse(t,e,i){const s=this.m_velocityBuffer.data,n=(e-t)*this.GetParticleMass(),r=(new Yh).Copy(i).SelfMul(1/n);for(let i=t;i<e;i++)s[i].SelfAdd(r)}static IsSignificantForce(t){return 0!==t.x||0!==t.y}ParticleApplyForce(t,e){U_.IsSignificantForce(e)&&this.ForceCanBeApplied(this.m_flagsBuffer.data[t])&&(this.PrepareForceBuffer(),this.m_forceBuffer[t].SelfAdd(e))}ApplyForce(t,e,i){const s=(new Yh).Copy(i).SelfMul(1/(e-t));if(U_.IsSignificantForce(s)){this.PrepareForceBuffer();for(let i=t;i<e;i++)this.m_forceBuffer[i].SelfAdd(s)}}GetNext(){return this.m_next}QueryAABB(t,e){if(0===this.m_proxyBuffer.count)return;const i=this.m_proxyBuffer.count,s=I_(this.m_proxyBuffer.data,0,i,U_.computeTag(this.m_inverseDiameter*e.lowerBound.x,this.m_inverseDiameter*e.lowerBound.y),j_.CompareProxyTag),n=E_(this.m_proxyBuffer.data,s,i,U_.computeTag(this.m_inverseDiameter*e.upperBound.x,this.m_inverseDiameter*e.upperBound.y),j_.CompareTagProxy),r=this.m_positionBuffer.data;for(let i=s;i<n;++i){const s=this.m_proxyBuffer.data[i].index,n=r[s];if(e.lowerBound.x<n.x&&n.x<e.upperBound.x&&e.lowerBound.y<n.y&&n.y<e.upperBound.y&&!t.ReportParticle(this,s))break}}QueryShapeAABB(t,e,i,s=0){const n=U_.QueryShapeAABB_s_aabb;e.ComputeAABB(n,i,s),this.QueryAABB(t,n)}QueryPointAABB(t,e,i=.005){const s=U_.QueryPointAABB_s_aabb;s.lowerBound.Set(e.x-i,e.y-i),s.upperBound.Set(e.x+i,e.y+i),this.QueryAABB(t,s)}RayCast(t,e,i){const s=U_.RayCast_s_aabb,n=U_.RayCast_s_p,r=U_.RayCast_s_v,o=U_.RayCast_s_n,a=U_.RayCast_s_point;if(0===this.m_proxyBuffer.count)return;const l=this.m_positionBuffer.data,h=s;Yh.MinV(e,i,h.lowerBound),Yh.MaxV(e,i,h.upperBound);let c=1;const m=Yh.SubVV(i,e,r),u=Yh.DotVV(m,m),_=this.GetInsideBoundsEnumerator(h);let d;for(;(d=_.GetNext())>=0;){const i=Yh.SubVV(e,l[d],n),s=Yh.DotVV(i,m),r=s*s-u*(Yh.DotVV(i,i)-this.m_squaredDiameter);if(r>=0){const n=Xh(r);let l=(-s-n)/u;if(l>c)continue;if(l<0&&(l=(-s+n)/u,l<0||l>c))continue;const h=Yh.AddVMulSV(i,l,m,o);if(h.Normalize(),c=Uh(c,t.ReportParticle(this,d,Yh.AddVMulSV(e,l,m,a),h,l)),c<=0)break}}}ComputeAABB(t){const e=this.GetParticleCount();t.lowerBound.x=+Bh,t.lowerBound.y=+Bh,t.upperBound.x=-Bh,t.upperBound.y=-Bh;const i=this.m_positionBuffer.data;for(let s=0;s<e;s++){const e=i[s];Yh.MinV(t.lowerBound,e,t.lowerBound),Yh.MaxV(t.upperBound,e,t.upperBound)}t.lowerBound.x-=this.m_particleDiameter,t.lowerBound.y-=this.m_particleDiameter,t.upperBound.x+=this.m_particleDiameter,t.upperBound.y+=this.m_particleDiameter}FreeBuffer(t,e){null!==t&&(t.length=0)}FreeUserOverridableBuffer(t){0===t.userSuppliedCapacity&&this.FreeBuffer(t.data,this.m_internalAllocatedCapacity)}ReallocateBuffer3(t,e,i){if(i<=e)throw new Error;const s=t?t.slice():[];return s.length=i,s}ReallocateBuffer5(t,e,i,s,n){if(s<=i)throw new Error;if(e&&!(s<=e))throw new Error;return n&&!t||e||(t=this.ReallocateBuffer3(t,i,s)),t}ReallocateBuffer4(t,e,i,s){return this.ReallocateBuffer5(t.data,t.userSuppliedCapacity,e,i,s)}RequestBuffer(t){return t||(0===this.m_internalAllocatedCapacity&&this.ReallocateInternalAllocatedBuffers(256),(t=[]).length=this.m_internalAllocatedCapacity),t}ReallocateHandleBuffers(t){this.m_handleIndexBuffer.data=this.ReallocateBuffer4(this.m_handleIndexBuffer,this.m_internalAllocatedCapacity,t,!0)}ReallocateInternalAllocatedBuffers(t){function e(t,e){return e&&t>e?e:t}if(t=e(t,this.m_def.maxCount),t=e(t,this.m_flagsBuffer.userSuppliedCapacity),t=e(t,this.m_positionBuffer.userSuppliedCapacity),t=e(t,this.m_velocityBuffer.userSuppliedCapacity),t=e(t,this.m_colorBuffer.userSuppliedCapacity),t=e(t,this.m_userDataBuffer.userSuppliedCapacity),this.m_internalAllocatedCapacity<t){this.ReallocateHandleBuffers(t),this.m_flagsBuffer.data=this.ReallocateBuffer4(this.m_flagsBuffer,this.m_internalAllocatedCapacity,t,!1);const e=this.m_stuckThreshold>0;this.m_lastBodyContactStepBuffer.data=this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer,this.m_internalAllocatedCapacity,t,e),this.m_bodyContactCountBuffer.data=this.ReallocateBuffer4(this.m_bodyContactCountBuffer,this.m_internalAllocatedCapacity,t,e),this.m_consecutiveContactStepsBuffer.data=this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer,this.m_internalAllocatedCapacity,t,e),this.m_positionBuffer.data=this.ReallocateBuffer4(this.m_positionBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_velocityBuffer.data=this.ReallocateBuffer4(this.m_velocityBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_forceBuffer=this.ReallocateBuffer5(this.m_forceBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_weightBuffer=this.ReallocateBuffer5(this.m_weightBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_staticPressureBuffer=this.ReallocateBuffer5(this.m_staticPressureBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_accumulationBuffer=this.ReallocateBuffer5(this.m_accumulationBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_accumulation2Buffer=this.ReallocateBuffer5(this.m_accumulation2Buffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_depthBuffer=this.ReallocateBuffer5(this.m_depthBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_colorBuffer.data=this.ReallocateBuffer4(this.m_colorBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_groupBuffer=this.ReallocateBuffer5(this.m_groupBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_userDataBuffer.data=this.ReallocateBuffer4(this.m_userDataBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_expirationTimeBuffer.data=this.ReallocateBuffer4(this.m_expirationTimeBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_indexByExpirationTimeBuffer.data=this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_internalAllocatedCapacity=t}}CreateParticleForGroup(t,e,i){const s=new x_;s.flags=Ah(t.flags,0),ic.MulXV(e,i,s.position),Yh.AddVV(Ah(t.linearVelocity,Yh.ZERO),Yh.CrossSV(Ah(t.angularVelocity,0),Yh.SubVV(s.position,Ah(t.position,Yh.ZERO),Yh.s_t0),Yh.s_t0),s.velocity),s.color.Copy(Ah(t.color,wh.ZERO)),s.lifetime=Ah(t.lifetime,0),s.userData=t.userData,this.CreateParticle(s)}CreateParticlesStrokeShapeForGroup(t,e,i){const s=U_.CreateParticlesStrokeShapeForGroup_s_edge,n=U_.CreateParticlesStrokeShapeForGroup_s_d,r=U_.CreateParticlesStrokeShapeForGroup_s_p;let o=Ah(e.stride,0);0===o&&(o=this.GetParticleStride());let a=0;const l=t.GetChildCount();for(let h=0;h<l;h++){let l=null;t.GetType()===jc.e_edgeShape?l=t:(l=s,t.GetChildEdge(l,h));const c=Yh.SubVV(l.m_vertex2,l.m_vertex1,n),m=c.Length();for(;a<m;){const t=Yh.AddVMulSV(l.m_vertex1,a/m,c,r);this.CreateParticleForGroup(e,i,t),a+=o}a-=m}}CreateParticlesFillShapeForGroup(t,e,i){const s=U_.CreateParticlesFillShapeForGroup_s_aabb,n=U_.CreateParticlesFillShapeForGroup_s_p;let r=Ah(e.stride,0);0===r&&(r=this.GetParticleStride());const o=ic.IDENTITY,a=s;t.ComputeAABB(a,o,0);for(let s=Math.floor(a.lowerBound.y/r)*r;s<a.upperBound.y;s+=r)for(let l=Math.floor(a.lowerBound.x/r)*r;l<a.upperBound.x;l+=r){const r=n.Set(l,s);t.TestPoint(o,r)&&this.CreateParticleForGroup(e,i,r)}}CreateParticlesWithShapeForGroup(t,e,i){switch(t.GetType()){case jc.e_edgeShape:case jc.e_chainShape:this.CreateParticlesStrokeShapeForGroup(t,e,i);break;case jc.e_polygonShape:case jc.e_circleShape:this.CreateParticlesFillShapeForGroup(t,e,i)}}CreateParticlesWithShapesForGroup(t,e,i,s){const n=new $_(t,e);this.CreateParticlesFillShapeForGroup(n,i,s)}CloneParticle(t,e){const i=new x_;i.flags=this.m_flagsBuffer.data[t],i.position.Copy(this.m_positionBuffer.data[t]),i.velocity.Copy(this.m_velocityBuffer.data[t]),this.m_colorBuffer.data&&i.color.Copy(this.m_colorBuffer.data[t]),this.m_userDataBuffer.data&&(i.userData=this.m_userDataBuffer.data[t]),i.group=e;const s=this.CreateParticle(i);if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[t];e&&e.SetIndex(s),this.m_handleIndexBuffer.data[s]=e,this.m_handleIndexBuffer.data[t]=null}return this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[s]=this.m_lastBodyContactStepBuffer.data[t]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[s]=this.m_bodyContactCountBuffer.data[t]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[s]=this.m_consecutiveContactStepsBuffer.data[t]),this.m_hasForce&&this.m_forceBuffer[s].Copy(this.m_forceBuffer[t]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[s]=this.m_staticPressureBuffer[t]),this.m_depthBuffer&&(this.m_depthBuffer[s]=this.m_depthBuffer[t]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[s]=this.m_expirationTimeBuffer.data[t]),s}DestroyParticlesInGroup(t,e=!1){for(let i=t.m_firstIndex;i<t.m_lastIndex;i++)this.DestroyParticle(i,e)}DestroyParticleGroup(t){this.m_world.m_destructionListener&&this.m_world.m_destructionListener.SayGoodbyeParticleGroup(t),this.SetGroupFlags(t,0);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_groupBuffer[e]=null;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_groupList&&(this.m_groupList=t.m_next),--this.m_groupCount}static ParticleCanBeConnected(t,e){return 0!=(t&(p_.b2_wallParticle|p_.b2_springParticle|p_.b2_elasticParticle))||null!==e&&0!=(e.GetGroupFlags()&f_.b2_rigidParticleGroup)}UpdatePairsAndTriads(t,e,i){const s=U_.UpdatePairsAndTriads_s_dab,n=U_.UpdatePairsAndTriads_s_dbc,r=U_.UpdatePairsAndTriads_s_dca,o=this.m_positionBuffer.data;let a=0;for(let i=t;i<e;i++)a|=this.m_flagsBuffer.data[i];if(a&U_.k_pairFlags)for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,a=n.indexB,l=this.m_flagsBuffer.data[r],h=this.m_flagsBuffer.data[a],c=this.m_groupBuffer[r],m=this.m_groupBuffer[a];if(r>=t&&r<e&&a>=t&&a<e&&!((l|h)&p_.b2_zombieParticle)&&(l|h)&U_.k_pairFlags&&(i.IsNecessary(r)||i.IsNecessary(a))&&U_.ParticleCanBeConnected(l,c)&&U_.ParticleCanBeConnected(h,m)&&i.ShouldCreatePair(r,a)){const t=this.m_pairBuffer.data[this.m_pairBuffer.Append()];t.indexA=r,t.indexB=a,t.flags=n.flags,t.strength=Uh(c?c.m_strength:1,m?m.m_strength:1),t.distance=Yh.DistanceVV(o[r],o[a])}P_(this.m_pairBuffer.data,0,this.m_pairBuffer.count,U_.ComparePairIndices),this.m_pairBuffer.Unique(U_.MatchPairIndices)}if(a&U_.k_triadFlags){const a=new C_(e-t);for(let s=t;s<e;s++){const t=this.m_flagsBuffer.data[s],e=this.m_groupBuffer[s];t&p_.b2_zombieParticle||!U_.ParticleCanBeConnected(t,e)||a.AddGenerator(o[s],s,i.IsNecessary(s))}const l=this.GetParticleStride();a.Generate(l/2,2*l);const h=this,c=(t,e,a)=>{const l=h.m_flagsBuffer.data[t],c=h.m_flagsBuffer.data[e],m=h.m_flagsBuffer.data[a];if((l|c|m)&U_.k_triadFlags&&i.ShouldCreateTriad(t,e,a)){const i=o[t],u=o[e],_=o[a],d=Yh.SubVV(i,u,s),p=Yh.SubVV(u,_,n),f=Yh.SubVV(_,i,r),y=4*h.m_squaredDiameter;if(Yh.DotVV(d,d)>y||Yh.DotVV(p,p)>y||Yh.DotVV(f,f)>y)return;const g=h.m_groupBuffer[t],x=h.m_groupBuffer[e],v=h.m_groupBuffer[a],S=h.m_triadBuffer.data[h.m_triadBuffer.Append()];S.indexA=t,S.indexB=e,S.indexC=a,S.flags=l|c|m,S.strength=Uh(Uh(g?g.m_strength:1,x?x.m_strength:1),v?v.m_strength:1);const w=(i.x+u.x+_.x)/3,b=(i.y+u.y+_.y)/3;S.pa.x=i.x-w,S.pa.y=i.y-b,S.pb.x=u.x-w,S.pb.y=u.y-b,S.pc.x=_.x-w,S.pc.y=_.y-b,S.ka=-Yh.DotVV(f,d),S.kb=-Yh.DotVV(d,p),S.kc=-Yh.DotVV(p,f),S.s=Yh.CrossVV(i,u)+Yh.CrossVV(u,_)+Yh.CrossVV(_,i)}};a.GetNodes(c),P_(this.m_triadBuffer.data,0,this.m_triadBuffer.count,U_.CompareTriadIndices),this.m_triadBuffer.Unique(U_.MatchTriadIndices)}}UpdatePairsAndTriadsWithReactiveParticles(){const t=new td(this.m_flagsBuffer);this.UpdatePairsAndTriads(0,this.m_count,t);for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&=~p_.b2_reactiveParticle;this.m_allParticleFlags&=~p_.b2_reactiveParticle}static ComparePairIndices(t,e){const i=t.indexA-e.indexA;return 0!==i?i<0:t.indexB<e.indexB}static MatchPairIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB}static CompareTriadIndices(t,e){const i=t.indexA-e.indexA;if(0!==i)return i<0;const s=t.indexB-e.indexB;return 0!==s?s<0:t.indexC<e.indexC}static MatchTriadIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB&&t.indexC===e.indexC}static InitializeParticleLists(t,e){const i=t.GetBufferIndex(),s=t.GetParticleCount();for(let t=0;t<s;t++){const s=e[t];s.list=s,s.next=null,s.count=1,s.index=t+i}}MergeParticleListsInContact(t,e){const i=t.GetBufferIndex();for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,o=n.indexB;if(!t.ContainsParticle(r)||!t.ContainsParticle(o))continue;let a=e[r-i].list,l=e[o-i].list;if(a!==l){if(a.count<l.count){const t=a;a=l,l=t}U_.MergeParticleLists(a,l)}}}static MergeParticleLists(t,e){for(let i=e;;){i.list=t;const e=i.next;if(!e){i.next=t.next;break}i=e}t.next=e,t.count+=e.count,e.count=0}static FindLongestParticleList(t,e){const i=t.GetParticleCount();let s=e[0];for(let t=0;t<i;t++){const i=e[t];s.count<i.count&&(s=i)}return s}MergeZombieParticleListNodes(t,e,i){const s=t.GetParticleCount();for(let t=0;t<s;t++){const s=e[t];s!==i&&this.m_flagsBuffer.data[s.index]&p_.b2_zombieParticle&&U_.MergeParticleListAndNode(i,s)}}static MergeParticleListAndNode(t,e){e.list=t,e.next=t.next,t.next=e,t.count++,e.count=0}CreateParticleGroupsFromParticleList(t,e,i){const s=t.GetParticleCount(),n=new S_;n.groupFlags=t.GetGroupFlags(),n.userData=t.GetUserData();for(let t=0;t<s;t++){const s=e[t];if(!s.count||s===i)continue;const r=this.CreateParticleGroup(n);for(let t=s;t;t=t.next){const e=t.index,i=this.CloneParticle(e,r);this.m_flagsBuffer.data[e]|=p_.b2_zombieParticle,t.index=i}}}UpdatePairsAndTriadsWithParticleList(t,e){const i=t.GetBufferIndex();for(let s=0;s<this.m_pairBuffer.count;s++){const n=this.m_pairBuffer.data[s],r=n.indexA,o=n.indexB;t.ContainsParticle(r)&&(n.indexA=e[r-i].index),t.ContainsParticle(o)&&(n.indexB=e[o-i].index)}for(let s=0;s<this.m_triadBuffer.count;s++){const n=this.m_triadBuffer.data[s],r=n.indexA,o=n.indexB,a=n.indexC;t.ContainsParticle(r)&&(n.indexA=e[r-i].index),t.ContainsParticle(o)&&(n.indexB=e[o-i].index),t.ContainsParticle(a)&&(n.indexC=e[a-i].index)}}ComputeDepth(){const t=[];let e=0;for(let i=0;i<this.m_contactBuffer.count;i++){const s=this.m_contactBuffer.data[i],n=s.indexA,r=s.indexB,o=this.m_groupBuffer[n],a=this.m_groupBuffer[r];o&&o===a&&o.m_groupFlags&f_.b2_particleGroupNeedsUpdateDepth&&(t[e++]=s)}const i=[];let s=0;for(let t=this.m_groupList;t;t=t.GetNext())if(t.m_groupFlags&f_.b2_particleGroupNeedsUpdateDepth){i[s++]=t,this.SetGroupFlags(t,t.m_groupFlags&~f_.b2_particleGroupNeedsUpdateDepth);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_accumulationBuffer[e]=0}for(let i=0;i<e;i++){const e=t[i],s=e.indexA,n=e.indexB,r=e.weight;this.m_accumulationBuffer[s]+=r,this.m_accumulationBuffer[n]+=r}for(let t=0;t<s;t++){const e=i[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++){const e=this.m_accumulationBuffer[t];this.m_depthBuffer[t]=e<.8?0:Bh}}const n=Xh(this.m_count)>>0;for(let i=0;i<n;i++){let i=!1;for(let s=0;s<e;s++){const e=t[s],n=e.indexA,r=e.indexB,o=1-e.weight,a=this.m_depthBuffer[n],l=this.m_depthBuffer[r],h=l+o,c=a+o;a>h&&(this.m_depthBuffer[n]=h,i=!0),l>c&&(this.m_depthBuffer[r]=c,i=!0)}if(!i)break}for(let t=0;t<s;t++){const e=i[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++)this.m_depthBuffer[t]<Bh?this.m_depthBuffer[t]*=this.m_particleDiameter:this.m_depthBuffer[t]=0}}GetInsideBoundsEnumerator(t){const e=U_.computeTag(this.m_inverseDiameter*t.lowerBound.x-1,this.m_inverseDiameter*t.lowerBound.y-1),i=U_.computeTag(this.m_inverseDiameter*t.upperBound.x+1,this.m_inverseDiameter*t.upperBound.y+1),s=this.m_proxyBuffer.count,n=I_(this.m_proxyBuffer.data,0,s,e,j_.CompareProxyTag),r=E_(this.m_proxyBuffer.data,0,s,i,j_.CompareTagProxy);return new H_(this,e,i,n,r)}UpdateAllParticleFlags(){this.m_allParticleFlags=0;for(let t=0;t<this.m_count;t++)this.m_allParticleFlags|=this.m_flagsBuffer.data[t];this.m_needsUpdateAllParticleFlags=!1}UpdateAllGroupFlags(){this.m_allGroupFlags=0;for(let t=this.m_groupList;t;t=t.GetNext())this.m_allGroupFlags|=t.m_groupFlags;this.m_needsUpdateAllGroupFlags=!1}AddContact(t,e,i){const s=this.m_flagsBuffer.data,n=this.m_positionBuffer.data,r=Yh.SubVV(n[e],n[t],U_.AddContact_s_d),o=Yh.DotVV(r,r);if(0<o&&o<this.m_squaredDiameter){const i=qh(o),n=this.m_contactBuffer.data[this.m_contactBuffer.Append()];n.indexA=t,n.indexB=e,n.flags=s[t]|s[e],n.weight=1-o*i*this.m_inverseDiameter,n.normal.x=i*r.x,n.normal.y=i*r.y}}FindContacts_Reference(t){const e=this.m_proxyBuffer.count;this.m_contactBuffer.count=0;for(let t=0,i=0;t<e;t++){const s=U_.computeRelativeTag(this.m_proxyBuffer.data[t].tag,1,0);for(let i=t+1;i<e&&!(s<this.m_proxyBuffer.data[i].tag);i++)this.AddContact(this.m_proxyBuffer.data[t].index,this.m_proxyBuffer.data[i].index,this.m_contactBuffer);const n=U_.computeRelativeTag(this.m_proxyBuffer.data[t].tag,-1,1);for(;i<e&&!(n<=this.m_proxyBuffer.data[i].tag);i++);const r=U_.computeRelativeTag(this.m_proxyBuffer.data[t].tag,1,1);for(let s=i;s<e&&!(r<this.m_proxyBuffer.data[s].tag);s++)this.AddContact(this.m_proxyBuffer.data[t].index,this.m_proxyBuffer.data[s].index,this.m_contactBuffer)}}FindContacts(t){this.FindContacts_Reference(t)}UpdateProxies_Reference(t){const e=this.m_positionBuffer.data,i=this.m_inverseDiameter;for(let t=0;t<this.m_proxyBuffer.count;++t){const s=this.m_proxyBuffer.data[t],n=e[s.index];s.tag=U_.computeTag(i*n.x,i*n.y)}}UpdateProxies(t){this.UpdateProxies_Reference(t)}SortProxies(t){T_(this.m_proxyBuffer.data,0,this.m_proxyBuffer.count,j_.CompareProxyProxy)}FilterContacts(t){const e=this.GetParticleContactFilter();if(null===e)return;const i=this;this.m_contactBuffer.RemoveIf((t=>0!=(t.flags&p_.b2_particleContactFilterParticle)&&!e.ShouldCollideParticleParticle(i,t.indexA,t.indexB)))}NotifyContactListenerPreContact(t){if(null!==this.GetParticleContactListener())throw t.Initialize(this.m_contactBuffer,this.m_flagsBuffer),new Error}NotifyContactListenerPostContact(t){const e=this.GetParticleContactListener();if(null!==e){for(let i=0;i<this.m_contactBuffer.count;++i){const s=this.m_contactBuffer.data[i],n=-1;n>=0?t.Invalidate(n):e.BeginContactParticleParticle(this,s)}throw new Error}}static b2ParticleContactIsZombie(t){return(t.flags&p_.b2_zombieParticle)===p_.b2_zombieParticle}UpdateContacts(t){this.UpdateProxies(this.m_proxyBuffer),this.SortProxies(this.m_proxyBuffer);const e=new Z_;this.NotifyContactListenerPreContact(e),this.FindContacts(this.m_contactBuffer),this.FilterContacts(this.m_contactBuffer),this.NotifyContactListenerPostContact(e),t&&this.m_contactBuffer.RemoveIf(U_.b2ParticleContactIsZombie)}NotifyBodyContactListenerPreContact(t){if(null!==this.GetFixtureContactListener())throw t.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer),new Error}NotifyBodyContactListenerPostContact(t){const e=this.GetFixtureContactListener();if(null!==e){for(let i=0;i<this.m_bodyContactBuffer.count;i++){const s=this.m_bodyContactBuffer.data[i],n=-1;n>=0?t.Invalidate(n):e.BeginContactFixtureParticle(this,s)}throw new Error}}UpdateBodyContacts(){const t=U_.UpdateBodyContacts_s_aabb,e=new J_;if(this.NotifyBodyContactListenerPreContact(e),this.m_stuckThreshold>0){const t=this.GetParticleCount();for(let e=0;e<t;e++)this.m_bodyContactCountBuffer.data[e]=0,this.m_timestamp>this.m_lastBodyContactStepBuffer.data[e]+1&&(this.m_consecutiveContactStepsBuffer.data[e]=0)}this.m_bodyContactBuffer.SetCount(0),this.m_stuckParticleBuffer.SetCount(0);const i=t;this.ComputeAABB(i),null===this.UpdateBodyContacts_callback&&(this.UpdateBodyContacts_callback=new ed(this));const s=this.UpdateBodyContacts_callback;s.m_contactFilter=this.GetFixtureContactFilter(),this.m_world.QueryAABB(s,i),this.m_def.strictContactCheck&&this.RemoveSpuriousBodyContacts(),this.NotifyBodyContactListenerPostContact(e)}Solve(t){const e=U_.Solve_s_subStep;if(0!==this.m_count&&(this.m_expirationTimeBuffer.data&&this.SolveLifetimes(t),this.m_allParticleFlags&p_.b2_zombieParticle&&this.SolveZombie(),this.m_needsUpdateAllParticleFlags&&this.UpdateAllParticleFlags(),this.m_needsUpdateAllGroupFlags&&this.UpdateAllGroupFlags(),!this.m_paused))for(this.m_iterationIndex=0;this.m_iterationIndex<t.particleIterations;this.m_iterationIndex++){++this.m_timestamp;const i=e.Copy(t);i.dt/=t.particleIterations,i.inv_dt*=t.particleIterations,this.UpdateContacts(!1),this.UpdateBodyContacts(),this.ComputeWeight(),this.m_allGroupFlags&f_.b2_particleGroupNeedsUpdateDepth&&this.ComputeDepth(),this.m_allParticleFlags&p_.b2_reactiveParticle&&this.UpdatePairsAndTriadsWithReactiveParticles(),this.m_hasForce&&this.SolveForce(i),this.m_allParticleFlags&p_.b2_viscousParticle&&this.SolveViscous(),this.m_allParticleFlags&p_.b2_repulsiveParticle&&this.SolveRepulsive(i),this.m_allParticleFlags&p_.b2_powderParticle&&this.SolvePowder(i),this.m_allParticleFlags&p_.b2_tensileParticle&&this.SolveTensile(i),this.m_allGroupFlags&f_.b2_solidParticleGroup&&this.SolveSolid(i),this.m_allParticleFlags&p_.b2_colorMixingParticle&&this.SolveColorMixing(),this.SolveGravity(i),this.m_allParticleFlags&p_.b2_staticPressureParticle&&this.SolveStaticPressure(i),this.SolvePressure(i),this.SolveDamping(i),this.m_allParticleFlags&U_.k_extraDampingFlags&&this.SolveExtraDamping(),this.m_allParticleFlags&p_.b2_elasticParticle&&this.SolveElastic(i),this.m_allParticleFlags&p_.b2_springParticle&&this.SolveSpring(i),this.LimitVelocity(i),this.m_allGroupFlags&f_.b2_rigidParticleGroup&&this.SolveRigidDamping(),this.m_allParticleFlags&p_.b2_barrierParticle&&this.SolveBarrier(i),this.SolveCollision(i),this.m_allGroupFlags&f_.b2_rigidParticleGroup&&this.SolveRigid(i),this.m_allParticleFlags&p_.b2_wallParticle&&this.SolveWall();for(let t=0;t<this.m_count;t++)this.m_positionBuffer.data[t].SelfMulAdd(i.dt,this.m_velocityBuffer.data[t])}}SolveCollision(t){const e=U_.SolveCollision_s_aabb,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=e;n.lowerBound.x=+Bh,n.lowerBound.y=+Bh,n.upperBound.x=-Bh,n.upperBound.y=-Bh;for(let e=0;e<this.m_count;e++){const r=s[e],o=i[e],a=o.x+t.dt*r.x,l=o.y+t.dt*r.y;n.lowerBound.x=Uh(n.lowerBound.x,Uh(o.x,a)),n.lowerBound.y=Uh(n.lowerBound.y,Uh(o.y,l)),n.upperBound.x=Wh(n.upperBound.x,Wh(o.x,a)),n.upperBound.y=Wh(n.upperBound.y,Wh(o.y,l))}null===this.SolveCollision_callback&&(this.SolveCollision_callback=new id(this,t));const r=this.SolveCollision_callback;r.m_step=t,this.m_world.QueryAABB(r,n)}LimitVelocity(t){const e=this.m_velocityBuffer.data,i=this.GetCriticalVelocitySquared(t);for(let t=0;t<this.m_count;t++){const s=e[t],n=Yh.DotVV(s,s);n>i&&s.SelfMul(Xh(i/n))}}SolveGravity(t){const e=U_.SolveGravity_s_gravity,i=this.m_velocityBuffer.data,s=Yh.MulSV(t.dt*this.m_def.gravityScale,this.m_world.GetGravity(),e);for(let t=0;t<this.m_count;t++)i[t].SelfAdd(s)}SolveBarrier(t){const e=U_.SolveBarrier_s_aabb,i=U_.SolveBarrier_s_va,s=U_.SolveBarrier_s_vb,n=U_.SolveBarrier_s_pba,r=U_.SolveBarrier_s_vba,o=U_.SolveBarrier_s_vc,a=U_.SolveBarrier_s_pca,l=U_.SolveBarrier_s_vca,h=U_.SolveBarrier_s_qba,c=U_.SolveBarrier_s_qca,m=U_.SolveBarrier_s_dv,u=U_.SolveBarrier_s_f,_=this.m_positionBuffer.data,d=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++)0!=(this.m_flagsBuffer.data[t]&U_.k_barrierWallFlags)&&d[t].SetZero();const p=2.5*t.dt,f=this.GetParticleMass();for(let y=0;y<this.m_pairBuffer.count;y++){const g=this.m_pairBuffer.data[y];if(g.flags&p_.b2_barrierParticle){const y=g.indexA,x=g.indexB,v=_[y],S=_[x],w=e;Yh.MinV(v,S,w.lowerBound),Yh.MaxV(v,S,w.upperBound);const b=this.m_groupBuffer[y],C=this.m_groupBuffer[x],A=this.GetLinearVelocity(b,y,v,i),B=this.GetLinearVelocity(C,x,S,s),M=Yh.SubVV(S,v,n),V=Yh.SubVV(B,A,r),T=this.GetInsideBoundsEnumerator(w);let P;for(;(P=T.GetNext())>=0;){const e=_[P],i=this.m_groupBuffer[P];if(b!==i&&C!==i){const s=this.GetLinearVelocity(i,P,e,o),n=Yh.SubVV(e,v,a),r=Yh.SubVV(s,A,l),_=Yh.CrossVV(V,r),y=Yh.CrossVV(M,r)-Yh.CrossVV(n,V),g=Yh.CrossVV(M,n);let x,S;const w=h,b=c;if(0===_){if(0===y)continue;if(S=-g/y,!(S>=0&&S<p))continue;if(Yh.AddVMulSV(M,S,V,w),Yh.AddVMulSV(n,S,r,b),x=Yh.DotVV(w,b)/Yh.DotVV(w,w),!(x>=0&&x<=1))continue}else{const t=y*y-4*g*_;if(t<0)continue;const e=Xh(t);let i=(-y-e)/(2*_),s=(-y+e)/(2*_);if(i>s){const t=i;i=s,s=t}if(S=i,Yh.AddVMulSV(M,S,V,w),Yh.AddVMulSV(n,S,r,b),x=Yh.DotVV(w,b)/Yh.DotVV(w,w),!(S>=0&&S<p&&x>=0&&x<=1)){if(S=s,!(S>=0&&S<p))continue;if(Yh.AddVMulSV(M,S,V,w),Yh.AddVMulSV(n,S,r,b),x=Yh.DotVV(w,b)/Yh.DotVV(w,w),!(x>=0&&x<=1))continue}}const C=m;C.x=A.x+x*V.x-s.x,C.y=A.y+x*V.y-s.y;const B=Yh.MulSV(f,C,u);if(i&&this.IsRigidGroup(i)){const t=i.GetMass(),s=i.GetInertia();t>0&&i.m_linearVelocity.SelfMulAdd(1/t,B),s>0&&(i.m_angularVelocity+=Yh.CrossVV(Yh.SubVV(e,i.GetCenter(),Yh.s_t0),B)/s)}else d[P].SelfAdd(C);this.ParticleApplyForce(P,B.SelfMul(-t.inv_dt))}}}}}SolveStaticPressure(t){this.m_staticPressureBuffer=this.RequestBuffer(this.m_staticPressureBuffer);const e=this.GetCriticalPressure(t),i=this.m_def.staticPressureStrength*e,s=.25*e,n=this.m_def.staticPressureRelaxation;for(let t=0;t<this.m_def.staticPressureIterations;t++){for(let t=0;t<this.m_count;t++)this.m_accumulationBuffer[t]=0;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&p_.b2_staticPressureParticle){const t=e.indexA,i=e.indexB,s=e.weight;this.m_accumulationBuffer[t]+=s*this.m_staticPressureBuffer[i],this.m_accumulationBuffer[i]+=s*this.m_staticPressureBuffer[t]}}for(let t=0;t<this.m_count;t++){const e=this.m_weightBuffer[t];if(this.m_flagsBuffer.data[t]&p_.b2_staticPressureParticle){const r=(this.m_accumulationBuffer[t]+i*(e-1))/(e+n);this.m_staticPressureBuffer[t]=jh(r,0,s)}else this.m_staticPressureBuffer[t]=0}}}ComputeWeight(){for(let t=0;t<this.m_count;t++)this.m_weightBuffer[t]=0;for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t],i=e.index,s=e.weight;this.m_weightBuffer[i]+=s}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t],i=e.indexA,s=e.indexB,n=e.weight;this.m_weightBuffer[i]+=n,this.m_weightBuffer[s]+=n}}SolvePressure(t){const e=U_.SolvePressure_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.GetCriticalPressure(t),r=this.m_def.pressureStrength*n,o=.25*n;for(let t=0;t<this.m_count;t++){const e=r*Wh(0,this.m_weightBuffer[t]-1);this.m_accumulationBuffer[t]=Uh(e,o)}if(this.m_allParticleFlags&U_.k_noPressureFlags)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&U_.k_noPressureFlags&&(this.m_accumulationBuffer[t]=0);if(this.m_allParticleFlags&p_.b2_staticPressureParticle)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&p_.b2_staticPressureParticle&&(this.m_accumulationBuffer[t]+=this.m_staticPressureBuffer[t]);const a=t.dt/(this.m_def.density*this.m_particleDiameter),l=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const n=this.m_bodyContactBuffer.data[t],o=n.index,h=n.body,c=n.weight,m=n.mass,u=n.normal,_=i[o],d=this.m_accumulationBuffer[o]+r*c,p=Yh.MulSV(a*c*m*d,u,e);s[o].SelfMulSub(l,p),h.ApplyLinearImpulse(p,_,!0)}for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t],n=i.indexA,r=i.indexB,o=i.weight,l=i.normal,h=this.m_accumulationBuffer[n]+this.m_accumulationBuffer[r],c=Yh.MulSV(a*o*h,l,e);s[n].SelfSub(c),s[r].SelfAdd(c)}}SolveDamping(t){const e=U_.SolveDamping_s_v,i=U_.SolveDamping_s_f,s=this.m_positionBuffer.data,n=this.m_velocityBuffer.data,r=this.m_def.dampingStrength,o=1/this.GetCriticalVelocity(t),a=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const l=this.m_bodyContactBuffer.data[t],h=l.index,c=l.body,m=l.weight,u=l.mass,_=l.normal,d=s[h],p=Yh.SubVV(c.GetLinearVelocityFromWorldPoint(d,Yh.s_t0),n[h],e),f=Yh.DotVV(p,_);if(f<0){const t=Wh(r*m,Uh(-o*f,.5)),e=Yh.MulSV(t*u*f,_,i);n[h].SelfMulAdd(a,e),c.ApplyLinearImpulse(e.SelfNeg(),d,!0)}}for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t],a=s.indexA,l=s.indexB,h=s.weight,c=s.normal,m=Yh.SubVV(n[l],n[a],e),u=Yh.DotVV(m,c);if(u<0){const t=Wh(r*h,Uh(-o*u,.5)),e=Yh.MulSV(t*u,c,i);n[a].SelfAdd(e),n[l].SelfSub(e)}}}SolveRigidDamping(){const t=U_.SolveRigidDamping_s_t0,e=U_.SolveRigidDamping_s_t1,i=U_.SolveRigidDamping_s_p,s=U_.SolveRigidDamping_s_v,n=[0],r=[0],o=[0],a=[0],l=[0],h=[0],c=this.m_positionBuffer.data,m=this.m_def.dampingStrength;for(let i=0;i<this.m_bodyContactBuffer.count;i++){const u=this.m_bodyContactBuffer.data[i],_=u.index,d=this.m_groupBuffer[_];if(d&&this.IsRigidGroup(d)){const i=u.body,p=u.normal,f=u.weight,y=c[_],g=Yh.SubVV(i.GetLinearVelocityFromWorldPoint(y,t),d.GetLinearVelocityFromWorldPoint(y,e),s),x=Yh.DotVV(g,p);if(x<0){this.InitDampingParameterWithRigidGroupOrParticle(n,r,o,!0,d,_,y,p),this.InitDampingParameter(a,l,h,i.GetMass(),i.GetInertia()-i.GetMass()*i.GetLocalCenter().LengthSquared(),i.GetWorldCenter(),y,p);const t=m*Uh(f,1)*this.ComputeDampingImpulse(n[0],r[0],o[0],a[0],l[0],h[0],x);this.ApplyDamping(n[0],r[0],o[0],!0,d,_,t,p),i.ApplyLinearImpulse(Yh.MulSV(-t,p,Yh.s_t0),y,!0)}}}for(let u=0;u<this.m_contactBuffer.count;u++){const _=this.m_contactBuffer.data[u],d=_.indexA,p=_.indexB,f=_.normal,y=_.weight,g=this.m_groupBuffer[d],x=this.m_groupBuffer[p],v=this.IsRigidGroup(g),S=this.IsRigidGroup(x);if(g!==x&&(v||S)){const u=Yh.MidVV(c[d],c[p],i),_=Yh.SubVV(this.GetLinearVelocity(x,p,u,t),this.GetLinearVelocity(g,d,u,e),s),w=Yh.DotVV(_,f);if(w<0){this.InitDampingParameterWithRigidGroupOrParticle(n,r,o,v,g,d,u,f),this.InitDampingParameterWithRigidGroupOrParticle(a,l,h,S,x,p,u,f);const t=m*y*this.ComputeDampingImpulse(n[0],r[0],o[0],a[0],l[0],h[0],w);this.ApplyDamping(n[0],r[0],o[0],v,g,d,t,f),this.ApplyDamping(a[0],l[0],h[0],S,x,p,-t,f)}}}}SolveExtraDamping(){const t=U_.SolveExtraDamping_s_v,e=U_.SolveExtraDamping_s_f,i=this.m_velocityBuffer.data,s=this.m_positionBuffer.data,n=this.GetParticleInvMass();for(let r=0;r<this.m_bodyContactBuffer.count;r++){const o=this.m_bodyContactBuffer.data[r],a=o.index;if(this.m_flagsBuffer.data[a]&U_.k_extraDampingFlags){const r=o.body,l=o.mass,h=o.normal,c=s[a],m=Yh.SubVV(r.GetLinearVelocityFromWorldPoint(c,Yh.s_t0),i[a],t),u=Yh.DotVV(m,h);if(u<0){const t=Yh.MulSV(.5*l*u,h,e);i[a].SelfMulAdd(n,t),r.ApplyLinearImpulse(t.SelfNeg(),c,!0)}}}}SolveWall(){const t=this.m_velocityBuffer.data;for(let e=0;e<this.m_count;e++)this.m_flagsBuffer.data[e]&p_.b2_wallParticle&&t[e].SetZero()}SolveRigid(t){const e=U_.SolveRigid_s_position,i=U_.SolveRigid_s_rotation,s=U_.SolveRigid_s_transform,n=U_.SolveRigid_s_velocityTransform,r=this.m_positionBuffer.data,o=this.m_velocityBuffer.data;for(let a=this.m_groupList;a;a=a.GetNext())if(a.m_groupFlags&f_.b2_rigidParticleGroup){a.UpdateStatistics();const l=i;l.SetAngle(t.dt*a.m_angularVelocity);const h=Yh.AddVV(a.m_center,Yh.SubVV(Yh.MulSV(t.dt,a.m_linearVelocity,Yh.s_t0),ec.MulRV(l,a.m_center,Yh.s_t1),Yh.s_t0),e),c=s;c.SetPositionRotation(h,l),ic.MulXX(c,a.m_transform,a.m_transform);const m=n;m.p.x=t.inv_dt*c.p.x,m.p.y=t.inv_dt*c.p.y,m.q.s=t.inv_dt*c.q.s,m.q.c=t.inv_dt*(c.q.c-1);for(let t=a.m_firstIndex;t<a.m_lastIndex;t++)ic.MulXV(m,r[t],o[t])}}SolveElastic(t){const e=U_.SolveElastic_s_pa,i=U_.SolveElastic_s_pb,s=U_.SolveElastic_s_pc,n=U_.SolveElastic_s_r,r=U_.SolveElastic_s_t0,o=this.m_positionBuffer.data,a=this.m_velocityBuffer.data,l=t.inv_dt*this.m_def.elasticStrength;for(let h=0;h<this.m_triadBuffer.count;h++){const c=this.m_triadBuffer.data[h];if(c.flags&p_.b2_elasticParticle){const h=c.indexA,m=c.indexB,u=c.indexC,_=c.pa,d=c.pb,p=c.pc,f=e.Copy(o[h]),y=i.Copy(o[m]),g=s.Copy(o[u]),x=a[h],v=a[m],S=a[u];f.SelfMulAdd(t.dt,x),y.SelfMulAdd(t.dt,v),g.SelfMulAdd(t.dt,S);const w=(f.x+y.x+g.x)/3,b=(f.y+y.y+g.y)/3;f.x-=w,f.y-=b,y.x-=w,y.y-=b,g.x-=w,g.y-=b;const C=n;C.s=Yh.CrossVV(_,f)+Yh.CrossVV(d,y)+Yh.CrossVV(p,g),C.c=Yh.DotVV(_,f)+Yh.DotVV(d,y)+Yh.DotVV(p,g);let A=qh(C.s*C.s+C.c*C.c);isFinite(A)||(A=198177537e11),C.s*=A,C.c*=A;const B=l*c.strength;ec.MulRV(C,_,r),Yh.SubVV(r,f,r),Yh.MulSV(B,r,r),x.SelfAdd(r),ec.MulRV(C,d,r),Yh.SubVV(r,y,r),Yh.MulSV(B,r,r),v.SelfAdd(r),ec.MulRV(C,p,r),Yh.SubVV(r,g,r),Yh.MulSV(B,r,r),S.SelfAdd(r)}}}SolveSpring(t){const e=U_.SolveSpring_s_pa,i=U_.SolveSpring_s_pb,s=U_.SolveSpring_s_d,n=U_.SolveSpring_s_f,r=this.m_positionBuffer.data,o=this.m_velocityBuffer.data,a=t.inv_dt*this.m_def.springStrength;for(let l=0;l<this.m_pairBuffer.count;l++){const h=this.m_pairBuffer.data[l];if(h.flags&p_.b2_springParticle){const l=h.indexA,c=h.indexB,m=e.Copy(r[l]),u=i.Copy(r[c]),_=o[l],d=o[c];m.SelfMulAdd(t.dt,_),u.SelfMulAdd(t.dt,d);const p=Yh.SubVV(u,m,s),f=h.distance,y=p.Length(),g=a*h.strength,x=Yh.MulSV(g*(f-y)/y,p,n);_.SelfSub(x),d.SelfAdd(x)}}}SolveTensile(t){const e=U_.SolveTensile_s_weightedNormal,i=U_.SolveTensile_s_s,s=U_.SolveTensile_s_f,n=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++)this.m_accumulation2Buffer[t]=new Yh,this.m_accumulation2Buffer[t].SetZero();for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];if(i.flags&p_.b2_tensileParticle){const t=i.indexA,s=i.indexB,n=i.weight,r=i.normal,o=Yh.MulSV((1-n)*n,r,e);this.m_accumulation2Buffer[t].SelfSub(o),this.m_accumulation2Buffer[s].SelfAdd(o)}}const r=this.GetCriticalVelocity(t),o=this.m_def.surfaceTensionPressureStrength*r,a=this.m_def.surfaceTensionNormalStrength*r,l=.5*r;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&p_.b2_tensileParticle){const t=e.indexA,r=e.indexB,h=e.weight,c=e.normal,m=this.m_weightBuffer[t]+this.m_weightBuffer[r],u=Yh.SubVV(this.m_accumulation2Buffer[r],this.m_accumulation2Buffer[t],i),_=Uh(o*(m-2)+a*Yh.DotVV(u,c),l)*h,d=Yh.MulSV(_,c,s);n[t].SelfSub(d),n[r].SelfAdd(d)}}}SolveViscous(){const t=U_.SolveViscous_s_v,e=U_.SolveViscous_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.m_def.viscousStrength,r=this.GetParticleInvMass();for(let o=0;o<this.m_bodyContactBuffer.count;o++){const a=this.m_bodyContactBuffer.data[o],l=a.index;if(this.m_flagsBuffer.data[l]&p_.b2_viscousParticle){const o=a.body,h=a.weight,c=a.mass,m=i[l],u=Yh.SubVV(o.GetLinearVelocityFromWorldPoint(m,Yh.s_t0),s[l],t),_=Yh.MulSV(n*c*h,u,e);s[l].SelfMulAdd(r,_),o.ApplyLinearImpulse(_.SelfNeg(),m,!0)}}for(let i=0;i<this.m_contactBuffer.count;i++){const r=this.m_contactBuffer.data[i];if(r.flags&p_.b2_viscousParticle){const i=r.indexA,o=r.indexB,a=r.weight,l=Yh.SubVV(s[o],s[i],t),h=Yh.MulSV(n*a,l,e);s[i].SelfAdd(h),s[o].SelfSub(h)}}}SolveRepulsive(t){const e=U_.SolveRepulsive_s_f,i=this.m_velocityBuffer.data,s=this.m_def.repulsiveStrength*this.GetCriticalVelocity(t);for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t];if(n.flags&p_.b2_repulsiveParticle){const t=n.indexA,r=n.indexB;if(this.m_groupBuffer[t]!==this.m_groupBuffer[r]){const o=n.weight,a=n.normal,l=Yh.MulSV(s*o,a,e);i[t].SelfSub(l),i[r].SelfAdd(l)}}}}SolvePowder(t){const e=U_.SolvePowder_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.m_def.powderStrength*this.GetCriticalVelocity(t),r=.25,o=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const a=this.m_bodyContactBuffer.data[t],l=a.index;if(this.m_flagsBuffer.data[l]&p_.b2_powderParticle){const t=a.weight;if(t>r){const h=a.body,c=a.mass,m=i[l],u=a.normal,_=Yh.MulSV(n*c*(t-r),u,e);s[l].SelfMulSub(o,_),h.ApplyLinearImpulse(_,m,!0)}}}for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];if(i.flags&p_.b2_powderParticle){const t=i.weight;if(t>r){const o=i.indexA,a=i.indexB,l=i.normal,h=Yh.MulSV(n*(t-r),l,e);s[o].SelfSub(h),s[a].SelfAdd(h)}}}}SolveSolid(t){const e=U_.SolveSolid_s_f,i=this.m_velocityBuffer.data;this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer);const s=t.inv_dt*this.m_def.ejectionStrength;for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t],r=n.indexA,o=n.indexB;if(this.m_groupBuffer[r]!==this.m_groupBuffer[o]){const t=n.weight,a=n.normal,l=this.m_depthBuffer[r]+this.m_depthBuffer[o],h=Yh.MulSV(s*l*t,a,e);i[r].SelfSub(h),i[o].SelfAdd(h)}}}SolveForce(t){const e=this.m_velocityBuffer.data,i=t.dt*this.GetParticleInvMass();for(let t=0;t<this.m_count;t++)e[t].SelfMulAdd(i,this.m_forceBuffer[t]);this.m_hasForce=!1}SolveColorMixing(){const t=.5*this.m_def.colorMixingStrength;if(t)for(let e=0;e<this.m_contactBuffer.count;e++){const i=this.m_contactBuffer.data[e],s=i.indexA,n=i.indexB;if(this.m_flagsBuffer.data[s]&this.m_flagsBuffer.data[n]&p_.b2_colorMixingParticle){const e=this.m_colorBuffer.data[s],i=this.m_colorBuffer.data[n];wh.MixColors(e,i,t)}}}SolveZombie(){let t=0;const e=[];for(let t=0;t<this.m_count;t++)e[t]=Gh;let i=0;for(let s=0;s<this.m_count;s++){const n=this.m_flagsBuffer.data[s];if(n&p_.b2_zombieParticle){const t=this.m_world.m_destructionListener;if(n&p_.b2_destructionListenerParticle&&t&&t.SayGoodbyeParticle(this,s),this.m_handleIndexBuffer.data){const t=this.m_handleIndexBuffer.data[s];t&&(t.SetIndex(Gh),this.m_handleIndexBuffer.data[s]=null)}e[s]=Gh}else{if(e[s]=t,s!==t){if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[s];e&&e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e}this.m_flagsBuffer.data[t]=this.m_flagsBuffer.data[s],this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[t]=this.m_lastBodyContactStepBuffer.data[s]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[t]=this.m_bodyContactCountBuffer.data[s]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[t]=this.m_consecutiveContactStepsBuffer.data[s]),this.m_positionBuffer.data[t].Copy(this.m_positionBuffer.data[s]),this.m_velocityBuffer.data[t].Copy(this.m_velocityBuffer.data[s]),this.m_groupBuffer[t]=this.m_groupBuffer[s],this.m_hasForce&&this.m_forceBuffer[t].Copy(this.m_forceBuffer[s]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[t]=this.m_staticPressureBuffer[s]),this.m_depthBuffer&&(this.m_depthBuffer[t]=this.m_depthBuffer[s]),this.m_colorBuffer.data&&this.m_colorBuffer.data[t].Copy(this.m_colorBuffer.data[s]),this.m_userDataBuffer.data&&(this.m_userDataBuffer.data[t]=this.m_userDataBuffer.data[s]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[t]=this.m_expirationTimeBuffer.data[s])}t++,i|=n}}for(let t=0;t<this.m_proxyBuffer.count;t++){const i=this.m_proxyBuffer.data[t];i.index=e[i.index]}this.m_proxyBuffer.RemoveIf((t=>t.index<0));for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB]}this.m_contactBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0));for(let t=0;t<this.m_bodyContactBuffer.count;t++){const i=this.m_bodyContactBuffer.data[t];i.index=e[i.index]}this.m_bodyContactBuffer.RemoveIf((t=>t.index<0));for(let t=0;t<this.m_pairBuffer.count;t++){const i=this.m_pairBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB]}this.m_pairBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0));for(let t=0;t<this.m_triadBuffer.count;t++){const i=this.m_triadBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB],i.indexC=e[i.indexC]}if(this.m_triadBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0||t.indexC<0)),this.m_indexByExpirationTimeBuffer.data){let t=0;for(let i=0;i<this.m_count;i++){const s=e[this.m_indexByExpirationTimeBuffer.data[i]];s!==Gh&&(this.m_indexByExpirationTimeBuffer.data[t++]=s)}}for(let i=this.m_groupList;i;i=i.GetNext()){let s=t,n=0,r=!1;for(let t=i.m_firstIndex;t<i.m_lastIndex;t++){const i=e[t];i>=0?(s=Uh(s,i),n=Wh(n,i+1)):r=!0}s<n?(i.m_firstIndex=s,i.m_lastIndex=n,r&&i.m_groupFlags&f_.b2_solidParticleGroup&&this.SetGroupFlags(i,i.m_groupFlags|f_.b2_particleGroupNeedsUpdateDepth)):(i.m_firstIndex=0,i.m_lastIndex=0,i.m_groupFlags&f_.b2_particleGroupCanBeEmpty||this.SetGroupFlags(i,i.m_groupFlags|f_.b2_particleGroupWillBeDestroyed))}this.m_count=t,this.m_allParticleFlags=i,this.m_needsUpdateAllParticleFlags=!1;for(let t=this.m_groupList;t;){const e=t.GetNext();t.m_groupFlags&f_.b2_particleGroupWillBeDestroyed&&this.DestroyParticleGroup(t),t=e}}SolveLifetimes(t){this.m_timeElapsed=this.LifetimeToExpirationTime(t.dt);const e=this.GetQuantizedTimeElapsed(),i=this.m_expirationTimeBuffer.data,s=this.m_indexByExpirationTimeBuffer.data,n=this.GetParticleCount();this.m_expirationTimeBufferRequiresSorting&&(T_(s,0,n,((t,e)=>{const s=i[t],n=i[e],r=s<=0;return r===n<=0?s>n:r})),this.m_expirationTimeBufferRequiresSorting=!1);for(let t=n-1;t>=0;--t){const n=s[t],r=i[n];if(e<r||r<=0)break;this.DestroyParticle(n)}}RotateBuffer(t,e,i){if(t!==e&&e!==i){if(R_(this.m_flagsBuffer.data,t,e,i),this.m_lastBodyContactStepBuffer.data&&R_(this.m_lastBodyContactStepBuffer.data,t,e,i),this.m_bodyContactCountBuffer.data&&R_(this.m_bodyContactCountBuffer.data,t,e,i),this.m_consecutiveContactStepsBuffer.data&&R_(this.m_consecutiveContactStepsBuffer.data,t,e,i),R_(this.m_positionBuffer.data,t,e,i),R_(this.m_velocityBuffer.data,t,e,i),R_(this.m_groupBuffer,t,e,i),this.m_hasForce&&R_(this.m_forceBuffer,t,e,i),this.m_staticPressureBuffer&&R_(this.m_staticPressureBuffer,t,e,i),this.m_depthBuffer&&R_(this.m_depthBuffer,t,e,i),this.m_colorBuffer.data&&R_(this.m_colorBuffer.data,t,e,i),this.m_userDataBuffer.data&&R_(this.m_userDataBuffer.data,t,e,i),this.m_handleIndexBuffer.data){R_(this.m_handleIndexBuffer.data,t,e,i);for(let e=t;e<i;++e){const t=this.m_handleIndexBuffer.data[e];t&&t.SetIndex(s(t.GetIndex()))}}if(this.m_expirationTimeBuffer.data){R_(this.m_expirationTimeBuffer.data,t,e,i);const n=this.GetParticleCount(),r=this.m_indexByExpirationTimeBuffer.data;for(let t=0;t<n;++t)r[t]=s(r[t])}for(let t=0;t<this.m_proxyBuffer.count;t++){const e=this.m_proxyBuffer.data[t];e.index=s(e.index)}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB)}for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t];e.index=s(e.index)}for(let t=0;t<this.m_pairBuffer.count;t++){const e=this.m_pairBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB)}for(let t=0;t<this.m_triadBuffer.count;t++){const e=this.m_triadBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB),e.indexC=s(e.indexC)}for(let t=this.m_groupList;t;t=t.GetNext())t.m_firstIndex=s(t.m_firstIndex),t.m_lastIndex=s(t.m_lastIndex-1)+1}function s(s){return s<t?s:s<e?s+i-e:s<i?s+t-e:s}}GetCriticalVelocity(t){return this.m_particleDiameter*t.inv_dt}GetCriticalVelocitySquared(t){const e=this.GetCriticalVelocity(t);return e*e}GetCriticalPressure(t){return this.m_def.density*this.GetCriticalVelocitySquared(t)}GetParticleStride(){return.75*this.m_particleDiameter}GetParticleMass(){const t=this.GetParticleStride();return this.m_def.density*t*t}GetParticleInvMass(){const t=1.3333333333333333*this.m_inverseDiameter;return this.m_inverseDensity*t*t}GetFixtureContactFilter(){return this.m_allParticleFlags&p_.b2_fixtureContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetParticleContactFilter(){return this.m_allParticleFlags&p_.b2_particleContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetFixtureContactListener(){return this.m_allParticleFlags&p_.b2_fixtureContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}GetParticleContactListener(){return this.m_allParticleFlags&p_.b2_particleContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}SetUserOverridableBuffer(t,e){t.data=e,t.userSuppliedCapacity=e.length}SetGroupFlags(t,e){const i=t.m_groupFlags;(i^e)&f_.b2_solidParticleGroup&&(e|=f_.b2_particleGroupNeedsUpdateDepth),i&~e&&(this.m_needsUpdateAllGroupFlags=!0),~this.m_allGroupFlags&e&&(e&f_.b2_solidParticleGroup&&(this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer)),this.m_allGroupFlags|=e),t.m_groupFlags=e}static BodyContactCompare(t,e){return t.index===e.index?t.weight>e.weight:t.index<e.index}RemoveSpuriousBodyContacts(){T_(this.m_bodyContactBuffer.data,0,this.m_bodyContactBuffer.count,U_.BodyContactCompare);const t=U_.RemoveSpuriousBodyContacts_s_n,e=U_.RemoveSpuriousBodyContacts_s_pos,i=U_.RemoveSpuriousBodyContacts_s_normal,s=this;let n=-1,r=0;this.m_bodyContactBuffer.count=D_(this.m_bodyContactBuffer.data,(o=>{if(o.index!==n&&(r=0,n=o.index),r++>3)return!0;const a=t.Copy(o.normal);a.SelfMul(s.m_particleDiameter*(1-o.weight));const l=Yh.AddVV(s.m_positionBuffer.data[o.index],a,e);if(!o.fixture.TestPoint(l)){const t=o.fixture.GetShape().GetChildCount();for(let e=0;e<t;e++){const t=i;if(o.fixture.ComputeDistance(l,t,e)<Ph)return!1}return!0}return!1}),this.m_bodyContactBuffer.count)}DetectStuckParticle(t){this.m_stuckThreshold<=0||(++this.m_bodyContactCountBuffer.data[t],2===this.m_bodyContactCountBuffer.data[t]&&(++this.m_consecutiveContactStepsBuffer.data[t],this.m_consecutiveContactStepsBuffer.data[t]>this.m_stuckThreshold&&(this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()]=t)),this.m_lastBodyContactStepBuffer.data[t]=this.m_timestamp)}ValidateParticleIndex(t){return t>=0&&t<this.GetParticleCount()&&t!==Gh}GetQuantizedTimeElapsed(){return Math.floor(this.m_timeElapsed/4294967296)}LifetimeToExpirationTime(t){return this.m_timeElapsed+Math.floor(t/this.m_def.lifetimeGranularity*4294967296)}ForceCanBeApplied(t){return!(t&p_.b2_wallParticle)}PrepareForceBuffer(){if(!this.m_hasForce){for(let t=0;t<this.m_count;t++)this.m_forceBuffer[t].SetZero();this.m_hasForce=!0}}IsRigidGroup(t){return null!==t&&0!=(t.m_groupFlags&f_.b2_rigidParticleGroup)}GetLinearVelocity(t,e,i,s){return t&&this.IsRigidGroup(t)?t.GetLinearVelocityFromWorldPoint(i,s):s.Copy(this.m_velocityBuffer.data[e])}InitDampingParameter(t,e,i,s,n,r,o,a){t[0]=s>0?1/s:0,e[0]=n>0?1/n:0,i[0]=Yh.CrossVV(Yh.SubVV(o,r,Yh.s_t0),a)}InitDampingParameterWithRigidGroupOrParticle(t,e,i,s,n,r,o,a){if(n&&s)this.InitDampingParameter(t,e,i,n.GetMass(),n.GetInertia(),n.GetCenter(),o,a);else{const s=this.m_flagsBuffer.data[r];this.InitDampingParameter(t,e,i,s&p_.b2_wallParticle?0:this.GetParticleMass(),0,o,o,a)}}ComputeDampingImpulse(t,e,i,s,n,r,o){const a=t+e*i*i+s+n*r*r;return a>0?o/a:0}ApplyDamping(t,e,i,s,n,r,o,a){n&&s?(n.m_linearVelocity.SelfMulAdd(o*t,a),n.m_angularVelocity+=o*i*e):this.m_velocityBuffer.data[r].SelfMulAdd(o*t,a)}}U_.xTruncBits=12,U_.yTruncBits=12,U_.tagBits=32,U_.yOffset=1<<U_.yTruncBits-1,U_.yShift=U_.tagBits-U_.yTruncBits,U_.xShift=U_.tagBits-U_.yTruncBits-U_.xTruncBits,U_.xScale=1<<U_.xShift,U_.xOffset=U_.xScale*(1<<U_.xTruncBits-1),U_.yMask=(1<<U_.yTruncBits)-1<<U_.yShift,U_.xMask=~U_.yMask,U_.DestroyParticlesInShape_s_aabb=new Dc,U_.CreateParticleGroup_s_transform=new ic,U_.ComputeCollisionEnergy_s_v=new Yh,U_.QueryShapeAABB_s_aabb=new Dc,U_.QueryPointAABB_s_aabb=new Dc,U_.RayCast_s_aabb=new Dc,U_.RayCast_s_p=new Yh,U_.RayCast_s_v=new Yh,U_.RayCast_s_n=new Yh,U_.RayCast_s_point=new Yh,U_.k_pairFlags=p_.b2_springParticle,U_.k_triadFlags=p_.b2_elasticParticle,U_.k_noPressureFlags=p_.b2_powderParticle|p_.b2_tensileParticle,U_.k_extraDampingFlags=p_.b2_staticPressureParticle,U_.k_barrierWallFlags=p_.b2_barrierParticle|p_.b2_wallParticle,U_.CreateParticlesStrokeShapeForGroup_s_edge=new qc,U_.CreateParticlesStrokeShapeForGroup_s_d=new Yh,U_.CreateParticlesStrokeShapeForGroup_s_p=new Yh,U_.CreateParticlesFillShapeForGroup_s_aabb=new Dc,U_.CreateParticlesFillShapeForGroup_s_p=new Yh,U_.UpdatePairsAndTriads_s_dab=new Yh,U_.UpdatePairsAndTriads_s_dbc=new Yh,U_.UpdatePairsAndTriads_s_dca=new Yh,U_.AddContact_s_d=new Yh,U_.UpdateBodyContacts_s_aabb=new Dc,U_.Solve_s_subStep=new Qu,U_.SolveCollision_s_aabb=new Dc,U_.SolveGravity_s_gravity=new Yh,U_.SolveBarrier_s_aabb=new Dc,U_.SolveBarrier_s_va=new Yh,U_.SolveBarrier_s_vb=new Yh,U_.SolveBarrier_s_pba=new Yh,U_.SolveBarrier_s_vba=new Yh,U_.SolveBarrier_s_vc=new Yh,U_.SolveBarrier_s_pca=new Yh,U_.SolveBarrier_s_vca=new Yh,U_.SolveBarrier_s_qba=new Yh,U_.SolveBarrier_s_qca=new Yh,U_.SolveBarrier_s_dv=new Yh,U_.SolveBarrier_s_f=new Yh,U_.SolvePressure_s_f=new Yh,U_.SolveDamping_s_v=new Yh,U_.SolveDamping_s_f=new Yh,U_.SolveRigidDamping_s_t0=new Yh,U_.SolveRigidDamping_s_t1=new Yh,U_.SolveRigidDamping_s_p=new Yh,U_.SolveRigidDamping_s_v=new Yh,U_.SolveExtraDamping_s_v=new Yh,U_.SolveExtraDamping_s_f=new Yh,U_.SolveRigid_s_position=new Yh,U_.SolveRigid_s_rotation=new ec,U_.SolveRigid_s_transform=new ic,U_.SolveRigid_s_velocityTransform=new ic,U_.SolveElastic_s_pa=new Yh,U_.SolveElastic_s_pb=new Yh,U_.SolveElastic_s_pc=new Yh,U_.SolveElastic_s_r=new ec,U_.SolveElastic_s_t0=new Yh,U_.SolveSpring_s_pa=new Yh,U_.SolveSpring_s_pb=new Yh,U_.SolveSpring_s_d=new Yh,U_.SolveSpring_s_f=new Yh,U_.SolveTensile_s_weightedNormal=new Yh,U_.SolveTensile_s_s=new Yh,U_.SolveTensile_s_f=new Yh,U_.SolveViscous_s_v=new Yh,U_.SolveViscous_s_f=new Yh,U_.SolveRepulsive_s_f=new Yh,U_.SolvePowder_s_f=new Yh,U_.SolveSolid_s_f=new Yh,U_.RemoveSpuriousBodyContacts_s_n=new Yh,U_.RemoveSpuriousBodyContacts_s_pos=new Yh,U_.RemoveSpuriousBodyContacts_s_normal=new Yh;class W_{constructor(){this._data=null,this.userSuppliedCapacity=0}get data(){return this._data}set data(t){this._data=t}}class j_{constructor(){this.index=Gh,this.tag=0}static CompareProxyProxy(t,e){return t.tag<e.tag}static CompareTagProxy(t,e){return t<e.tag}static CompareProxyTag(t,e){return t.tag<e}}class H_{constructor(t,e,i,s,n){this.m_system=t,this.m_xLower=(e&U_.xMask)>>>0,this.m_xUpper=(i&U_.xMask)>>>0,this.m_yLower=(e&U_.yMask)>>>0,this.m_yUpper=(i&U_.yMask)>>>0,this.m_first=s,this.m_last=n}GetNext(){for(;this.m_first<this.m_last;){const t=(this.m_system.m_proxyBuffer.data[this.m_first].tag&U_.xMask)>>>0;if(t>=this.m_xLower&&t<=this.m_xUpper)return this.m_system.m_proxyBuffer.data[this.m_first++].index;this.m_first++}return Gh}}class q_{constructor(){this.next=null,this.count=0,this.index=0}}class X_{Allocate(t,e){return e}Clear(){}GetCount(){return 0}Invalidate(t){}GetValidBuffer(){return[]}GetBuffer(){return[]}SetCount(t){}}class J_ extends X_{Initialize(t,e){}Find(t){return Gh}}class Z_ extends X_{Initialize(t,e){}Find(t){return Gh}}class Y_{IsNecessary(t){return!0}ShouldCreatePair(t,e){return!0}ShouldCreateTriad(t,e,i){return!0}}class Q_ extends Ju{constructor(t,e,i,s){super(),this.m_callDestructionListener=!1,this.m_destroyed=0,this.m_system=t,this.m_shape=e,this.m_xf=i,this.m_callDestructionListener=s,this.m_destroyed=0}ReportFixture(t){return!1}ReportParticle(t,e){return t===this.m_system&&(this.m_shape.TestPoint(this.m_xf,this.m_system.m_positionBuffer.data[e])&&(this.m_system.DestroyParticle(e,this.m_callDestructionListener),this.m_destroyed++),!0)}Destroyed(){return this.m_destroyed}}class K_ extends Y_{constructor(t){super(),this.m_threshold=0,this.m_threshold=t}ShouldCreatePair(t,e){return t<this.m_threshold&&this.m_threshold<=e||e<this.m_threshold&&this.m_threshold<=t}ShouldCreateTriad(t,e,i){return(t<this.m_threshold||e<this.m_threshold||i<this.m_threshold)&&(this.m_threshold<=t||this.m_threshold<=e||this.m_threshold<=i)}}class $_ extends Hc{constructor(t,e=t.length){super(jc.e_unknown,0),this.m_shapeCount=0,this.m_shapes=t,this.m_shapeCount=e}Clone(){throw new Error}GetChildCount(){return 1}TestPoint(t,e){for(let i=0;i<this.m_shapeCount;i++)if(this.m_shapes[i].TestPoint(t,e))return!0;return!1}ComputeDistance(t,e,i,s){return 0}RayCast(t,e,i,s){return!1}ComputeAABB(t,e,i){const s=new Dc;t.lowerBound.x=+Bh,t.lowerBound.y=+Bh,t.upperBound.x=-Bh,t.upperBound.y=-Bh;for(let i=0;i<this.m_shapeCount;i++){const n=this.m_shapes[i].GetChildCount();for(let r=0;r<n;r++){const n=s;this.m_shapes[i].ComputeAABB(n,e,r),t.Combine1(n)}}}ComputeMass(t,e){}SetupDistanceProxy(t,e){}ComputeSubmergedArea(t,e,i,s){return 0}Dump(t){}}class td extends Y_{constructor(t){super(),this.m_flagsBuffer=t}IsNecessary(t){return 0!=(this.m_flagsBuffer.data[t]&p_.b2_reactiveParticle)}}class ed extends G_{constructor(t,e=null){super(t),this.m_contactFilter=null,this.m_contactFilter=e}ShouldCollideFixtureParticle(t,e,i){return!(this.m_contactFilter&&this.m_system.GetFlagsBuffer()[i]&p_.b2_fixtureContactFilterParticle)||this.m_contactFilter.ShouldCollideFixtureParticle(t,this.m_system,i)}ReportFixtureAndParticle(t,e,i){const s=ed.ReportFixtureAndParticle_s_n,n=ed.ReportFixtureAndParticle_s_rp,r=this.m_system.m_positionBuffer.data[i],o=s,a=t.ComputeDistance(r,o,e);if(a<this.m_system.m_particleDiameter&&this.ShouldCollideFixtureParticle(t,this.m_system,i)){const e=t.GetBody(),s=e.GetWorldCenter(),l=e.GetMass(),h=e.GetInertia()-l*e.GetLocalCenter().LengthSquared(),c=l>0?1/l:0,m=h>0?1/h:0,u=this.m_system.m_flagsBuffer.data[i]&p_.b2_wallParticle?0:this.m_system.GetParticleInvMass(),_=Yh.SubVV(r,s,n),d=Yh.CrossVV(_,o),p=u+c+m*d*d,f=this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];f.index=i,f.body=e,f.fixture=t,f.weight=1-a*this.m_system.m_inverseDiameter,f.normal.Copy(o.SelfNeg()),f.mass=p>0?1/p:0,this.m_system.DetectStuckParticle(i)}}}ed.ReportFixtureAndParticle_s_n=new Yh,ed.ReportFixtureAndParticle_s_rp=new Yh;class id extends G_{constructor(t,e){super(t),this.m_step=e}ReportFixtureAndParticle(t,e,i){const s=id.ReportFixtureAndParticle_s_p1,n=id.ReportFixtureAndParticle_s_output,r=id.ReportFixtureAndParticle_s_input,o=id.ReportFixtureAndParticle_s_p,a=id.ReportFixtureAndParticle_s_v,l=id.ReportFixtureAndParticle_s_f,h=t.GetBody(),c=this.m_system.m_positionBuffer.data[i],m=this.m_system.m_velocityBuffer.data[i],u=n,_=r;if(0===this.m_system.m_iterationIndex){const e=ic.MulTXV(h.m_xf0,c,s);t.GetShape().GetType()===jc.e_circleShape&&(e.SelfSub(h.GetLocalCenter()),ec.MulRV(h.m_xf0.q,e,e),ec.MulTRV(h.m_xf.q,e,e),e.SelfAdd(h.GetLocalCenter())),ic.MulXV(h.m_xf,e,_.p1)}else _.p1.Copy(c);if(Yh.AddVMulSV(c,this.m_step.dt,m,_.p2),_.maxFraction=1,t.RayCast(u,_,e)){const t=u.normal,e=o;e.x=(1-u.fraction)*_.p1.x+u.fraction*_.p2.x+Ph*t.x,e.y=(1-u.fraction)*_.p1.y+u.fraction*_.p2.y+Ph*t.y;const s=a;s.x=this.m_step.inv_dt*(e.x-c.x),s.y=this.m_step.inv_dt*(e.y-c.y),this.m_system.m_velocityBuffer.data[i].Copy(s);const n=l;n.x=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.x-s.x),n.y=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.y-s.y),this.m_system.ParticleApplyForce(i,n)}}ReportParticle(t,e){return!1}}id.ReportFixtureAndParticle_s_p1=new Yh,id.ReportFixtureAndParticle_s_output=new Pc,id.ReportFixtureAndParticle_s_input=new Tc,id.ReportFixtureAndParticle_s_p=new Yh,id.ReportFixtureAndParticle_s_v=new Yh,id.ReportFixtureAndParticle_s_f=new Yh;class sd{constructor(t){this.m_contactManager=new Zu,this.m_bodyList=null,this.m_jointList=null,this.m_particleSystemList=null,this.m_bodyCount=0,this.m_jointCount=0,this.m_gravity=new Yh,this.m_allowSleep=!0,this.m_destructionListener=null,this.m_debugDraw=null,this.m_inv_dt0=0,this.m_newContacts=!1,this.m_locked=!1,this.m_clearForces=!0,this.m_warmStarting=!0,this.m_continuousPhysics=!0,this.m_subStepping=!1,this.m_stepComplete=!0,this.m_profile=new Yu,this.m_island=new a_,this.s_stack=[],this.m_controllerList=null,this.m_controllerCount=0,this.m_gravity.Copy(t)}SetDestructionListener(t){this.m_destructionListener=t}SetContactFilter(t){this.m_contactManager.m_contactFilter=t}SetContactListener(t){this.m_contactManager.m_contactListener=t}SetDebugDraw(t){this.m_debugDraw=t}CreateBody(t={}){if(this.IsLocked())throw new Error;const e=new Du(t,this);return e.m_prev=null,e.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=e),this.m_bodyList=e,++this.m_bodyCount,e}DestroyBody(t){if(this.IsLocked())throw new Error;let e=t.m_jointList;for(;e;){const i=e;e=e.next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeJoint(i.joint),this.DestroyJoint(i.joint),t.m_jointList=e}t.m_jointList=null;let i=t.m_controllerList;for(;i;){const e=i;i=i.nextController,e.controller.RemoveBody(t)}let s=t.m_contactList;for(;s;){const t=s;s=s.next,this.m_contactManager.Destroy(t.contact)}t.m_contactList=null;let n=t.m_fixtureList;for(;n;){const e=n;n=n.m_next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeFixture(e),e.DestroyProxies(),e.Reset(),t.m_fixtureList=n,t.m_fixtureCount-=1}t.m_fixtureList=null,t.m_fixtureCount=0,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_bodyList&&(this.m_bodyList=t.m_next),--this.m_bodyCount}static _Joint_Create(t){switch(t.type){case vu.e_distanceJoint:return new Bu(t);case vu.e_mouseJoint:return new h_(t);case vu.e_prismaticJoint:return new c_(t);case vu.e_revoluteJoint:return new u_(t);case vu.e_pulleyJoint:return new m_(t);case vu.e_gearJoint:return new o_(t);case vu.e_wheelJoint:return new d_(t);case vu.e_weldJoint:return new __(t);case vu.e_frictionJoint:return new r_(t);case vu.e_motorJoint:return new l_(t);case vu.e_areaJoint:return new Mu(t)}throw new Error}static _Joint_Destroy(t){}CreateJoint(t){if(this.IsLocked())throw new Error;const e=sd._Joint_Create(t);e.m_prev=null,e.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=e),this.m_jointList=e,++this.m_jointCount,e.m_edgeA.prev=null,e.m_edgeA.next=e.m_bodyA.m_jointList,e.m_bodyA.m_jointList&&(e.m_bodyA.m_jointList.prev=e.m_edgeA),e.m_bodyA.m_jointList=e.m_edgeA,e.m_edgeB.prev=null,e.m_edgeB.next=e.m_bodyB.m_jointList,e.m_bodyB.m_jointList&&(e.m_bodyB.m_jointList.prev=e.m_edgeB),e.m_bodyB.m_jointList=e.m_edgeB;const i=e.m_bodyA,s=e.m_bodyB;if(!e.m_collideConnected){let t=s.GetContactList();for(;t;)t.other===i&&t.contact.FlagForFiltering(),t=t.next}return e}DestroyJoint(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,i=t.m_bodyB,s=t.m_collideConnected;if(e.SetAwake(!0),i.SetAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA===e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.Reset(),t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB===i.m_jointList&&(i.m_jointList=t.m_edgeB.next),t.m_edgeB.Reset(),sd._Joint_Destroy(t),--this.m_jointCount,!s){let t=i.GetContactList();for(;t;)t.other===e&&t.contact.FlagForFiltering(),t=t.next}}CreateParticleSystem(t){if(this.IsLocked())throw new Error;const e=new U_(t,this);return e.m_prev=null,e.m_next=this.m_particleSystemList,this.m_particleSystemList&&(this.m_particleSystemList.m_prev=e),this.m_particleSystemList=e,e}DestroyParticleSystem(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_particleSystemList&&(this.m_particleSystemList=t.m_next)}CalculateReasonableParticleIterations(t){return null===this.m_particleSystemList?1:function(t,e,i){return jh(Math.ceil(Math.sqrt(t/(.01*e))*i),1,8)}(this.m_gravity.Length(),function(t){let e=Bh;for(let i=t.GetParticleSystemList();null!==i;i=i.m_next)e=Uh(e,i.GetRadius());return e}(this),t)}Step(t,e,i,s=this.CalculateReasonableParticleIterations(t)){const n=sd.Step_s_stepTimer.Reset();this.m_newContacts&&(this.m_contactManager.FindNewContacts(),this.m_newContacts=!1),this.m_locked=!0;const r=sd.Step_s_step;r.dt=t,r.velocityIterations=e,r.positionIterations=i,r.particleIterations=s,r.inv_dt=t>0?1/t:0,r.dtRatio=this.m_inv_dt0*t,r.warmStarting=this.m_warmStarting;const o=sd.Step_s_timer.Reset();if(this.m_contactManager.Collide(),this.m_profile.collide=o.GetMilliseconds(),this.m_stepComplete&&r.dt>0){const t=sd.Step_s_timer.Reset();for(let t=this.m_particleSystemList;t;t=t.m_next)t.Solve(r);this.Solve(r),this.m_profile.solve=t.GetMilliseconds()}if(this.m_continuousPhysics&&r.dt>0){const t=sd.Step_s_timer.Reset();this.SolveTOI(r),this.m_profile.solveTOI=t.GetMilliseconds()}r.dt>0&&(this.m_inv_dt0=r.inv_dt),this.m_clearForces&&this.ClearForces(),this.m_locked=!1,this.m_profile.step=n.GetMilliseconds()}ClearForces(){for(let t=this.m_bodyList;t;t=t.m_next)t.m_force.SetZero(),t.m_torque=0}DrawParticleSystem(t){if(null===this.m_debugDraw)return;const e=t.GetParticleCount();if(e){const i=t.GetRadius(),s=t.GetPositionBuffer();if(t.m_colorBuffer.data){const n=t.GetColorBuffer();this.m_debugDraw.DrawParticles(s,i,n,e)}else this.m_debugDraw.DrawParticles(s,i,null,e)}}DebugDraw(){if(null===this.m_debugDraw)return;const t=this.m_debugDraw.GetFlags(),e=sd.DebugDraw_s_color.SetRGB(0,0,0);if(t&Ch.e_shapeBit)for(let t=this.m_bodyList;t;t=t.m_next){const i=t.m_xf;this.m_debugDraw.PushTransform(i);for(let i=t.GetFixtureList();i;i=i.m_next)t.GetType()===Su.b2_dynamicBody&&0===t.m_mass?this.DrawShape(i,new wh(1,0,0)):t.IsEnabled()?t.GetType()===Su.b2_staticBody?(e.SetRGB(.5,.9,.5),this.DrawShape(i,e)):t.GetType()===Su.b2_kinematicBody?(e.SetRGB(.5,.5,.9),this.DrawShape(i,e)):t.IsAwake()?(e.SetRGB(.9,.7,.7),this.DrawShape(i,e)):(e.SetRGB(.6,.6,.6),this.DrawShape(i,e)):(e.SetRGB(.5,.5,.3),this.DrawShape(i,e));this.m_debugDraw.PopTransform(i)}if(t&Ch.e_particleBit)for(let t=this.m_particleSystemList;t;t=t.m_next)this.DrawParticleSystem(t);if(t&Ch.e_jointBit)for(let t=this.m_jointList;t;t=t.m_next)t.Draw(this.m_debugDraw);if(t&Ch.e_pairBit){e.SetRGB(.3,.9,.9);for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){const i=t.GetFixtureA(),s=t.GetFixtureB(),n=t.GetChildIndexA(),r=t.GetChildIndexB(),o=i.GetAABB(n).GetCenter(),a=s.GetAABB(r).GetCenter();this.m_debugDraw.DrawSegment(o,a,e)}}if(t&Ch.e_aabbBit){e.SetRGB(.9,.3,.9);const t=sd.DebugDraw_s_vs;for(let i=this.m_bodyList;i;i=i.m_next)if(i.IsEnabled())for(let s=i.GetFixtureList();s;s=s.m_next)for(let i=0;i<s.m_proxyCount;++i){const n=s.m_proxies[i].treeNode.aabb;t[0].Set(n.lowerBound.x,n.lowerBound.y),t[1].Set(n.upperBound.x,n.lowerBound.y),t[2].Set(n.upperBound.x,n.upperBound.y),t[3].Set(n.lowerBound.x,n.upperBound.y),this.m_debugDraw.DrawPolygon(t,4,e)}}if(t&Ch.e_centerOfMassBit)for(let t=this.m_bodyList;t;t=t.m_next){const e=sd.DebugDraw_s_xf;e.q.Copy(t.m_xf.q),e.p.Copy(t.GetWorldCenter()),this.m_debugDraw.DrawTransform(e)}if(t&Ch.e_controllerBit)for(let t=this.m_controllerList;t;t=t.m_next)t.Draw(this.m_debugDraw)}QueryAABB(...t){t[0]instanceof Ju?this._QueryAABB(t[0],t[1]):this._QueryAABB(null,t[0],t[1])}_QueryAABB(t,e,i){if(this.m_contactManager.m_broadPhase.Query(e,(e=>{const s=e.userData.fixture;return t?t.ReportFixture(s):!i||i(s)})),t instanceof Ju)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryAABB(t,e)}QueryAllAABB(t,e=[]){return this.QueryAABB(t,(t=>(e.push(t),!0))),e}QueryPointAABB(...t){t[0]instanceof Ju?this._QueryPointAABB(t[0],t[1]):this._QueryPointAABB(null,t[0],t[1])}_QueryPointAABB(t,e,i){if(this.m_contactManager.m_broadPhase.QueryPoint(e,(e=>{const s=e.userData.fixture;return t?t.ReportFixture(s):!i||i(s)})),t instanceof Ju)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryPointAABB(t,e)}QueryAllPointAABB(t,e=[]){return this.QueryPointAABB(t,(t=>(e.push(t),!0))),e}QueryFixtureShape(...t){t[0]instanceof Ju?this._QueryFixtureShape(t[0],t[1],t[2],t[3]):this._QueryFixtureShape(null,t[0],t[1],t[2],t[3])}_QueryFixtureShape(t,e,i,s,n){const r=sd.QueryFixtureShape_s_aabb;if(e.ComputeAABB(r,s,i),this.m_contactManager.m_broadPhase.Query(r,(r=>{const o=r.userData,a=o.fixture;if(Fc(e,i,a.GetShape(),o.childIndex,s,a.GetBody().GetTransform())){if(t)return t.ReportFixture(a);if(n)return n(a)}return!0})),t instanceof Ju)for(let e=this.m_particleSystemList;e;e=e.m_next)t.ShouldQueryParticleSystem(e)&&e.QueryAABB(t,r)}QueryAllFixtureShape(t,e,i,s=[]){return this.QueryFixtureShape(t,e,i,(t=>(s.push(t),!0))),s}QueryFixturePoint(...t){t[0]instanceof Ju?this._QueryFixturePoint(t[0],t[1]):this._QueryFixturePoint(null,t[0],t[1])}_QueryFixturePoint(t,e,i){if(this.m_contactManager.m_broadPhase.QueryPoint(e,(s=>{const n=s.userData.fixture;if(n.TestPoint(e)){if(t)return t.ReportFixture(n);if(i)return i(n)}return!0})),t)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryPointAABB(t,e)}QueryAllFixturePoint(t,e=[]){return this.QueryFixturePoint(t,(t=>(e.push(t),!0))),e}RayCast(...t){t[0]instanceof class{ReportFixture(t,e,i,s){return s}ReportParticle(t,e,i,s,n){return 0}ShouldQueryParticleSystem(t){return!0}}?this._RayCast(t[0],t[1],t[2]):this._RayCast(null,t[0],t[1],t[2])}_RayCast(t,e,i,s){const n=sd.RayCast_s_input;if(n.maxFraction=1,n.p1.Copy(e),n.p2.Copy(i),this.m_contactManager.m_broadPhase.RayCast(n,((n,r)=>{const o=r.userData,a=o.fixture,l=o.childIndex,h=sd.RayCast_s_output;if(a.RayCast(h,n,l)){const n=h.fraction,r=sd.RayCast_s_point;if(r.Set((1-n)*e.x+n*i.x,(1-n)*e.y+n*i.y),t)return t.ReportFixture(a,r,h.normal,n);if(s)return s(a,r,h.normal,n)}return n.maxFraction})),t)for(let s=this.m_particleSystemList;s;s=s.m_next)t.ShouldQueryParticleSystem(s)&&s.RayCast(t,e,i)}RayCastOne(t,e){let i=null,s=1;return this.RayCast(t,e,((t,e,n,r)=>(r<s&&(s=r,i=t),s))),i}RayCastAll(t,e,i=[]){return this.RayCast(t,e,((t,e,s,n)=>(i.push(t),1))),i}GetBodyList(){return this.m_bodyList}GetJointList(){return this.m_jointList}GetParticleSystemList(){return this.m_particleSystemList}GetContactList(){return this.m_contactManager.m_contactList}SetAllowSleeping(t){if(t!==this.m_allowSleep&&(this.m_allowSleep=t,!this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetAllowSleeping(){return this.m_allowSleep}SetWarmStarting(t){this.m_warmStarting=t}GetWarmStarting(){return this.m_warmStarting}SetContinuousPhysics(t){this.m_continuousPhysics=t}GetContinuousPhysics(){return this.m_continuousPhysics}SetSubStepping(t){this.m_subStepping=t}GetSubStepping(){return this.m_subStepping}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount()}GetBodyCount(){return this.m_bodyCount}GetJointCount(){return this.m_jointCount}GetContactCount(){return this.m_contactManager.m_contactCount}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight()}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance()}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality()}SetGravity(t,e=!0){if(!Yh.IsEqualToV(this.m_gravity,t)&&(this.m_gravity.Copy(t),e))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetGravity(){return this.m_gravity}IsLocked(){return this.m_locked}SetAutoClearForces(t){this.m_clearForces=t}GetAutoClearForces(){return this.m_clearForces}ShiftOrigin(t){if(this.IsLocked())throw new Error;for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.SelfSub(t),e.m_sweep.c0.SelfSub(t),e.m_sweep.c.SelfSub(t);for(let e=this.m_jointList;e;e=e.m_next)e.ShiftOrigin(t);this.m_contactManager.m_broadPhase.ShiftOrigin(t)}GetContactManager(){return this.m_contactManager}GetProfile(){return this.m_profile}Dump(t){if(this.m_locked)return;t("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n",this.m_gravity.x,this.m_gravity.y),t("this.m_world.SetGravity(g);\n"),t("const bodies: b2Body[] = [];\n"),t("const joints: b2Joint[] = [];\n");let e=0;for(let i=this.m_bodyList;i;i=i.m_next)i.m_islandIndex=e,i.Dump(t),++e;e=0;for(let t=this.m_jointList;t;t=t.m_next)t.m_index=e,++e;for(let e=this.m_jointList;e;e=e.m_next)e.m_type!==vu.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"));for(let e=this.m_jointList;e;e=e.m_next)e.m_type===vu.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"))}DrawShape(t,e){if(null===this.m_debugDraw)return;const i=t.GetShape();switch(i.m_type){case jc.e_circleShape:{const t=i,s=t.m_p,n=t.m_radius,r=Yh.UNITX;this.m_debugDraw.DrawSolidCircle(s,n,r,e);break}case jc.e_edgeShape:{const t=i,s=t.m_vertex1,n=t.m_vertex2;this.m_debugDraw.DrawSegment(s,n,e),!1===t.m_oneSided&&(this.m_debugDraw.DrawPoint(s,4,e),this.m_debugDraw.DrawPoint(n,4,e));break}case jc.e_chainShape:{const t=i,s=t.m_count,n=t.m_vertices;let r=n[0];for(let t=1;t<s;++t){const i=n[t];this.m_debugDraw.DrawSegment(r,i,e),r=i}break}case jc.e_polygonShape:{const t=i,s=t.m_count,n=t.m_vertices;this.m_debugDraw.DrawSolidPolygon(n,s,e);break}}}Solve(t){for(let t=this.m_bodyList;t;t=t.m_next)t.m_xf0.Copy(t.m_xf);for(let e=this.m_controllerList;e;e=e.m_next)e.Step(t);this.m_profile.solveInit=0,this.m_profile.solveVelocity=0,this.m_profile.solvePosition=0;const e=this.m_island;e.Initialize(this.m_bodyCount,this.m_contactManager.m_contactCount,this.m_jointCount,this.m_contactManager.m_contactListener);for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const i=this.s_stack;for(let s=this.m_bodyList;s;s=s.m_next){if(s.m_islandFlag)continue;if(!s.IsAwake()||!s.IsEnabled())continue;if(s.GetType()===Su.b2_staticBody)continue;e.Clear();let n=0;for(i[n++]=s,s.m_islandFlag=!0;n>0;){const t=i[--n];if(!t)throw new Error;if(e.AddBody(t),t.GetType()!==Su.b2_staticBody){t.m_awakeFlag=!0;for(let s=t.m_contactList;s;s=s.next){const t=s.contact;if(t.m_islandFlag)continue;if(!t.IsEnabled()||!t.IsTouching())continue;const r=t.m_fixtureA.m_isSensor,o=t.m_fixtureB.m_isSensor;if(r||o)continue;e.AddContact(t),t.m_islandFlag=!0;const a=s.other;a.m_islandFlag||(i[n++]=a,a.m_islandFlag=!0)}for(let s=t.m_jointList;s;s=s.next){if(s.joint.m_islandFlag)continue;const t=s.other;t.IsEnabled()&&(e.AddJoint(s.joint),s.joint.m_islandFlag=!0,t.m_islandFlag||(i[n++]=t,t.m_islandFlag=!0))}}}const r=new Yu;e.Solve(r,t,this.m_gravity,this.m_allowSleep),this.m_profile.solveInit+=r.solveInit,this.m_profile.solveVelocity+=r.solveVelocity,this.m_profile.solvePosition+=r.solvePosition;for(let t=0;t<e.m_bodyCount;++t){const i=e.m_bodies[t];i.GetType()===Su.b2_staticBody&&(i.m_islandFlag=!1)}}for(let t=0;t<i.length&&i[t];++t)i[t]=null;const s=new Jm;for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag&&t.GetType()!==Su.b2_staticBody&&t.SynchronizeFixtures();this.m_contactManager.FindNewContacts(),this.m_profile.broadphase=s.GetMilliseconds()}SolveTOI(t){const e=this.m_island;if(e.Initialize(64,32,0,this.m_contactManager.m_contactListener),this.m_stepComplete){for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let i=null,s=1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){if(!t.IsEnabled())continue;if(t.m_toiCount>8)continue;let e=1;if(t.m_toiFlag)e=t.m_toi;else{const i=t.GetFixtureA(),s=t.GetFixtureB();if(i.IsSensor()||s.IsSensor())continue;const n=i.GetBody(),r=s.GetBody(),o=n.m_type,a=r.m_type,l=n.IsAwake()&&o!==Su.b2_staticBody,h=r.IsAwake()&&a!==Su.b2_staticBody;if(!l&&!h)continue;const c=n.IsBullet()||o!==Su.b2_dynamicBody,m=r.IsBullet()||a!==Su.b2_dynamicBody;if(!c&&!m)continue;let u=n.m_sweep.alpha0;n.m_sweep.alpha0<r.m_sweep.alpha0?(u=r.m_sweep.alpha0,n.m_sweep.Advance(u)):r.m_sweep.alpha0<n.m_sweep.alpha0&&(u=n.m_sweep.alpha0,r.m_sweep.Advance(u));const _=t.GetChildIndexA(),d=t.GetChildIndexB(),p=sd.SolveTOI_s_toi_input;p.proxyA.SetShape(i.GetShape(),_),p.proxyB.SetShape(s.GetShape(),d),p.sweepA.Copy(n.m_sweep),p.sweepB.Copy(r.m_sweep),p.tMax=1;const f=sd.SolveTOI_s_toi_output;xu(f,p);const y=f.t;e=f.state===au.e_touching?Uh(u+(1-u)*y,1):1,t.m_toi=e,t.m_toiFlag=!0}e<s&&(i=t,s=e)}if(null===i||.9999<s){this.m_stepComplete=!0;break}const n=i.GetFixtureA(),r=i.GetFixtureB(),o=n.GetBody(),a=r.GetBody(),l=sd.SolveTOI_s_backup1.Copy(o.m_sweep),h=sd.SolveTOI_s_backup2.Copy(a.m_sweep);if(o.Advance(s),a.Advance(s),i.Update(this.m_contactManager.m_contactListener),i.m_toiFlag=!1,++i.m_toiCount,!i.IsEnabled()||!i.IsTouching()){i.SetEnabled(!1),o.m_sweep.Copy(l),a.m_sweep.Copy(h),o.SynchronizeTransform(),a.SynchronizeTransform();continue}o.SetAwake(!0),a.SetAwake(!0),e.Clear(),e.AddBody(o),e.AddBody(a),e.AddContact(i),o.m_islandFlag=!0,a.m_islandFlag=!0,i.m_islandFlag=!0;for(let t=0;t<2;++t){const i=0===t?o:a;if(i.m_type===Su.b2_dynamicBody)for(let t=i.m_contactList;t&&e.m_bodyCount!==e.m_bodyCapacity&&e.m_contactCount!==e.m_contactCapacity;t=t.next){const n=t.contact;if(n.m_islandFlag)continue;const r=t.other;if(r.m_type===Su.b2_dynamicBody&&!i.IsBullet()&&!r.IsBullet())continue;const o=n.m_fixtureA.m_isSensor,a=n.m_fixtureB.m_isSensor;if(o||a)continue;const l=sd.SolveTOI_s_backup.Copy(r.m_sweep);r.m_islandFlag||r.Advance(s),n.Update(this.m_contactManager.m_contactListener),n.IsEnabled()&&n.IsTouching()?(n.m_islandFlag=!0,e.AddContact(n),r.m_islandFlag||(r.m_islandFlag=!0,r.m_type!==Su.b2_staticBody&&r.SetAwake(!0),e.AddBody(r))):(r.m_sweep.Copy(l),r.SynchronizeTransform())}}const c=sd.SolveTOI_s_subStep;c.dt=(1-s)*t.dt,c.inv_dt=1/c.dt,c.dtRatio=1,c.positionIterations=20,c.velocityIterations=t.velocityIterations,c.particleIterations=t.particleIterations,c.warmStarting=!1,e.SolveTOI(c,o.m_islandIndex,a.m_islandIndex);for(let t=0;t<e.m_bodyCount;++t){const i=e.m_bodies[t];if(i.m_islandFlag=!1,i.m_type===Su.b2_dynamicBody){i.SynchronizeFixtures();for(let t=i.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(this.m_contactManager.FindNewContacts(),this.m_subStepping){this.m_stepComplete=!1;break}}}AddController(t){return t.m_next=this.m_controllerList,t.m_prev=null,this.m_controllerList&&(this.m_controllerList.m_prev=t),this.m_controllerList=t,++this.m_controllerCount,t}RemoveController(t){return t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),this.m_controllerList===t&&(this.m_controllerList=t.m_next),--this.m_controllerCount,t.m_prev=null,t.m_next=null,t}}sd.Step_s_step=new Qu,sd.Step_s_stepTimer=new Jm,sd.Step_s_timer=new Jm,sd.DebugDraw_s_color=new wh(0,0,0),sd.DebugDraw_s_vs=Yh.MakeArray(4),sd.DebugDraw_s_xf=new ic,sd.QueryFixtureShape_s_aabb=new Dc,sd.RayCast_s_input=new Tc,sd.RayCast_s_output=new Pc,sd.RayCast_s_point=new Yh,sd.SolveTOI_s_subStep=new Qu,sd.SolveTOI_s_backup=new sc,sd.SolveTOI_s_backup1=new sc,sd.SolveTOI_s_backup2=new sc,sd.SolveTOI_s_toi_input=new ou,sd.SolveTOI_s_toi_output=new hu,function(t){t[t.b2_pbdStretchingModel=0]="b2_pbdStretchingModel",t[t.b2_xpbdStretchingModel=1]="b2_xpbdStretchingModel"}(y_||(y_={})),function(t){t[t.b2_springAngleBendingModel=0]="b2_springAngleBendingModel",t[t.b2_pbdAngleBendingModel=1]="b2_pbdAngleBendingModel",t[t.b2_xpbdAngleBendingModel=2]="b2_xpbdAngleBendingModel",t[t.b2_pbdDistanceBendingModel=3]="b2_pbdDistanceBendingModel",t[t.b2_pbdHeightBendingModel=4]="b2_pbdHeightBendingModel",t[t.b2_pbdTriangleBendingModel=5]="b2_pbdTriangleBendingModel"}(g_||(g_={}));class nd{constructor(t,e){this.prevBody=null,this.nextBody=null,this.prevController=null,this.nextController=null,this.controller=t,this.body=e}}class rd{constructor(){this.m_bodyList=null,this.m_bodyCount=0,this.m_prev=null,this.m_next=null}GetNext(){return this.m_next}GetPrev(){return this.m_prev}GetBodyList(){return this.m_bodyList}AddBody(t){const e=new nd(this,t);e.nextBody=this.m_bodyList,e.prevBody=null,this.m_bodyList&&(this.m_bodyList.prevBody=e),this.m_bodyList=e,++this.m_bodyCount,e.nextController=t.m_controllerList,e.prevController=null,t.m_controllerList&&(t.m_controllerList.prevController=e),t.m_controllerList=e,++t.m_controllerCount}RemoveBody(t){if(this.m_bodyCount<=0)throw new Error;let e=this.m_bodyList;for(;e&&e.body!==t;)e=e.nextBody;if(null===e)throw new Error;e.prevBody&&(e.prevBody.nextBody=e.nextBody),e.nextBody&&(e.nextBody.prevBody=e.prevBody),this.m_bodyList===e&&(this.m_bodyList=e.nextBody),--this.m_bodyCount,e.nextController&&(e.nextController.prevController=e.prevController),e.prevController&&(e.prevController.nextController=e.nextController),t.m_controllerList===e&&(t.m_controllerList=e.nextController),--t.m_controllerCount}Clear(){for(;this.m_bodyList;)this.RemoveBody(this.m_bodyList.body);this.m_bodyCount=0}}class od extends rd{constructor(){super(...arguments),this.A=new Yh(0,0)}Step(t){const e=Yh.MulSV(t.dt,this.A,od.Step_s_dtA);for(let t=this.m_bodyList;t;t=t.nextBody){const i=t.body;i.IsAwake()&&i.SetLinearVelocity(Yh.AddVV(i.GetLinearVelocity(),e,Yh.s_t0))}}Draw(t){}}od.Step_s_dtA=new Yh;class ad extends rd{constructor(){super(...arguments),this.G=1,this.invSqr=!0}Step(t){if(this.invSqr)for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,i=e.GetWorldCenter(),s=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,r=t.GetWorldCenter(),o=t.GetMass(),a=r.x-i.x,l=r.y-i.y,h=a*a+l*l;if(h<Mh)continue;const c=ad.Step_s_f.Set(a,l);c.SelfMul(this.G/h/Xh(h)*s*o),e.IsAwake()&&e.ApplyForce(c,i),t.IsAwake()&&t.ApplyForce(c.SelfMul(-1),r)}}else for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,i=e.GetWorldCenter(),s=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,r=t.GetWorldCenter(),o=t.GetMass(),a=r.x-i.x,l=r.y-i.y,h=a*a+l*l;if(h<Mh)continue;const c=ad.Step_s_f.Set(a,l);c.SelfMul(this.G/h*s*o),e.IsAwake()&&e.ApplyForce(c,i),t.IsAwake()&&t.ApplyForce(c.SelfMul(-1),r)}}}Draw(t){}}ad.Step_s_f=new Yh;class ld extends rd{constructor(){super(...arguments),this.T=new $h,this.maxTimestep=0}Step(t){let e=t.dt;if(!(e<=Mh)){e>this.maxTimestep&&this.maxTimestep>0&&(e=this.maxTimestep);for(let t=this.m_bodyList;t;t=t.nextBody){const i=t.body;if(!i.IsAwake())continue;const s=i.GetWorldVector($h.MulMV(this.T,i.GetLocalVector(i.GetLinearVelocity(),Yh.s_t0),Yh.s_t1),ld.Step_s_damping);i.SetLinearVelocity(Yh.AddVV(i.GetLinearVelocity(),Yh.MulSV(e,s,Yh.s_t0),Yh.s_t1))}}}Draw(t){}SetAxisAligned(t,e){this.T.ex.x=-t,this.T.ex.y=0,this.T.ey.x=0,this.T.ey.y=-e,this.maxTimestep=t>0||e>0?1/Wh(t,e):0}}ld.Step_s_damping=new Yh,Su.b2_staticBody,Su.b2_kinematicBody,Su.b2_dynamicBody,g_.b2_springAngleBendingModel,g_.b2_pbdAngleBendingModel,g_.b2_xpbdAngleBendingModel,g_.b2_pbdDistanceBendingModel,g_.b2_pbdHeightBendingModel,g_.b2_pbdTriangleBendingModel,y_.b2_pbdStretchingModel,y_.b2_xpbdStretchingModel;class hd{constructor(){this._defaultMaterial=null,this._velocityIterations=8,this._positionIterations=3,this._world=new sd(new Yh(0,-9.81))}update(t){this._world.Step(t,this._velocityIterations,this._positionIterations),this._world.ClearForces();let e=this._world.GetBodyList();for(;e;){const t=e.GetUserData();t&&(t.transform.position.x=e.GetPosition().x,t.transform.position.y=e.GetPosition().y,t.transform.rotation=e.GetAngle()),e=e.GetNext()}}get gravity(){const t=this._world.GetGravity();return new Z(t.x,t.y)}set gravity(t){this._world.SetGravity(new Yh(t.x,t.y))}get defaultMaterial(){return this._defaultMaterial}set defaultMaterial(t){this._defaultMaterial=t}get velocityIterations(){return this._velocityIterations}set velocityIterations(t){this._velocityIterations=t}get positionIterations(){return this._positionIterations}set positionIterations(t){this._positionIterations=t}}class cd{constructor(t,e){this._gameSetting=e,this._rootScene=new pl,this._gameScreen=new _h(t.clientWidth,t.clientHeight),this._container=t,this._css3DRenderer=new Sh,this._css3DRenderer.setSize(t.clientWidth,t.clientHeight),this._css3DRenderer.domElement.style.width="100%",this._css3DRenderer.domElement.style.height="100%",this._cameraContainer=new ql((t=>{this._css3DRenderer.domElement.style.backgroundColor="rgba("+255*t.r+","+255*t.g+","+255*t.b+","+t.a+")"})),this._time=new uh,this._gameState=new Xl(Ml.WaitingForStart),this._sceneProcessor=new mh,this._coroutineProcessor=new dh(this._time),this._transformMatrixProcessor=new ph,this._physics2DProcessor=new hd,this._engineGlobalObject=new Hl(this._rootScene,this._cameraContainer,this._time,this._gameState,this._gameScreen,this._sceneProcessor,this._coroutineProcessor,this._transformMatrixProcessor,this._physics2DProcessor,this._css3DRenderer.domElement),this._animationFrameId=null,this._isDisposed=!1,e.render.useCss3DRenderer&&t.appendChild(this._css3DRenderer.domElement),this._css3DRenderer.domElement.onscroll=()=>{this._css3DRenderer.domElement.scrollLeft=0,this._css3DRenderer.domElement.scrollTop=0},this._resizeFrameBufferBind=this.resizeFramebuffer.bind(this),window.addEventListener("resize",this._resizeFrameBufferBind),this._loopBind=this.loop.bind(this)}resizeFramebuffer(){const t=this._container.clientWidth,e=this._container.clientHeight;t===this._gameScreen.width&&e===this._gameScreen.height||(this._gameScreen.resize(t,e),this._css3DRenderer.setSize(t,e),this._css3DRenderer.domElement.style.width="100%",this._css3DRenderer.domElement.style.height="100%")}run(t,e){if(this._isDisposed)throw new Error("Game is disposed.");if(this._gameState.kind!==Ml.WaitingForStart)throw new Error("Game is already running.");if(this._gameState.kind=Ml.Initializing,this._time.start(),new t(this._engineGlobalObject,e).run().build(),!this._cameraContainer.camera)throw new Error("Camera is not exist or not active in the scene.");if(this._gameState.kind=Ml.Running,this._sceneProcessor.startProcessNonSyncedEvent(),this._gameSetting.physics.usePhysics2D&&this._physics2DProcessor.update(this._time.deltaTime),this._coroutineProcessor.updateAfterProcess(),!this._cameraContainer.camera)throw new Error("Camera is not exist or not active in the scene.");this._sceneProcessor.processRemoveObject();const i=this._transformMatrixProcessor.update();this._gameSetting.render.useCss3DRenderer&&this._css3DRenderer.render(i,this._rootScene,this._cameraContainer.camera),this._transformMatrixProcessor.flush(),this._coroutineProcessor.endFrameAfterProcess(),this.loop()}loop(){if(this._animationFrameId=requestAnimationFrame(this._loopBind),this._time.update(),this._sceneProcessor.startProcessNonSyncedEvent(),this._gameSetting.physics.usePhysics2D&&this._physics2DProcessor.update(this._time.deltaTime),this._coroutineProcessor.tryCompact(),this._coroutineProcessor.updateAfterProcess(),!this._cameraContainer.camera)throw new Error("Camera is not exist or not active in the scene.");this._sceneProcessor.processRemoveObject();const t=this._transformMatrixProcessor.update();this._gameSetting.render.useCss3DRenderer&&this._css3DRenderer.render(t,this._rootScene,this._cameraContainer.camera),this._transformMatrixProcessor.flush(),this._coroutineProcessor.endFrameAfterProcess()}stop(){if(this._isDisposed)throw new Error("Game is disposed.");if(this._gameState.kind!==Ml.Running)throw new Error("Game is not running.");this._gameState.kind=Ml.Stopped,this._animationFrameId&&cancelAnimationFrame(this._animationFrameId),this._animationFrameId=null}resume(){if(this._isDisposed)throw new Error("Game is disposed.");if(this._gameState.kind!==Ml.Stopped)throw new Error("Game is not stopped.");this._gameState.kind=Ml.Running,this.loop()}dispose(){this._isDisposed||(this._gameState.kind=Ml.Finalizing,this._animationFrameId&&cancelAnimationFrame(this._animationFrameId),this._engineGlobalObject.dispose(),this._rootScene.children.slice().forEach((t=>{t instanceof Al&&t.gameObject.destroy()})),this._container.removeChild(this._css3DRenderer.domElement),window.removeEventListener("resize",this._resizeFrameBufferBind),this._isDisposed=!0,this._gameState.kind=Ml.Finalized)}get inputHandler(){return this._engineGlobalObject.input}get currentGameState(){return this._gameState.kind}}const md={defaultSpriteSrc:"https://i.imgur.com/B5T81uM.png"};class ud{constructor(t,e){this._x=t,this._y=e,this._gCost=0,this._hCost=0,this._fCost=0,this._previousNode=null,this._isWalkable=!0}calculateFCost(){this._fCost=this._gCost+this._hCost}equals(t){return this._x===t._x&&this._y===t._y}get x(){return this._x}get y(){return this._y}get gCost(){return this._gCost}set gCost(t){this._gCost=t}get hCost(){return this._hCost}set hCost(t){this._hCost=t}get fCost(){return this._fCost}set fCost(t){this._fCost=t}get isWalkable(){return this._isWalkable}set isWalkable(t){this._isWalkable=t}get previousNode(){return this._previousNode}set previousNode(t){this._previousNode=t}}class _d{constructor(t){var e;this.collideMaps=null!==(e=null==t?void 0:t.slice())&&void 0!==e?e:[]}addCollideMap(t){this.collideMaps.push(t)}findPath(t,e){const i=new ud(t.x,t.y),s=new ud(e.x,e.y);if(this.checkCollision(i.x,i.y))return null;if(this.checkCollision(s.x,s.y))return null;const n=[],r=[];i.gCost=0,i.hCost=this.calculateDistanceCost(i,s),i.calculateFCost(),n.push(i);let o=0;for(;n.length>0&&o<_d._iterationLimit;){o++;const t=this.getLowestFcostNode(n);if(t.equals(s))return this.calculatePath(t);n.splice(n.indexOf(t),1),r.push(t);const e=this.getNeighbors(t);for(let i=0;i<e.length;i++){const o=e[i];if(void 0!==r.find((t=>t.equals(o))))continue;if(o.gCost=Number.MAX_VALUE,o.calculateFCost(),o.previousNode=null,this.checkCollision(o.x,o.y)){r.push(o);continue}const a=t.gCost+this.calculateDistanceCost(t,o);a<o.gCost&&(o.previousNode=t,o.gCost=a,o.hCost=this.calculateDistanceCost(o,s),o.calculateFCost(),void 0===n.find((t=>t.equals(o)))&&n.push(o))}}return null}getNeighbors(t){const e=[];return e.push(new ud(t.x,t.y-1)),e.push(new ud(t.x+1,t.y)),e.push(new ud(t.x,t.y+1)),e.push(new ud(t.x-1,t.y)),e}calculatePath(t){const e=[];let i=t;for(;i.previousNode;)e.push(new Z(i.x,i.y)),i=i.previousNode;return e.push(new Z(i.x,i.y)),e.reverse()}calculateDistanceCost(t,e){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)}getLowestFcostNode(t){let e=t[0];for(let i=1;i<t.length;i++)t[i].fCost<e.fCost&&(e=t[i]);return e}checkCollision(t,e){const i=this.collideMaps;for(let s=0;s<i.length;s++){const n=i[s];if(n.checkCollision(t*n.gridCellWidth+n.gridCenterX,e*n.gridCellHeight+n.gridCenterY,_d._checkCollisionScale,_d._checkCollisionScale))return!0}return!1}}_d._checkCollisionScale=8,_d._iterationLimit=1e3,new pt,new dt,new pt;class dd extends ye{constructor(t=document.createElement("div")){super(),this.element=t,this.element.style.position="absolute",this.element.style.pointerEvents="auto",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.addEventListener("removed",(function(){this.traverse((function(t){t.element instanceof Element&&null!==t.element.parentNode&&t.element.parentNode.removeChild(t.element)}))}))}copy(t,e){return super.copy(t,e),this.element=t.element.cloneNode(!0),this}}dd.prototype.isCSS3DObject=!0,class extends dd{constructor(t){super(t),this.rotation2D=0}copy(t,e){return super.copy(t,e),this.rotation2D=t.rotation2D,this}}.prototype.isCSS3DSprite=!0,new qt,new qt;class pd extends Nl{}class fd extends pd{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._runOnce=!0}start(){this.process(),this.runOnce&&(this.enabled=!1)}update(){this.process()}process(){this.gameObject.getComponentsInChildren().forEach((t=>{const e=t;e.onSortByZaxis&&"function"==typeof e.onSortByZaxis&&e.onSortByZaxis(t.transform.position.z)}))}static checkAncestorZaxisInitializer(t,e){if(!t.transform.parent)return;let i=t.transform.parent;for(;i;){if(i.gameObject.getComponent(fd))return void e(i.position.z);if(null===i.parent)break;i=i.parent}}get runOnce(){return this._runOnce}set runOnce(t){this._runOnce=t}}class yd extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._sprite=null,this._htmlImageElement=null,this._imageCenterOffset=new Z(0,0),this._zindex=0,this._imageWidth=0,this._imageHeight=0,this._imageFlipX=!1,this._imageFlipY=!1,this._opacity=1,this._pointerEvents=!0,this._started=!1,this._initializeFunction=null}start(){var t;this._started=!0,null===(t=this._initializeFunction)||void 0===t||t.call(this),this._htmlImageElement||this.asyncSetImagePath(md.defaultSpriteSrc),fd.checkAncestorZaxisInitializer(this.gameObject,this.onSortByZaxis.bind(this))}onDestroy(){this._started&&this._sprite&&this.transform.unsafeGetObject3D().remove(this._sprite)}onEnable(){this._sprite&&(this._sprite.visible=!0,this.transform.enqueueRenderAttachedObject3D(this._sprite))}onDisable(){this._sprite&&(this._sprite.visible=!1,this.transform.enqueueRenderAttachedObject3D(this._sprite))}onSortByZaxis(t){this._zindex=t,this._sprite&&(this._sprite.element.style.zIndex=Math.floor(this._zindex).toString())}onWorldMatrixUpdated(){this._sprite&&(Al.updateRawObject3DWorldMatrixRecursively(this._sprite),this.transform.enqueueRenderAttachedObject3D(this._sprite))}get imagePath(){var t;return(null===(t=this._htmlImageElement)||void 0===t?void 0:t.src)||null}asyncSetImagePath(t,e){if(!this._started)return void(this._initializeFunction=()=>{this.asyncSetImagePath(t,e)});t||(t=md.defaultSpriteSrc),this._htmlImageElement||(this._htmlImageElement=new Image),this._htmlImageElement.src=t;const i=t=>{const s=t.target;s.removeEventListener("load",i),this._sprite||(this._sprite=new dd(s),s.alt=this.gameObject.name+"_sprite_atlas",s.style.imageRendering="pixelated",0===this._imageWidth&&(this._imageWidth=s.width),0===this._imageHeight&&(this._imageHeight=s.height),s.style.width=this._imageWidth+"px",s.style.height=this._imageHeight+"px",s.style.opacity=this._opacity.toString(),s.style.pointerEvents=this._pointerEvents?"auto":"none",s.style.zIndex=Math.floor(this._zindex).toString(),this.updateCenterOffset(),this._sprite.scale.x=this._imageFlipX?-1:1,this._sprite.scale.y=this._imageFlipY?-1:1,this.transform.unsafeGetObject3D().add(this._sprite),this.enabled&&this.gameObject.activeInHierarchy?this._sprite.visible=!0:this._sprite.visible=!1,Al.updateRawObject3DWorldMatrixRecursively(this._sprite),this.transform.enqueueRenderAttachedObject3D(this._sprite)),null==e||e()};this._htmlImageElement.addEventListener("load",i)}updateCenterOffset(){this._sprite&&(this._sprite.position.set(this._imageWidth*this._imageCenterOffset.x,this._imageHeight*this._imageCenterOffset.y,0),Al.updateRawObject3DWorldMatrixRecursively(this._sprite),this.transform.enqueueRenderAttachedObject3D(this._sprite))}get imageCenterOffset(){return this._imageCenterOffset.clone()}set imageCenterOffset(t){this._imageCenterOffset.copy(t),this.updateCenterOffset()}get imageWidth(){return this._imageWidth}set imageWidth(t){this._imageWidth=t,this._htmlImageElement&&(this._htmlImageElement.style.width=t+"px"),this.updateCenterOffset()}get imageHeight(){return this._imageHeight}set imageHeight(t){this._imageHeight=t,this._htmlImageElement&&(this._htmlImageElement.style.height=t+"px"),this.updateCenterOffset()}get imageFlipX(){return this._imageFlipX}set imageFlipX(t){this._imageFlipX=t,this._sprite&&(this._sprite.scale.x=this._imageFlipX?-1:1,Al.updateRawObject3DWorldMatrixRecursively(this._sprite),this.transform.enqueueRenderAttachedObject3D(this._sprite))}get imageFlipY(){return this._imageFlipY}set imageFlipY(t){this._imageFlipY=t,this._sprite&&(this._sprite.scale.y=this._imageFlipY?-1:1,Al.updateRawObject3DWorldMatrixRecursively(this._sprite),this.transform.enqueueRenderAttachedObject3D(this._sprite))}get opacity(){return this._opacity}set opacity(t){this._opacity=t,this._htmlImageElement&&(this._htmlImageElement.style.opacity=this._opacity.toString())}get pointerEvents(){return this._pointerEvents}set pointerEvents(t){this._pointerEvents=t,this._htmlImageElement&&(this._htmlImageElement.style.pointerEvents=this._pointerEvents?"auto":"none")}}class gd{constructor(t,e){this._priority=t,this._backgroundColor=e}get priority(){return this._priority}set priority(t){this._priority=t}get backgroundColor(){return this._backgroundColor}set backgroundColor(t){this._backgroundColor=t}}class xd{constructor(t,e,i,s=1){this._r=t,this._g=e,this._b=i,this._a=s}get r(){return this._r}get g(){return this._g}get b(){return this._b}get a(){return this._a}toString(){return"rgba("+this._r+", "+this._g+", "+this._b+", "+this._a+")"}toHex(){return"#"+this._r.toString(16)+this._g.toString(16)+this._b.toString(16)}toArray(){return[this._r,this._g,this._b,this._a]}static fromHex(t){const e=parseInt(t.slice(1,3),16),i=parseInt(t.slice(3,5),16),s=parseInt(t.slice(5,7),16);return new xd(e,i,s)}static fromArray(t){return new xd(t[0],t[1],t[2],t[3])}static fromString(t){const e=t.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*(?:\.\d+)?)\)$/);return e?new xd(parseInt(e[1]),parseInt(e[2]),parseInt(e[3]),parseFloat(e[4])):xd.fromHex(t)}}var vd,Sd,wd,bd;!function(t){t[t.Perspective=0]="Perspective",t[t.Orthographic=1]="Orthographic"}(vd||(vd={}));class Cd extends Nl{constructor(){super(...arguments),this._camera=null,this._cameraType=vd.Orthographic,this._fov=75,this._viewSize=300,this._near=.1,this._far=1e3,this._priority=0,this._backgroudColor=new xd(1,1,1,0),this._onScreenResizeBind=this.onScreenResize.bind(this)}onEnable(){this.engine.screen.addOnResizeEventListener(this._onScreenResizeBind),this.createOrUpdateCamera()}onWorldMatrixUpdated(){this._camera&&(Al.updateRawObject3DWorldMatrixRecursively(this._camera),this._camera.matrixWorldInverse.copy(this._camera.matrixWorld).invert())}createOrUpdateCamera(){const t=this.engine.screen.width/this.engine.screen.height;if(this._cameraType===vd.Perspective)this._camera?this._camera instanceof yi?(this._camera.aspect=t,this._camera.fov=this._fov,this._camera.near=this._near,this._camera.far=this._far,this._camera.updateProjectionMatrix()):(this._camera.removeFromParent(),this._camera=this.createNewPerspectiveCamera(),this.transform.unsafeGetObject3D().add(this._camera)):(this._camera=this.createNewPerspectiveCamera(),this.transform.unsafeGetObject3D().add(this._camera));else{if(this._cameraType!==vd.Orthographic)throw new Error("Camera type not supported");if(this._camera)if(this._camera instanceof Ni){const e=.5*this._viewSize;this._camera.left=-e*t,this._camera.right=e*t,this._camera.top=e,this._camera.bottom=-e,this._camera.near=this._near,this._camera.far=this._far,this._camera.updateProjectionMatrix()}else this._camera.removeFromParent(),this._camera=this.createNewOrthographicCamera(),this.transform.unsafeGetObject3D().add(this._camera);else this._camera=this.createNewOrthographicCamera(),this.transform.unsafeGetObject3D().add(this._camera)}Al.updateRawObject3DWorldMatrixRecursively(this._camera),this.engine.cameraContainer.addCamera(this._camera,new gd(this._priority,this._backgroudColor))}createNewPerspectiveCamera(){const t=this.engine.screen.width/this.engine.screen.height;return new yi(this._fov,t,this._near,this._far)}createNewOrthographicCamera(){const t=this.engine.screen.width/this.engine.screen.height,e=.5*this._viewSize;return new Ni(-e*t,e*t,e,-e,this._near,this._far)}onDisable(){this.engine.screen.removeOnResizeEventListener(this._onScreenResizeBind),this._camera&&this.engine.cameraContainer.removeCamera(this._camera)}onDestroy(){var t;null===(t=this._camera)||void 0===t||t.removeFromParent()}onScreenResize(t,e){const i=t/e;if(this._camera instanceof yi)this._camera.aspect=i,this._camera.updateProjectionMatrix();else if(this._camera instanceof Ni){const t=.5*this._viewSize;this._camera.left=-t*i,this._camera.right=t*i,this._camera.top=t,this._camera.bottom=-t,this._camera.updateProjectionMatrix()}}get cameraType(){return this._cameraType}set cameraType(t){this._cameraType!==t&&(this._cameraType=t,this._camera&&this.createOrUpdateCamera())}get fov(){return this._fov}set fov(t){this._fov!==t&&(this._fov=t,this._camera instanceof yi&&(this._camera.fov=t,this._camera.updateProjectionMatrix()))}get viewSize(){return this._viewSize}set viewSize(t){if(this._viewSize!==t&&(this._viewSize=t,this._camera instanceof Ni)){const t=this.engine.screen.width/this.engine.screen.height,e=.5*this._viewSize;this._camera.left=-e*t,this._camera.right=e*t,this._camera.top=e,this._camera.bottom=-e,this._camera.updateProjectionMatrix()}}get near(){return this._near}set near(t){this._near!==t&&(this._near=t,this._camera instanceof yi&&(this._camera.near=t,this._camera.updateProjectionMatrix()))}get far(){return this._far}set far(t){this._far!==t&&(this._far=t,this._camera instanceof yi&&(this._camera.far=t,this._camera.updateProjectionMatrix()))}get priority(){return this._priority}set priority(t){this._priority=t,this._camera&&this.engine.cameraContainer.changeCameraPriority(this._camera,t)}get backgroundColor(){return this._backgroudColor}set backgroundColor(t){this._backgroudColor=t,this._camera&&this.engine.cameraContainer.changeCameraBackgroundColor(this._camera,t)}}!function(t){t[t.Up=0]="Up",t[t.Down=1]="Down",t[t.Left=2]="Left",t[t.Right=3]="Right"}(Sd||(Sd={}));class Ad extends Nl{constructor(){super(...arguments),this._direction=Sd.Down,this._isMoving=!1}get direction(){return this._direction}set direction(t){this._direction=t}get isMoving(){return this._isMoving}set isMoving(t){this._isMoving=t}}class Bd extends Ad{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._speed=80,this._gridCellHeight=16,this._gridCellWidth=16,this._collideMaps=[],this._collideSize=8,this._gridCenter=new Z,this._currentGridPosition=new Z,this._targetGridPosition=new Z,this._initPosition=new Z,this._onMoveToTargetDelegates=[],this._onMovedToTargetDelegates=[],this._onPointerDownBind=this.onPointerDown.bind(this),this._gridPointer=null,this._pathfinder=null,this._movingByPathfinder=!1,this._findedPath=null,this._currentPathIndex=0,this._pathfindStartFunction=null,this._tempVector2=new Z,this._lastPointerDownTime=-1,this._lastPointerDownPosition=new Z,this._doubleClickTime=.3}start(){this._pathfinder=new _d(this._collideMaps);const t=this.transform,e=t.position;e.x=this._gridCenter.x+this._initPosition.x*this._gridCellWidth,e.y=this._gridCenter.y+this._initPosition.y*this._gridCellHeight,this._currentGridPosition.set(t.localPosition.x,t.localPosition.y)}update(){var t;null===(t=this._pathfindStartFunction)||void 0===t||t.call(this),this.processInput(),this.processPathfinderInput(),this.processMovement()}processInput(){if(this.isMoving)return void this.tryCancelPathfinder();const t=this.engine.input.map;if(t.get("w")||t.get("W")||t.get("ArrowUp")){if(this.direction=Sd.Up,this.checkCollision(this._currentGridPosition.x,this._currentGridPosition.y+this._gridCellHeight))return;this._targetGridPosition.set(this._currentGridPosition.x,this._currentGridPosition.y+this._gridCellHeight),this.invokeOnMoveToTarget(this._targetGridPosition),this.isMoving=!0}else if(t.get("s")||t.get("S")||t.get("ArrowDown")){if(this.direction=Sd.Down,this.checkCollision(this._currentGridPosition.x,this._currentGridPosition.y-this._gridCellHeight))return;this._targetGridPosition.set(this._currentGridPosition.x,this._currentGridPosition.y-this._gridCellHeight),this.invokeOnMoveToTarget(this._targetGridPosition),this.isMoving=!0}else if(t.get("a")||t.get("A")||t.get("ArrowLeft")){if(this.direction=Sd.Left,this.checkCollision(this._currentGridPosition.x-this._gridCellWidth,this._currentGridPosition.y))return;this._targetGridPosition.set(this._currentGridPosition.x-this._gridCellWidth,this._currentGridPosition.y),this.invokeOnMoveToTarget(this._targetGridPosition),this.isMoving=!0}else if(t.get("d")||t.get("D")||t.get("ArrowRight")){if(this.direction=Sd.Right,this.checkCollision(this._currentGridPosition.x+this._gridCellWidth,this._currentGridPosition.y))return;this._targetGridPosition.set(this._currentGridPosition.x+this._gridCellWidth,this._currentGridPosition.y),this.invokeOnMoveToTarget(this._targetGridPosition),this.isMoving=!0}}noncheckProcessInput(t){const e=this.engine.input.map;return e.get("w")||e.get("W")||e.get("ArrowUp")?(this.direction=Sd.Up,!this.checkCollision(t.x,t.y+this._gridCellHeight)&&(this._targetGridPosition.set(t.x,t.y+this._gridCellHeight),this.invokeOnMoveToTarget(this._targetGridPosition),!0)):e.get("s")||e.get("S")||e.get("ArrowDown")?(this.direction=Sd.Down,!this.checkCollision(t.x,t.y-this._gridCellHeight)&&(this._targetGridPosition.set(t.x,t.y-this._gridCellHeight),this.invokeOnMoveToTarget(this._targetGridPosition),!0)):e.get("a")||e.get("A")||e.get("ArrowLeft")?(this.direction=Sd.Left,!this.checkCollision(t.x-this._gridCellWidth,t.y)&&(this._targetGridPosition.set(t.x-this._gridCellWidth,t.y),this.invokeOnMoveToTarget(this._targetGridPosition),!0)):!!(e.get("d")||e.get("D")||e.get("ArrowRight"))&&(this.direction=Sd.Right,!this.checkCollision(t.x+this._gridCellWidth,t.y)&&(this._targetGridPosition.set(t.x+this._gridCellWidth,t.y),this.invokeOnMoveToTarget(this._targetGridPosition),!0))}invokeOnMoveToTarget(t){this._onMoveToTargetDelegates.forEach((t=>t(Math.floor(this._targetGridPosition.x/this._gridCellWidth),Math.floor(this._targetGridPosition.y/this._gridCellHeight))))}invokeOnMovedToTarget(t){this._onMovedToTargetDelegates.forEach((t=>t(Math.floor(this._currentGridPosition.x/this._gridCellWidth),Math.floor(this._currentGridPosition.y/this._gridCellHeight))))}tryCancelPathfinder(){const t=this.engine.input.map;(t.get("w")||t.get("W")||t.get("ArrowUp")||t.get("s")||t.get("S")||t.get("ArrowDown")||t.get("a")||t.get("A")||t.get("ArrowLeft")||t.get("d")||t.get("D")||t.get("ArrowRight"))&&(this._movingByPathfinder=!1)}processPathfinderInput(){if(!this._movingByPathfinder)return;const t=this.transform,e=this._tempVector2.set(t.localPosition.x,t.localPosition.y),i=this._findedPath[this._currentPathIndex];if(i.distanceTo(e)<this._speed*this.engine.time.deltaTime){if(this._currentPathIndex++,this._currentPathIndex>=this._findedPath.length)return void(this._movingByPathfinder=!1);this.invokeOnMovedToTarget(e)}if(this.checkCollision(i.x,i.y))return void(this._movingByPathfinder=!1);if(this._targetGridPosition.equals(this._findedPath[this._currentPathIndex]))return;this._targetGridPosition.copy(this._findedPath[this._currentPathIndex]),this.invokeOnMoveToTarget(this._targetGridPosition);const s=this._findedPath[this._currentPathIndex-1].x,n=this._findedPath[this._currentPathIndex-1].y,r=this._findedPath[this._currentPathIndex].x,o=this._findedPath[this._currentPathIndex].y;n<o?this.direction=Sd.Up:n>o?this.direction=Sd.Down:s<r?this.direction=Sd.Right:s>r&&(this.direction=Sd.Left),this.isMoving=!0}processMovement(){if(!this.isMoving)return;const t=this.transform,e=new Z(t.localPosition.x,t.localPosition.y);let i=e.distanceTo(this._targetGridPosition);if(i<this._speed*this.engine.time.deltaTime&&this.noncheckProcessInput(this._targetGridPosition)&&(i=e.distanceTo(this._targetGridPosition),this.invokeOnMovedToTarget(e)),i>.1){const s=this._targetGridPosition.clone().sub(e).normalize();s.multiplyScalar(Math.min(this._speed*this.engine.time.deltaTime,i)),t.localPosition.x+=s.x,t.localPosition.y+=s.y}else this.isMoving=!1,this._currentGridPosition.copy(this._targetGridPosition),this.invokeOnMovedToTarget(this._targetGridPosition)}checkCollision(t,e){for(let i=0;i<this._collideMaps.length;i++)if(this._collideMaps[i].checkCollision(t,e,this._collideSize,this._collideSize))return!0;return!1}onPointerDown(t){if(0!==t.button)return;this._movingByPathfinder=!1;const e=this.engine.time.unscaledTime;e-this._lastPointerDownTime<this._doubleClickTime?this._lastPointerDownPosition.equals(t.gridPosition)&&(this.onDoubleClick(t),this._lastPointerDownTime=-1):(this._lastPointerDownTime=e,this._lastPointerDownPosition.copy(t.gridPosition))}onDoubleClick(t){if(this._movingByPathfinder)return this._movingByPathfinder=!1,void(this._pathfindStartFunction=()=>this.tryStartPathfind(t.gridPosition));this._pathfindStartFunction=()=>this.tryStartPathfind(t.gridPosition)}tryStartPathfind(t){this._movingByPathfinder||(this._pathfindStartFunction=null,this._findedPath=this._pathfinder.findPath(this.positionInGrid,t),!this._findedPath||this._findedPath.length<=1||(this._findedPath.forEach((t=>{t.x=t.x*this._gridCellWidth+this._gridCenter.x,t.y=t.y*this._gridCellHeight+this._gridCenter.y})),this._currentPathIndex=1,this.isMoving=!0,this._movingByPathfinder=!0))}addOnMoveToTargetEventListener(t){this._onMoveToTargetDelegates.push(t)}removeOnMoveToTargetEventListener(t){const e=this._onMoveToTargetDelegates.indexOf(t);e>=0&&this._onMoveToTargetDelegates.splice(e,1)}addOnMovedToTargetEventListener(t){this._onMovedToTargetDelegates.push(t)}removeOnMovedToTargetEventListener(t){const e=this._onMovedToTargetDelegates.indexOf(t);e>=0&&this._onMovedToTargetDelegates.splice(e,1)}get speed(){return this._speed}set speed(t){this._speed=t}get gridCenter(){return this._gridCenter.clone()}set gridCenter(t){this._gridCenter.copy(t)}get gridCellHeight(){return this._gridCellHeight}set gridCellHeight(t){this._gridCellHeight=t}get gridCellWidth(){return this._gridCellWidth}set gridCellWidth(t){this._gridCellWidth=t}set initPosition(t){this._initPosition.copy(t)}set gridPointer(t){this._gridPointer&&this._gridPointer.removeOnPointerDownEventListener(this._onPointerDownBind),this._gridPointer=t,this._gridPointer&&this._gridPointer.addOnPointerDownEventListener(this._onPointerDownBind)}get gridPointer(){return this._gridPointer}addCollideMap(t){var e;this._collideMaps.push(t),null===(e=this._pathfinder)||void 0===e||e.addCollideMap(t)}setGridInfoFromCollideMap(t){this._gridCellWidth=t.gridCellWidth,this._gridCellHeight=t.gridCellHeight,this._gridCenter.set(t.gridCenterX,t.gridCenterY)}get positionInGrid(){return new Z(Math.floor(this.transform.localPosition.x/this._gridCellWidth),Math.floor(this.transform.localPosition.y/this._gridCellHeight))}}class Md extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this.requiredComponents=[Cd],this._trackTarget=null,this._targetOffset=new Z,this._cameraDistanceOffset=200,this._pixelPerfectUnit=1,this._pixelPerfect=!1,this._lerpTrack=!1,this._lerpAlpha=.1,this._tempVector=new pt}start(){if(this._trackTarget){const t=this._tempVector.copy(this._trackTarget.transform.position);t.z+=this._cameraDistanceOffset,this.transform.position.copy(t)}}update(){const t=this._tempVector.copy(this._trackTarget.transform.position);t.z+=this._cameraDistanceOffset,t.x+=this._targetOffset.x,t.y+=this._targetOffset.y;const e=this.transform;this._lerpTrack?e.position.lerp(t,.1):e.position.copy(t),this._pixelPerfect&&(e.localPosition.x=Math.round(e.localPosition.x/this._pixelPerfectUnit)*this._pixelPerfectUnit,e.localPosition.y=Math.round(e.localPosition.y/this._pixelPerfectUnit)*this._pixelPerfectUnit)}setTrackTarget(t){this._trackTarget=t}get targetOffset(){return this._targetOffset}set targetOffset(t){this._targetOffset.copy(t)}get cameraDistanceOffset(){return this._cameraDistanceOffset}set cameraDistanceOffset(t){this._cameraDistanceOffset=t}get pixelPerfectUnit(){return this._pixelPerfectUnit}set pixelPerfectUnit(t){this._pixelPerfectUnit=t}get pixelPerfect(){return this._pixelPerfect}set pixelPerfect(t){this._pixelPerfect=t}get lerpTrack(){return this._lerpTrack}set lerpTrack(t){this._lerpTrack=t}get lerpAlpha(){return this._lerpAlpha}set lerpAlpha(t){this._lerpAlpha=t}}class Vd extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._css3DObject=null,this._htmlDivElement=null,this._centerOffset=new Z(0,0),this._zindex=0,this._elementWidth=16,this._elementHeight=16,this._autoSize=!1,this._pointerEvents=!0,this._initializeFunction=null,this._awaked=!1}awake(){var t;this._awaked=!0,null===(t=this._initializeFunction)||void 0===t||t.call(this),this._htmlDivElement||this.setElement(Vd._defaultElement)}start(){this._css3DObject&&(this.enabled&&this.gameObject.activeInHierarchy?this._css3DObject.visible=!0:this._css3DObject.visible=!1),fd.checkAncestorZaxisInitializer(this.gameObject,this.onSortByZaxis.bind(this))}onDestroy(){this._css3DObject&&this.transform.unsafeGetObject3D().remove(this._css3DObject)}onEnable(){this._css3DObject&&(this._css3DObject.visible=!0,this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}onDisable(){this._css3DObject&&(this._css3DObject.visible=!1,this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}onSortByZaxis(t){this._zindex=t,this._css3DObject&&(this._css3DObject.element.style.zIndex=Math.floor(this._zindex).toString())}onWorldMatrixUpdated(){this._css3DObject&&(Al.updateRawObject3DWorldMatrixRecursively(this._css3DObject),this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}getElementContainer(){return this._htmlDivElement}setElement(t){this._awaked?(t||(t=Vd._defaultElement),this._htmlDivElement||(this._htmlDivElement=document.createElement("div")),this._htmlDivElement=t,this._css3DObject||(this._css3DObject=new dd(this._htmlDivElement),0===this._elementWidth&&(this._elementWidth=this._htmlDivElement.offsetWidth),0===this._elementHeight&&(this._elementHeight=this._htmlDivElement.offsetHeight),this._autoSize?(this._htmlDivElement.style.width="auto",this._htmlDivElement.style.height="auto"):(this._htmlDivElement.style.width=this._elementWidth+"px",this._htmlDivElement.style.height=this._elementHeight+"px"),this._htmlDivElement.style.pointerEvents=this._pointerEvents?"auto":"none",this._htmlDivElement.style.zIndex=Math.floor(this._zindex).toString(),this._css3DObject.onAfterRender=()=>{this.updateCenterOffset(),this._css3DObject&&(this._css3DObject.onAfterRender=()=>{})},this.transform.unsafeGetObject3D().add(this._css3DObject),this.enabled&&this.gameObject.activeInHierarchy?this._css3DObject.visible=!0:this._css3DObject.visible=!1,this.transform.enqueueRenderAttachedObject3D(this._css3DObject))):this._initializeFunction=()=>{this.setElement(t)}}updateCenterOffset(){if(this._css3DObject){const t=this._css3DObject.element.style.display;this._css3DObject.element.style.display="",this._css3DObject.position.set(this._htmlDivElement.offsetWidth*this._centerOffset.x,this._htmlDivElement.offsetHeight*this._centerOffset.y,0),this._css3DObject.element.style.display=t,Al.updateRawObject3DWorldMatrixRecursively(this._css3DObject),this.transform.enqueueRenderAttachedObject3D(this._css3DObject)}}get centerOffset(){return this._centerOffset.clone()}set centerOffset(t){this._centerOffset.copy(t),this.updateCenterOffset()}get elementWidth(){return this._elementWidth}set elementWidth(t){this._elementWidth=t,this._htmlDivElement&&(this._htmlDivElement.style.width=t+"px"),this.updateCenterOffset()}get elementHeight(){return this._elementHeight}set elementHeight(t){this._elementHeight=t,this._htmlDivElement&&(this._htmlDivElement.style.height=t+"px"),this.updateCenterOffset()}get autoSize(){return this._autoSize}set autoSize(t){this._autoSize=t,this._htmlDivElement&&(t?(this._htmlDivElement.style.width="auto",this._htmlDivElement.style.height="auto"):(this._htmlDivElement.style.width=this._elementWidth+"px",this._htmlDivElement.style.height=this._elementHeight+"px"))}get pointerEvents(){return this._pointerEvents}set pointerEvents(t){this._pointerEvents=t,this._htmlDivElement&&(this._htmlDivElement.style.pointerEvents=t?"auto":"none")}}Vd._defaultElement=document.createElement("div");class Td extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this.requiredComponents=[Cd],this._cssHtmlRenderer=null,this._cssHtmlRendererObject=null,this._gridCellWidth=16,this._gridCellHeight=16,this._renderWidth=180,this._renderHeight=100,this._lineWidth=.2,this._lastPosition=new pt(NaN,NaN,NaN)}awake(){const t=new Ul;this._cssHtmlRendererObject=this.gameObject.addChildFromBuilder(this.engine.instantiater.buildGameObject("grid-renderer",new pt(0,0,-1),void 0,new pt(this._lineWidth,this._lineWidth,this._lineWidth)).active(!1).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundImage="                        repeating-linear-gradient(#999 0 1px, transparent 1px 100%),                        repeating-linear-gradient(90deg, #999 0 1px, transparent 1px 100%)",e.style.backgroundSize=this.gridCellWidth/this._lineWidth+"px "+this.gridCellHeight/this._lineWidth+"px",t.elementWidth=this._renderWidth/this._lineWidth,t.elementHeight=this._renderHeight/this._lineWidth,t.pointerEvents=!1,t.setElement(e)})).getComponent(Vd,t)),this._cssHtmlRenderer=t.ref}onEnable(){this._cssHtmlRendererObject.activeSelf=!0}onDisable(){this._cssHtmlRendererObject.activeSelf=!1}update(){const t=this.transform.position,e=this._renderWidth/this._lineWidth/2,i=this._renderHeight/this._lineWidth/2,s=this._gridCellWidth/this._lineWidth,n=this._gridCellHeight/this._lineWidth,r=e%s,o=i%n;t.equals(this._lastPosition)||(this._cssHtmlRenderer.getElementContainer().style.backgroundPosition=-t.x/this._lineWidth+r+s/2-.5+"px "+(t.y/this._lineWidth+o+n/2-.5)+"px")}onDestroy(){this._cssHtmlRendererObject.destroy()}get gridCellWidth(){return this._gridCellWidth}set gridCellWidth(t){this._gridCellWidth=t}get gridCellHeight(){return this._gridCellHeight}set gridCellHeight(t){this._gridCellHeight=t}get renderWidth(){return this._renderWidth}set renderWidth(t){this._renderWidth=t}get renderHeight(){return this._renderHeight}set renderHeight(t){this._renderHeight=t}get lineWidth(){return this._lineWidth}set lineWidth(t){this._lineWidth=t}}!function(t){t.Left="left",t.Center="center",t.Right="right"}(wd||(wd={})),function(t){t.Normal="normal",t.Bold="bold"}(bd||(bd={}));class Pd extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._css3DObject=null,this._htmlDivElement=null,this._textCenterOffset=new Z(0,0),this._zindex=0,this._textWidth=32,this._textHeight=16,this._fontSize=8,this._fontWeight=bd.Normal,this._fontFamily="Arial",this._textalign=wd.Left,this._opacity=1,this._pointerEvents=!0,this._awaked=!1,this._initializeFunction=null}awake(){var t;this._awaked=!0,null===(t=this._initializeFunction)||void 0===t||t.call(this),this._htmlDivElement||(this.text=Pd._defaultText)}start(){this._css3DObject&&(this.enabled&&this.gameObject.activeInHierarchy?this._css3DObject.visible=!0:this._css3DObject.visible=!1),fd.checkAncestorZaxisInitializer(this.gameObject,this.onSortByZaxis.bind(this))}onEnable(){this._css3DObject&&(this._css3DObject.visible=!0,this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}onDisable(){this._css3DObject&&(this._css3DObject.visible=!1,this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}onDestroy(){this._css3DObject&&this.transform.unsafeGetObject3D().remove(this._css3DObject)}onSortByZaxis(t){this._zindex=t,this._css3DObject&&(this._css3DObject.element.style.zIndex=Math.floor(this._zindex).toString())}onWorldMatrixUpdated(){this._css3DObject&&(Al.updateRawObject3DWorldMatrixRecursively(this._css3DObject),this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}get text(){var t;return(null===(t=this._htmlDivElement)||void 0===t?void 0:t.textContent)||null}set text(t){this._awaked?(t||(t=Pd._defaultText),this._htmlDivElement||(this._htmlDivElement=document.createElement("div")),this._htmlDivElement.textContent=t,this._css3DObject||(this._css3DObject=new dd(this._htmlDivElement),0===this._textWidth&&(this._textWidth=this._htmlDivElement.offsetWidth),0===this._textHeight&&(this._textHeight=this._htmlDivElement.offsetHeight),this._htmlDivElement.style.width=this._textWidth+"px",this._htmlDivElement.style.height=this._textHeight+"px",this._htmlDivElement.style.fontSize=this._fontSize+"px",this._htmlDivElement.style.fontWeight=this._fontWeight,this._htmlDivElement.style.fontFamily=this._fontFamily,this._htmlDivElement.style.textAlign=this._textalign,this._htmlDivElement.style.opacity=this._opacity.toString(),this._htmlDivElement.style.pointerEvents=this._pointerEvents?"auto":"none",this._htmlDivElement.style.zIndex=Math.floor(this._zindex).toString(),this.updateCenterOffset(),this.transform.unsafeGetObject3D().add(this._css3DObject),this.enabled&&this.gameObject.activeInHierarchy?this._css3DObject.visible=!0:this._css3DObject.visible=!1,Al.updateRawObject3DWorldMatrixRecursively(this._css3DObject),this.transform.enqueueRenderAttachedObject3D(this._css3DObject))):this._initializeFunction=()=>{this.text=t}}updateCenterOffset(){this._css3DObject&&(this._css3DObject.position.set(this._htmlDivElement.offsetWidth*this._textCenterOffset.x,this._htmlDivElement.offsetHeight*this._textCenterOffset.y,0),Al.updateRawObject3DWorldMatrixRecursively(this._css3DObject),this.transform.enqueueRenderAttachedObject3D(this._css3DObject))}get textCenterOffset(){return this._textCenterOffset.clone()}set textCenterOffset(t){this._textCenterOffset.copy(t),this.updateCenterOffset()}get textWidth(){return this._textWidth}set textWidth(t){this._textWidth=t,this._htmlDivElement&&(this._htmlDivElement.style.width=t+"px"),this.updateCenterOffset()}get textHeight(){return this._textHeight}set textHeight(t){this._textHeight=t,this._css3DObject&&(this._css3DObject.element.style.height=t+"px"),this.updateCenterOffset()}get fontSize(){return this._fontSize}set fontSize(t){this._fontSize=t,this._htmlDivElement&&(this._htmlDivElement.style.fontSize=t+"px")}get fontWeight(){return this._fontWeight}set fontWeight(t){this._fontWeight=t,this._htmlDivElement&&(this._htmlDivElement.style.fontWeight=t)}get fontFamily(){return this._fontFamily}set fontFamily(t){this._fontFamily=t,this._htmlDivElement&&(this._htmlDivElement.style.fontFamily=t)}get textAlign(){return this._textalign}set textAlign(t){this._textalign=t,this._htmlDivElement&&(this._htmlDivElement.style.textAlign=t)}get opacity(){return this._opacity}set opacity(t){this._opacity=t,this._htmlDivElement&&(this._htmlDivElement.style.opacity=t.toString())}get pointerEvents(){return this._pointerEvents}set pointerEvents(t){this._pointerEvents=t,this._htmlDivElement&&(this._htmlDivElement.style.pointerEvents=t?"auto":"none")}}function Dd(t,e){return void 0!==t?t:e}Pd._defaultText="Text";const Id=1e37,Ed=1e-5,Rd=1.0000000000000002e-10,Ld=3.14159265359,Gd=.005,Fd=.03490658503988889,kd=.01,zd=.13962634015955555,Od=1.570796326795,Nd=2.4674011002726646,Ud=-1;function Wd(t,e){const i=new Array(t);for(let s=0;s<t;++s)i[s]=e(s);return i}function jd(t,e=0){const i=new Array(t);for(let s=0;s<t;++s)i[s]=e;return i}new class{constructor(t=0,e=0,i=0){this.major=0,this.minor=0,this.revision=0,this.major=t,this.minor=e,this.revision=i}toString(){return this.major+"."+this.minor+"."+this.revision}}(2,4,1);const Hd=6.28318530718,qd=Math.abs;function Xd(t,e){return t<e?t:e}function Jd(t,e){return t>e?t:e}function Zd(t,e,i){return t<e?e:t>i?i:t}function Yd(t){return t*t}function Qd(t){return 1/Math.sqrt(t)}isFinite;const Kd=Math.sqrt,$d=Math.pow;Math.cos,Math.sin,Math.acos;const tp=Math.asin;Math.atan2;class ep{constructor(t=0,e=0){this.x=t,this.y=e}Clone(){return new ep(this.x,this.y)}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return this.x=t.x,this.y=t.y,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=Ed){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=Ed){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.x;return this.x=e*s-i*this.y,this.y=i*s+e*this.y,this}SelfRotateCosSin(t,e){const i=this.x;return this.x=t*i-e*this.y,this.y=e*i+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=Xd(this.x,t.x),this.y=Xd(this.y,t.y),this}SelfMaxV(t){return this.x=Jd(this.x,t.x),this.y=Jd(this.y,t.y),this}SelfAbs(){return this.x=qd(this.x),this.y=qd(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}static MakeArray(t){return Wd(t,(t=>new ep))}static AbsV(t,e){return e.x=qd(t.x),e.y=qd(t.y),e}static MinV(t,e,i){return i.x=Xd(t.x,e.x),i.y=Xd(t.y,e.y),i}static MaxV(t,e,i){return i.x=Jd(t.x,e.x),i.y=Jd(t.y,e.y),i}static ClampV(t,e,i,s){return s.x=Zd(t.x,e.x,i.x),s.y=Zd(t.y,e.y,i.y),s}static RotateV(t,e,i){const s=t.x,n=t.y,r=Math.cos(e),o=Math.sin(e);return i.x=r*s-o*n,i.y=o*s+r*n,i}static DotVV(t,e){return t.x*e.x+t.y*e.y}static CrossVV(t,e){return t.x*e.y-t.y*e.x}static CrossVS(t,e,i){const s=t.x;return i.x=e*t.y,i.y=-e*s,i}static CrossVOne(t,e){const i=t.x;return e.x=t.y,e.y=-i,e}static CrossSV(t,e,i){const s=e.x;return i.x=-t*e.y,i.y=t*s,i}static CrossOneV(t,e){const i=t.x;return e.x=-t.y,e.y=i,e}static AddVV(t,e,i){return i.x=t.x+e.x,i.y=t.y+e.y,i}static SubVV(t,e,i){return i.x=t.x-e.x,i.y=t.y-e.y,i}static MulSV(t,e,i){return i.x=e.x*t,i.y=e.y*t,i}static MulVS(t,e,i){return i.x=t.x*e,i.y=t.y*e,i}static AddVMulSV(t,e,i,s){return s.x=t.x+e*i.x,s.y=t.y+e*i.y,s}static SubVMulSV(t,e,i,s){return s.x=t.x-e*i.x,s.y=t.y-e*i.y,s}static AddVCrossSV(t,e,i,s){const n=i.x;return s.x=t.x-e*i.y,s.y=t.y+e*n,s}static MidVV(t,e,i){return i.x=.5*(t.x+e.x),i.y=.5*(t.y+e.y),i}static ExtVV(t,e,i){return i.x=.5*(e.x-t.x),i.y=.5*(e.y-t.y),i}static IsEqualToV(t,e){return t.x===e.x&&t.y===e.y}static DistanceVV(t,e){const i=t.x-e.x,s=t.y-e.y;return Math.sqrt(i*i+s*s)}static DistanceSquaredVV(t,e){const i=t.x-e.x,s=t.y-e.y;return i*i+s*s}static NegV(t,e){return e.x=-t.x,e.y=-t.y,e}}ep.ZERO=new ep(0,0),ep.UNITX=new ep(1,0),ep.UNITY=new ep(0,1),ep.s_t0=new ep,ep.s_t1=new ep,ep.s_t2=new ep,ep.s_t3=new ep,new ep(0,0);class ip{constructor(...t){if(t[0]instanceof Float32Array){if(2!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,i="number"==typeof t[1]?t[1]:0;this.data=new Float32Array([e,i])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}Clone(){return new ip(new Float32Array(this.data))}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return t instanceof ip?this.data.set(t.data):(this.x=t.x,this.y=t.y),this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=Ed){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=Ed){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.x;return this.x=e*s-i*this.y,this.y=i*s+e*this.y,this}SelfRotateCosSin(t,e){const i=this.x;return this.x=t*i-e*this.y,this.y=e*i+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=Xd(this.x,t.x),this.y=Xd(this.y,t.y),this}SelfMaxV(t){return this.x=Jd(this.x,t.x),this.y=Jd(this.y,t.y),this}SelfAbs(){return this.x=qd(this.x),this.y=qd(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}}class sp{constructor(...t){if(t[0]instanceof Float32Array){if(3!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,i="number"==typeof t[1]?t[1]:0,s="number"==typeof t[2]?t[2]:0;this.data=new Float32Array([e,i,s])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}get z(){return this.data[2]}set z(t){this.data[2]=t}Clone(){return new sp(this.x,this.y,this.z)}SetZero(){return this.x=0,this.y=0,this.z=0,this}SetXYZ(t,e,i){return this.x=t,this.y=e,this.z=i,this}Copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}SelfAddXYZ(t,e,i){return this.x+=t,this.y+=e,this.z+=i,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}SelfSubXYZ(t,e,i){return this.x-=t,this.y-=e,this.z-=i,this}SelfMul(t){return this.x*=t,this.y*=t,this.z*=t,this}static DotV3V3(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossV3V3(t,e,i){const s=t.x,n=t.y,r=t.z,o=e.x,a=e.y,l=e.z;return i.x=n*l-r*a,i.y=r*o-s*l,i.z=s*a-n*o,i}}sp.ZERO=new sp(0,0,0),sp.s_t0=new sp;class np{constructor(){this.ex=new ep(1,0),this.ey=new ep(0,1)}Clone(){return(new np).Copy(this)}static FromVV(t,e){return(new np).SetVV(t,e)}static FromSSSS(t,e,i,s){return(new np).SetSSSS(t,e,i,s)}static FromAngle(t){return(new np).SetAngle(t)}SetSSSS(t,e,i,s){return this.ex.Set(t,i),this.ey.Set(e,s),this}SetVV(t,e){return this.ex.Copy(t),this.ey.Copy(e),this}SetAngle(t){const e=Math.cos(t),i=Math.sin(t);return this.ex.Set(e,i),this.ey.Set(-i,e),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this}SetIdentity(){return this.ex.Set(1,0),this.ey.Set(0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this}GetAngle(){return Math.atan2(this.ex.y,this.ex.x)}GetInverse(t){const e=this.ex.x,i=this.ey.x,s=this.ex.y,n=this.ey.y;let r=e*n-i*s;return 0!==r&&(r=1/r),t.ex.x=r*n,t.ey.x=-r*i,t.ex.y=-r*s,t.ey.y=r*e,t}Solve(t,e,i){const s=this.ex.x,n=this.ey.x,r=this.ex.y,o=this.ey.y;let a=s*o-n*r;return 0!==a&&(a=1/a),i.x=a*(o*t-n*e),i.y=a*(s*e-r*t),i}SelfAbs(){return this.ex.SelfAbs(),this.ey.SelfAbs(),this}SelfInv(){return this.GetInverse(this),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this}SelfSubM(t){return this.ex.SelfSub(t.ex),this.ey.SelfSub(t.ey),this}static AbsM(t,e){const i=t.ex,s=t.ey;return e.ex.x=qd(i.x),e.ex.y=qd(i.y),e.ey.x=qd(s.x),e.ey.y=qd(s.y),e}static MulMV(t,e,i){const s=t.ex,n=t.ey,r=e.x,o=e.y;return i.x=s.x*r+n.x*o,i.y=s.y*r+n.y*o,i}static MulTMV(t,e,i){const s=t.ex,n=t.ey,r=e.x,o=e.y;return i.x=s.x*r+s.y*o,i.y=n.x*r+n.y*o,i}static AddMM(t,e,i){const s=t.ex,n=t.ey,r=e.ex,o=e.ey;return i.ex.x=s.x+r.x,i.ex.y=s.y+r.y,i.ey.x=n.x+o.x,i.ey.y=n.y+o.y,i}static MulMM(t,e,i){const s=t.ex.x,n=t.ex.y,r=t.ey.x,o=t.ey.y,a=e.ex.x,l=e.ex.y,h=e.ey.x,c=e.ey.y;return i.ex.x=s*a+r*l,i.ex.y=n*a+o*l,i.ey.x=s*h+r*c,i.ey.y=n*h+o*c,i}static MulTMM(t,e,i){const s=t.ex.x,n=t.ex.y,r=t.ey.x,o=t.ey.y,a=e.ex.x,l=e.ex.y,h=e.ey.x,c=e.ey.y;return i.ex.x=s*a+n*l,i.ex.y=r*a+o*l,i.ey.x=s*h+n*c,i.ey.y=r*h+o*c,i}}np.IDENTITY=new np;class rp{constructor(){this.data=new Float32Array([1,0,0,0,1,0,0,0,1]),this.ex=new sp(this.data.subarray(0,3)),this.ey=new sp(this.data.subarray(3,6)),this.ez=new sp(this.data.subarray(6,9))}Clone(){return(new rp).Copy(this)}SetVVV(t,e,i){return this.ex.Copy(t),this.ey.Copy(e),this.ez.Copy(i),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this.ez.Copy(t.ez),this}SetIdentity(){return this.ex.SetXYZ(1,0,0),this.ey.SetXYZ(0,1,0),this.ez.SetXYZ(0,0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this.ez.SetZero(),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this.ez.SelfAdd(t.ez),this}Solve33(t,e,i,s){const n=this.ex.x,r=this.ex.y,o=this.ex.z,a=this.ey.x,l=this.ey.y,h=this.ey.z,c=this.ez.x,m=this.ez.y,u=this.ez.z;let _=n*(l*u-h*m)+r*(h*c-a*u)+o*(a*m-l*c);return 0!==_&&(_=1/_),s.x=_*(t*(l*u-h*m)+e*(h*c-a*u)+i*(a*m-l*c)),s.y=_*(n*(e*u-i*m)+r*(i*c-t*u)+o*(t*m-e*c)),s.z=_*(n*(l*i-h*e)+r*(h*t-a*i)+o*(a*e-l*t)),s}Solve22(t,e,i){const s=this.ex.x,n=this.ey.x,r=this.ex.y,o=this.ey.y;let a=s*o-n*r;return 0!==a&&(a=1/a),i.x=a*(o*t-n*e),i.y=a*(s*e-r*t),i}GetInverse22(t){const e=this.ex.x,i=this.ey.x,s=this.ex.y,n=this.ey.y;let r=e*n-i*s;0!==r&&(r=1/r),t.ex.x=r*n,t.ey.x=-r*i,t.ex.z=0,t.ex.y=-r*s,t.ey.y=r*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}GetSymInverse33(t){let e=sp.DotV3V3(this.ex,sp.CrossV3V3(this.ey,this.ez,sp.s_t0));0!==e&&(e=1/e);const i=this.ex.x,s=this.ey.x,n=this.ez.x,r=this.ey.y,o=this.ez.y,a=this.ez.z;t.ex.x=e*(r*a-o*o),t.ex.y=e*(n*o-s*a),t.ex.z=e*(s*o-n*r),t.ey.x=t.ex.y,t.ey.y=e*(i*a-n*n),t.ey.z=e*(n*s-i*o),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(i*r-s*s)}static MulM33V3(t,e,i){const s=e.x,n=e.y,r=e.z;return i.x=t.ex.x*s+t.ey.x*n+t.ez.x*r,i.y=t.ex.y*s+t.ey.y*n+t.ez.y*r,i.z=t.ex.z*s+t.ey.z*n+t.ez.z*r,i}static MulM33XYZ(t,e,i,s,n){return n.x=t.ex.x*e+t.ey.x*i+t.ez.x*s,n.y=t.ex.y*e+t.ey.y*i+t.ez.y*s,n.z=t.ex.z*e+t.ey.z*i+t.ez.z*s,n}static MulM33V2(t,e,i){const s=e.x,n=e.y;return i.x=t.ex.x*s+t.ey.x*n,i.y=t.ex.y*s+t.ey.y*n,i}static MulM33XY(t,e,i,s){return s.x=t.ex.x*e+t.ey.x*i,s.y=t.ex.y*e+t.ey.y*i,s}}rp.IDENTITY=new rp;class op{constructor(t=0){this.s=0,this.c=1,t&&(this.s=Math.sin(t),this.c=Math.cos(t))}Clone(){return(new op).Copy(this)}Copy(t){return this.s=t.s,this.c=t.c,this}SetAngle(t){return this.s=Math.sin(t),this.c=Math.cos(t),this}SetIdentity(){return this.s=0,this.c=1,this}GetAngle(){return Math.atan2(this.s,this.c)}GetXAxis(t){return t.x=this.c,t.y=this.s,t}GetYAxis(t){return t.x=-this.s,t.y=this.c,t}static MulRR(t,e,i){const s=t.c,n=t.s,r=e.c,o=e.s;return i.s=n*r+s*o,i.c=s*r-n*o,i}static MulTRR(t,e,i){const s=t.c,n=t.s,r=e.c,o=e.s;return i.s=s*o-n*r,i.c=s*r+n*o,i}static MulRV(t,e,i){const s=t.c,n=t.s,r=e.x,o=e.y;return i.x=s*r-n*o,i.y=n*r+s*o,i}static MulTRV(t,e,i){const s=t.c,n=t.s,r=e.x,o=e.y;return i.x=s*r+n*o,i.y=-n*r+s*o,i}}op.IDENTITY=new op;class ap{constructor(){this.p=new ep,this.q=new op}Clone(){return(new ap).Copy(this)}Copy(t){return this.p.Copy(t.p),this.q.Copy(t.q),this}SetIdentity(){return this.p.SetZero(),this.q.SetIdentity(),this}SetPositionRotation(t,e){return this.p.Copy(t),this.q.Copy(e),this}SetPositionAngle(t,e){return this.p.Copy(t),this.q.SetAngle(e),this}SetPosition(t){return this.p.Copy(t),this}SetPositionXY(t,e){return this.p.Set(t,e),this}SetRotation(t){return this.q.Copy(t),this}SetRotationAngle(t){return this.q.SetAngle(t),this}GetPosition(){return this.p}GetRotation(){return this.q}GetRotationAngle(){return this.q.GetAngle()}GetAngle(){return this.q.GetAngle()}static MulXV(t,e,i){const s=t.q.c,n=t.q.s,r=e.x,o=e.y;return i.x=s*r-n*o+t.p.x,i.y=n*r+s*o+t.p.y,i}static MulTXV(t,e,i){const s=t.q.c,n=t.q.s,r=e.x-t.p.x,o=e.y-t.p.y;return i.x=s*r+n*o,i.y=-n*r+s*o,i}static MulXX(t,e,i){return op.MulRR(t.q,e.q,i.q),ep.AddVV(op.MulRV(t.q,e.p,i.p),t.p,i.p),i}static MulTXX(t,e,i){return op.MulTRR(t.q,e.q,i.q),op.MulTRV(t.q,ep.SubVV(e.p,t.p,i.p),i.p),i}}ap.IDENTITY=new ap;class lp{constructor(){this.localCenter=new ep,this.c0=new ep,this.c=new ep,this.a0=0,this.a=0,this.alpha0=0}Clone(){return(new lp).Copy(this)}Copy(t){return this.localCenter.Copy(t.localCenter),this.c0.Copy(t.c0),this.c.Copy(t.c),this.a0=t.a0,this.a=t.a,this.alpha0=t.alpha0,this}GetTransform(t,e){t.p.x=(1-e)*this.c0.x+e*this.c.x,t.p.y=(1-e)*this.c0.y+e*this.c.y;const i=(1-e)*this.a0+e*this.a;return t.q.SetAngle(i),t.p.SelfSub(op.MulRV(t.q,this.localCenter,ep.s_t0)),t}Advance(t){const e=(t-this.alpha0)/(1-this.alpha0),i=1-e;this.c0.x=i*this.c0.x+e*this.c.x,this.c0.y=i*this.c0.y+e*this.c.y,this.a0=i*this.a0+e*this.a,this.alpha0=t}Normalize(){const t=Hd*Math.floor(this.a0/Hd);this.a0-=t,this.a-=t}}class hp{constructor(t=.5,e=.5,i=.5,s=1){this.r=t,this.g=e,this.b=i,this.a=s}Clone(){return(new hp).Copy(this)}Copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,i,s=this.a){this.SetRGBA(t,e,i,s)}SetByteRGB(t,e,i){return this.r=t/255,this.g=e/255,this.b=i/255,this}SetByteRGBA(t,e,i,s){return this.r=t/255,this.g=e/255,this.b=i/255,this.a=s/255,this}SetRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}SetRGBA(t,e,i,s){return this.r=t,this.g=e,this.b=i,this.a=s,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){hp.MixColors(this,t,e)}static MixColors(t,e,i){const s=i*(e.r-t.r),n=i*(e.g-t.g),r=i*(e.b-t.b),o=i*(e.a-t.a);t.r+=s,t.g+=n,t.b+=r,t.a+=o,e.r-=s,e.g-=n,e.b-=r,e.a-=o}MakeStyleString(t=this.a){return hp.MakeStyleString(this.r,this.g,this.b,t)}static MakeStyleString(t,e,i,s=1){return t*=255,e*=255,i*=255,s<1?`rgba(${t},${e},${i},${s})`:`rgb(${t},${e},${i})`}}hp.ZERO=new hp(0,0,0,0),hp.RED=new hp(1,0,0),hp.GREEN=new hp(0,1,0),hp.BLUE=new hp(0,0,1);class cp{constructor(...t){if(t[0]instanceof Float32Array){if(4!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:.5,i="number"==typeof t[1]?t[1]:.5,s="number"==typeof t[2]?t[2]:.5,n="number"==typeof t[3]?t[3]:1;this.data=new Float32Array([e,i,s,n])}}get r(){return this.data[0]}set r(t){this.data[0]=t}get g(){return this.data[1]}set g(t){this.data[1]=t}get b(){return this.data[2]}set b(t){this.data[2]=t}get a(){return this.data[3]}set a(t){this.data[3]=t}Clone(){return new cp(new Float32Array(this.data))}Copy(t){return t instanceof cp?this.data.set(t.data):(this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a),this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,i,s=this.a){this.SetRGBA(t,e,i,s)}SetByteRGB(t,e,i){return this.r=t/255,this.g=e/255,this.b=i/255,this}SetByteRGBA(t,e,i,s){return this.r=t/255,this.g=e/255,this.b=i/255,this.a=s/255,this}SetRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}SetRGBA(t,e,i,s){return this.r=t,this.g=e,this.b=i,this.a=s,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){hp.MixColors(this,t,e)}MakeStyleString(t=this.a){return hp.MakeStyleString(this.r,this.g,this.b,t)}}var mp;!function(t){t[t.e_none=0]="e_none",t[t.e_shapeBit=1]="e_shapeBit",t[t.e_jointBit=2]="e_jointBit",t[t.e_aabbBit=4]="e_aabbBit",t[t.e_pairBit=8]="e_pairBit",t[t.e_centerOfMassBit=16]="e_centerOfMassBit",t[t.e_particleBit=32]="e_particleBit",t[t.e_controllerBit=64]="e_controllerBit",t[t.e_all=63]="e_all"}(mp||(mp={}));class up{constructor(t){this.m_stack=[],this.m_count=0,this.m_stack=Wd(t,(t=>null)),this.m_count=0}Reset(){return this.m_count=0,this}Push(t){this.m_stack[this.m_count]=t,this.m_count++}Pop(){this.m_count--;const t=this.m_stack[this.m_count];return this.m_stack[this.m_count]=null,t}GetCount(){return this.m_count}}class _p{constructor(){this.m_buffer=ep.MakeArray(2),this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0}Copy(t){return t.m_vertices===t.m_buffer?(this.m_vertices=this.m_buffer,this.m_buffer[0].Copy(t.m_buffer[0]),this.m_buffer[1].Copy(t.m_buffer[1])):this.m_vertices=t.m_vertices,this.m_count=t.m_count,this.m_radius=t.m_radius,this}Reset(){return this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0,this}SetShape(t,e){t.SetupDistanceProxy(this,e)}SetVerticesRadius(t,e,i){this.m_vertices=t,this.m_count=e,this.m_radius=i}GetSupport(t){let e=0,i=ep.DotVV(this.m_vertices[0],t);for(let s=1;s<this.m_count;++s){const n=ep.DotVV(this.m_vertices[s],t);n>i&&(e=s,i=n)}return e}GetSupportVertex(t){let e=0,i=ep.DotVV(this.m_vertices[0],t);for(let s=1;s<this.m_count;++s){const n=ep.DotVV(this.m_vertices[s],t);n>i&&(e=s,i=n)}return this.m_vertices[e]}GetVertexCount(){return this.m_count}GetVertex(t){return this.m_vertices[t]}}class dp{constructor(){this.metric=0,this.count=0,this.indexA=[0,0,0],this.indexB=[0,0,0]}Reset(){return this.metric=0,this.count=0,this}}class pp{constructor(){this.proxyA=new _p,this.proxyB=new _p,this.transformA=new ap,this.transformB=new ap,this.useRadii=!1}Reset(){return this.proxyA.Reset(),this.proxyB.Reset(),this.transformA.SetIdentity(),this.transformB.SetIdentity(),this.useRadii=!1,this}}class fp{constructor(){this.pointA=new ep,this.pointB=new ep,this.distance=0,this.iterations=0}Reset(){return this.pointA.SetZero(),this.pointB.SetZero(),this.distance=0,this.iterations=0,this}}let yp=0;class gp{constructor(){this.wA=new ep,this.wB=new ep,this.w=new ep,this.a=0,this.indexA=0,this.indexB=0}Copy(t){return this.wA.Copy(t.wA),this.wB.Copy(t.wB),this.w.Copy(t.w),this.a=t.a,this.indexA=t.indexA,this.indexB=t.indexB,this}}class xp{constructor(){this.m_v1=new gp,this.m_v2=new gp,this.m_v3=new gp,this.m_vertices=[],this.m_count=0,this.m_vertices[0]=this.m_v1,this.m_vertices[1]=this.m_v2,this.m_vertices[2]=this.m_v3}ReadCache(t,e,i,s,n){this.m_count=t.count;const r=this.m_vertices;for(let o=0;o<this.m_count;++o){const a=r[o];a.indexA=t.indexA[o],a.indexB=t.indexB[o];const l=e.GetVertex(a.indexA),h=s.GetVertex(a.indexB);ap.MulXV(i,l,a.wA),ap.MulXV(n,h,a.wB),ep.SubVV(a.wB,a.wA,a.w),a.a=0}if(this.m_count>1){const e=t.metric,i=this.GetMetric();(i<.5*e||2*e<i||i<Ed)&&(this.m_count=0)}if(0===this.m_count){const t=r[0];t.indexA=0,t.indexB=0;const o=e.GetVertex(0),a=s.GetVertex(0);ap.MulXV(i,o,t.wA),ap.MulXV(n,a,t.wB),ep.SubVV(t.wB,t.wA,t.w),t.a=1,this.m_count=1}}WriteCache(t){t.metric=this.GetMetric(),t.count=this.m_count;const e=this.m_vertices;for(let i=0;i<this.m_count;++i)t.indexA[i]=e[i].indexA,t.indexB[i]=e[i].indexB}GetSearchDirection(t){switch(this.m_count){case 1:return ep.NegV(this.m_v1.w,t);case 2:{const e=ep.SubVV(this.m_v2.w,this.m_v1.w,t);return ep.CrossVV(e,ep.NegV(this.m_v1.w,ep.s_t0))>0?ep.CrossOneV(e,t):ep.CrossVOne(e,t)}default:return t.SetZero()}}GetClosestPoint(t){switch(this.m_count){case 0:case 3:default:return t.SetZero();case 1:return t.Copy(this.m_v1.w);case 2:return t.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y)}}GetWitnessPoints(t,e){switch(this.m_count){case 0:default:break;case 1:t.Copy(this.m_v1.wA),e.Copy(this.m_v1.wB);break;case 2:t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x,t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y,e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x,e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x,e.y=t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y}}GetMetric(){switch(this.m_count){case 0:case 1:default:return 0;case 2:return ep.DistanceVV(this.m_v1.w,this.m_v2.w);case 3:return ep.CrossVV(ep.SubVV(this.m_v2.w,this.m_v1.w,ep.s_t0),ep.SubVV(this.m_v3.w,this.m_v1.w,ep.s_t1))}}Solve2(){const t=this.m_v1.w,e=this.m_v2.w,i=ep.SubVV(e,t,xp.s_e12),s=-ep.DotVV(t,i);if(s<=0)return this.m_v1.a=1,void(this.m_count=1);const n=ep.DotVV(e,i);if(n<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);const r=1/(n+s);this.m_v1.a=n*r,this.m_v2.a=s*r,this.m_count=2}Solve3(){const t=this.m_v1.w,e=this.m_v2.w,i=this.m_v3.w,s=ep.SubVV(e,t,xp.s_e12),n=ep.DotVV(t,s),r=ep.DotVV(e,s),o=-n,a=ep.SubVV(i,t,xp.s_e13),l=ep.DotVV(t,a),h=ep.DotVV(i,a),c=-l,m=ep.SubVV(i,e,xp.s_e23),u=ep.DotVV(e,m),_=ep.DotVV(i,m),d=-u,p=ep.CrossVV(s,a),f=p*ep.CrossVV(e,i),y=p*ep.CrossVV(i,t),g=p*ep.CrossVV(t,e);if(o<=0&&c<=0)return this.m_v1.a=1,void(this.m_count=1);if(r>0&&o>0&&g<=0){const t=1/(r+o);return this.m_v1.a=r*t,this.m_v2.a=o*t,void(this.m_count=2)}if(h>0&&c>0&&y<=0){const t=1/(h+c);return this.m_v1.a=h*t,this.m_v3.a=c*t,this.m_count=2,void this.m_v2.Copy(this.m_v3)}if(r<=0&&d<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);if(h<=0&&_<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v3);if(_>0&&d>0&&f<=0){const t=1/(_+d);return this.m_v2.a=_*t,this.m_v3.a=d*t,this.m_count=2,void this.m_v1.Copy(this.m_v3)}const x=1/(f+y+g);this.m_v1.a=f*x,this.m_v2.a=y*x,this.m_v3.a=g*x,this.m_count=3}}xp.s_e12=new ep,xp.s_e13=new ep,xp.s_e23=new ep;const vp=new xp,Sp=[0,0,0],wp=[0,0,0],bp=new ep,Cp=new ep,Ap=new ep,Bp=new ep,Mp=new ep;function Vp(t,e,i){const s=i.proxyA,n=i.proxyB,r=i.transformA,o=i.transformB,a=vp;a.ReadCache(e,s,r,n,o);const l=a.m_vertices,h=Sp,c=wp;let m=0,u=0;for(;u<20;){m=a.m_count;for(let t=0;t<m;++t)h[t]=l[t].indexA,c[t]=l[t].indexB;switch(a.m_count){case 1:default:break;case 2:a.Solve2();break;case 3:a.Solve3()}if(3===a.m_count)break;const t=a.GetSearchDirection(Cp);if(t.LengthSquared()<Rd)break;const e=l[a.m_count];e.indexA=s.GetSupport(op.MulTRV(r.q,ep.NegV(t,ep.s_t0),Bp)),ap.MulXV(r,s.GetVertex(e.indexA),e.wA),e.indexB=n.GetSupport(op.MulTRV(o.q,t,Mp)),ap.MulXV(o,n.GetVertex(e.indexB),e.wB),ep.SubVV(e.wB,e.wA,e.w),++u;let i=!1;for(let t=0;t<m;++t)if(e.indexA===h[t]&&e.indexB===c[t]){i=!0;break}if(i)break;++a.m_count}if(yp=Jd(yp,u),a.GetWitnessPoints(t.pointA,t.pointB),t.distance=ep.DistanceVV(t.pointA,t.pointB),t.iterations=u,a.WriteCache(e),i.useRadii){const e=s.m_radius,i=n.m_radius;if(t.distance>e+i&&t.distance>Ed){t.distance-=e+i;const s=ep.SubVV(t.pointB,t.pointA,Ap);s.Normalize(),t.pointA.SelfMulAdd(e,s),t.pointB.SelfMulSub(i,s)}else{const e=ep.MidVV(t.pointA,t.pointB,bp);t.pointA.Copy(e),t.pointB.Copy(e),t.distance=0}}}var Tp,Pp,Dp;new ep,new xp,new ep,new ep,new ep,new ep,new ep,new ep,function(t){t[t.e_vertex=0]="e_vertex",t[t.e_face=1]="e_face"}(Tp||(Tp={}));class Ip{constructor(){this._key=0,this._key_invalid=!1,this._indexA=0,this._indexB=0,this._typeA=0,this._typeB=0}get key(){return this._key_invalid&&(this._key_invalid=!1,this._key=this._indexA|this._indexB<<8|this._typeA<<16|this._typeB<<24),this._key}set key(t){this._key=t,this._key_invalid=!1,this._indexA=255&this._key,this._indexB=this._key>>8&255,this._typeA=this._key>>16&255,this._typeB=this._key>>24&255}get indexA(){return this._indexA}set indexA(t){this._indexA=t,this._key_invalid=!0}get indexB(){return this._indexB}set indexB(t){this._indexB=t,this._key_invalid=!0}get typeA(){return this._typeA}set typeA(t){this._typeA=t,this._key_invalid=!0}get typeB(){return this._typeB}set typeB(t){this._typeB=t,this._key_invalid=!0}}class Ep{constructor(){this.cf=new Ip}Copy(t){return this.key=t.key,this}Clone(){return(new Ep).Copy(this)}get key(){return this.cf.key}set key(t){this.cf.key=t}}class Rp{constructor(){this.localPoint=new ep,this.normalImpulse=0,this.tangentImpulse=0,this.id=new Ep}static MakeArray(t){return Wd(t,(t=>new Rp))}Reset(){this.localPoint.SetZero(),this.normalImpulse=0,this.tangentImpulse=0,this.id.key=0}Copy(t){return this.localPoint.Copy(t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.Copy(t.id),this}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circles=0]="e_circles",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(Pp||(Pp={}));class Lp{constructor(){this.points=Rp.MakeArray(2),this.localNormal=new ep,this.localPoint=new ep,this.type=Pp.e_unknown,this.pointCount=0}Reset(){for(let t=0;t<2;++t)this.points[t].Reset();this.localNormal.SetZero(),this.localPoint.SetZero(),this.type=Pp.e_unknown,this.pointCount=0}Copy(t){this.pointCount=t.pointCount;for(let e=0;e<2;++e)this.points[e].Copy(t.points[e]);return this.localNormal.Copy(t.localNormal),this.localPoint.Copy(t.localPoint),this.type=t.type,this}Clone(){return(new Lp).Copy(this)}}class Gp{constructor(){this.normal=new ep,this.points=ep.MakeArray(2),this.separations=jd(2)}Initialize(t,e,i,s,n){if(0!==t.pointCount)switch(t.type){case Pp.e_circles:{this.normal.Set(1,0);const r=ap.MulXV(e,t.localPoint,Gp.Initialize_s_pointA),o=ap.MulXV(s,t.points[0].localPoint,Gp.Initialize_s_pointB);ep.DistanceSquaredVV(r,o)>Rd&&ep.SubVV(o,r,this.normal).SelfNormalize();const a=ep.AddVMulSV(r,i,this.normal,Gp.Initialize_s_cA),l=ep.SubVMulSV(o,n,this.normal,Gp.Initialize_s_cB);ep.MidVV(a,l,this.points[0]),this.separations[0]=ep.DotVV(ep.SubVV(l,a,ep.s_t0),this.normal);break}case Pp.e_faceA:{op.MulRV(e.q,t.localNormal,this.normal);const r=ap.MulXV(e,t.localPoint,Gp.Initialize_s_planePoint);for(let e=0;e<t.pointCount;++e){const o=ap.MulXV(s,t.points[e].localPoint,Gp.Initialize_s_clipPoint),a=i-ep.DotVV(ep.SubVV(o,r,ep.s_t0),this.normal),l=ep.AddVMulSV(o,a,this.normal,Gp.Initialize_s_cA),h=ep.SubVMulSV(o,n,this.normal,Gp.Initialize_s_cB);ep.MidVV(l,h,this.points[e]),this.separations[e]=ep.DotVV(ep.SubVV(h,l,ep.s_t0),this.normal)}break}case Pp.e_faceB:{op.MulRV(s.q,t.localNormal,this.normal);const r=ap.MulXV(s,t.localPoint,Gp.Initialize_s_planePoint);for(let s=0;s<t.pointCount;++s){const o=ap.MulXV(e,t.points[s].localPoint,Gp.Initialize_s_clipPoint),a=n-ep.DotVV(ep.SubVV(o,r,ep.s_t0),this.normal),l=ep.AddVMulSV(o,a,this.normal,Gp.Initialize_s_cB),h=ep.SubVMulSV(o,i,this.normal,Gp.Initialize_s_cA);ep.MidVV(h,l,this.points[s]),this.separations[s]=ep.DotVV(ep.SubVV(h,l,ep.s_t0),this.normal)}this.normal.SelfNeg();break}}}}Gp.Initialize_s_pointA=new ep,Gp.Initialize_s_pointB=new ep,Gp.Initialize_s_cA=new ep,Gp.Initialize_s_cB=new ep,Gp.Initialize_s_planePoint=new ep,Gp.Initialize_s_clipPoint=new ep,function(t){t[t.b2_nullState=0]="b2_nullState",t[t.b2_addState=1]="b2_addState",t[t.b2_persistState=2]="b2_persistState",t[t.b2_removeState=3]="b2_removeState"}(Dp||(Dp={}));class Fp{constructor(){this.v=new ep,this.id=new Ep}static MakeArray(t){return Wd(t,(t=>new Fp))}Copy(t){return this.v.Copy(t.v),this.id.Copy(t.id),this}}class kp{constructor(){this.p1=new ep,this.p2=new ep,this.maxFraction=1}Copy(t){return this.p1.Copy(t.p1),this.p2.Copy(t.p2),this.maxFraction=t.maxFraction,this}}class zp{constructor(){this.normal=new ep,this.fraction=0}Copy(t){return this.normal.Copy(t.normal),this.fraction=t.fraction,this}}class Op{constructor(){this.lowerBound=new ep,this.upperBound=new ep,this.m_cache_center=new ep,this.m_cache_extent=new ep}Copy(t){return this.lowerBound.Copy(t.lowerBound),this.upperBound.Copy(t.upperBound),this}IsValid(){return!(!this.lowerBound.IsValid()||!this.upperBound.IsValid()||this.upperBound.x<this.lowerBound.x||this.upperBound.y<this.lowerBound.y)}GetCenter(){return ep.MidVV(this.lowerBound,this.upperBound,this.m_cache_center)}GetExtents(){return ep.ExtVV(this.lowerBound,this.upperBound,this.m_cache_extent)}GetPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+(this.upperBound.y-this.lowerBound.y))}Combine1(t){return this.lowerBound.x=Xd(this.lowerBound.x,t.lowerBound.x),this.lowerBound.y=Xd(this.lowerBound.y,t.lowerBound.y),this.upperBound.x=Jd(this.upperBound.x,t.upperBound.x),this.upperBound.y=Jd(this.upperBound.y,t.upperBound.y),this}Combine2(t,e){return this.lowerBound.x=Xd(t.lowerBound.x,e.lowerBound.x),this.lowerBound.y=Xd(t.lowerBound.y,e.lowerBound.y),this.upperBound.x=Jd(t.upperBound.x,e.upperBound.x),this.upperBound.y=Jd(t.upperBound.y,e.upperBound.y),this}static Combine(t,e,i){return i.Combine2(t,e),i}Contains(t){let e=!0;return e=e&&this.lowerBound.x<=t.lowerBound.x,e=e&&this.lowerBound.y<=t.lowerBound.y,e=e&&t.upperBound.x<=this.upperBound.x,e=e&&t.upperBound.y<=this.upperBound.y,e}RayCast(t,e){let i=-Id,s=Id;const n=e.p1.x,r=e.p1.y,o=e.p2.x-e.p1.x,a=e.p2.y-e.p1.y,l=qd(o),h=qd(a),c=t.normal;if(l<Ed){if(n<this.lowerBound.x||this.upperBound.x<n)return!1}else{const t=1/o;let e=(this.lowerBound.x-n)*t,r=(this.upperBound.x-n)*t,a=-1;if(e>r){const t=e;e=r,r=t,a=1}if(e>i&&(c.x=a,c.y=0,i=e),s=Xd(s,r),i>s)return!1}if(h<Ed){if(r<this.lowerBound.y||this.upperBound.y<r)return!1}else{const t=1/a;let e=(this.lowerBound.y-r)*t,n=(this.upperBound.y-r)*t,o=-1;if(e>n){const t=e;e=n,n=t,o=1}if(e>i&&(c.x=0,c.y=o,i=e),s=Xd(s,n),i>s)return!1}return!(i<0||e.maxFraction<i||(t.fraction=i,0))}TestContain(t){return!(t.x<this.lowerBound.x||this.upperBound.x<t.x||t.y<this.lowerBound.y||this.upperBound.y<t.y)}TestOverlap(t){return!(this.upperBound.x<t.lowerBound.x||this.upperBound.y<t.lowerBound.y||t.upperBound.x<this.lowerBound.x||t.upperBound.y<this.lowerBound.y)}}function Np(t,e){return!(t.upperBound.x<e.lowerBound.x||t.upperBound.y<e.lowerBound.y||e.upperBound.x<t.lowerBound.x||e.upperBound.y<t.lowerBound.y)}function Up(t,e,i,s,n){let r=0;const o=e[0],a=e[1],l=ep.DotVV(i,o.v)-s,h=ep.DotVV(i,a.v)-s;if(l<=0&&t[r++].Copy(o),h<=0&&t[r++].Copy(a),l*h<0){const e=l/(l-h),i=t[r].v;i.x=o.v.x+e*(a.v.x-o.v.x),i.y=o.v.y+e*(a.v.y-o.v.y);const s=t[r].id;s.cf.indexA=n,s.cf.indexB=o.id.cf.indexB,s.cf.typeA=Tp.e_vertex,s.cf.typeB=Tp.e_face,++r}return r}const Wp=new pp,jp=new dp,Hp=new fp;function qp(t,e,i,s,n,r){const o=Wp.Reset();o.proxyA.SetShape(t,e),o.proxyB.SetShape(i,s),o.transformA.Copy(n),o.transformB.Copy(r),o.useRadii=!0;const a=jp.Reset();a.count=0;const l=Hp.Reset();return Vp(l,a,o),l.distance<1e-4}function Xp(t){if(null===t)throw new Error;return t}class Jp{constructor(t=0){this.m_id=0,this.aabb=new Op,this._userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=0,this.moved=!1,this.m_id=t}get userData(){if(null===this._userData)throw new Error;return this._userData}set userData(t){if(null!==this._userData)throw new Error;this._userData=t}Reset(){this._userData=null}IsLeaf(){return null===this.child1}}class Zp{constructor(){this.m_root=null,this.m_freeList=null,this.m_insertionCount=0,this.m_stack=new up(256)}Query(t,e){const i=this.m_stack.Reset();for(i.Push(this.m_root);i.GetCount()>0;){const s=i.Pop();if(null!==s&&s.aabb.TestOverlap(t))if(s.IsLeaf()){if(!e(s))return}else i.Push(s.child1),i.Push(s.child2)}}QueryPoint(t,e){const i=this.m_stack.Reset();for(i.Push(this.m_root);i.GetCount()>0;){const s=i.Pop();if(null!==s&&s.aabb.TestContain(t))if(s.IsLeaf()){if(!e(s))return}else i.Push(s.child1),i.Push(s.child2)}}RayCast(t,e){const i=t.p1,s=t.p2,n=ep.SubVV(s,i,Zp.s_r);n.Normalize();const r=ep.CrossOneV(n,Zp.s_v),o=ep.AbsV(r,Zp.s_abs_v);let a=t.maxFraction;const l=Zp.s_segmentAABB;let h=i.x+a*(s.x-i.x),c=i.y+a*(s.y-i.y);l.lowerBound.x=Xd(i.x,h),l.lowerBound.y=Xd(i.y,c),l.upperBound.x=Jd(i.x,h),l.upperBound.y=Jd(i.y,c);const m=this.m_stack.Reset();for(m.Push(this.m_root);m.GetCount()>0;){const n=m.Pop();if(null===n)continue;if(!Np(n.aabb,l))continue;const u=n.aabb.GetCenter(),_=n.aabb.GetExtents();if(!(qd(ep.DotVV(r,ep.SubVV(i,u,ep.s_t0)))-ep.DotVV(o,_)>0))if(n.IsLeaf()){const r=Zp.s_subInput;r.p1.Copy(t.p1),r.p2.Copy(t.p2),r.maxFraction=a;const o=e(r,n);if(0===o)return;o>0&&(a=o,h=i.x+a*(s.x-i.x),c=i.y+a*(s.y-i.y),l.lowerBound.x=Xd(i.x,h),l.lowerBound.y=Xd(i.y,c),l.upperBound.x=Jd(i.x,h),l.upperBound.y=Jd(i.y,c))}else m.Push(n.child1),m.Push(n.child2)}}AllocateNode(){if(null!==this.m_freeList){const t=this.m_freeList;return this.m_freeList=t.parent,t.parent=null,t.child1=null,t.child2=null,t.height=0,t.moved=!1,t}return new Jp(Zp.s_node_id++)}FreeNode(t){t.parent=this.m_freeList,t.child1=null,t.child2=null,t.height=-1,t.Reset(),this.m_freeList=t}CreateProxy(t,e){const i=this.AllocateNode();return i.aabb.lowerBound.x=t.lowerBound.x-.1,i.aabb.lowerBound.y=t.lowerBound.y-.1,i.aabb.upperBound.x=t.upperBound.x+.1,i.aabb.upperBound.y=t.upperBound.y+.1,i.userData=e,i.height=0,i.moved=!0,this.InsertLeaf(i),i}DestroyProxy(t){this.RemoveLeaf(t),this.FreeNode(t)}MoveProxy(t,e,i){const s=Zp.MoveProxy_s_fatAABB;s.lowerBound.x=e.lowerBound.x-.1,s.lowerBound.y=e.lowerBound.y-.1,s.upperBound.x=e.upperBound.x+.1,s.upperBound.y=e.upperBound.y+.1;const n=4*i.x,r=4*i.y;n<0?s.lowerBound.x+=n:s.upperBound.x+=n,r<0?s.lowerBound.y+=r:s.upperBound.y+=r;const o=t.aabb;if(o.Contains(e)){const t=Zp.MoveProxy_s_hugeAABB;if(t.lowerBound.x=s.lowerBound.x-.4,t.lowerBound.y=s.lowerBound.y-.4,t.upperBound.x=s.upperBound.x+.4,t.upperBound.y=s.upperBound.y+.4,t.Contains(o))return!1}return this.RemoveLeaf(t),t.aabb.Copy(s),this.InsertLeaf(t),t.moved=!0,!0}InsertLeaf(t){if(++this.m_insertionCount,null===this.m_root)return this.m_root=t,void(this.m_root.parent=null);const e=t.aabb;let i=this.m_root;for(;!i.IsLeaf();){const t=Xp(i.child1),s=Xp(i.child2),n=i.aabb.GetPerimeter(),r=Zp.s_combinedAABB;r.Combine2(i.aabb,e);const o=r.GetPerimeter(),a=2*o,l=2*(o-n);let h;const c=Zp.s_aabb;let m,u,_;if(t.IsLeaf()?(c.Combine2(e,t.aabb),h=c.GetPerimeter()+l):(c.Combine2(e,t.aabb),m=t.aabb.GetPerimeter(),u=c.GetPerimeter(),h=u-m+l),s.IsLeaf()?(c.Combine2(e,s.aabb),_=c.GetPerimeter()+l):(c.Combine2(e,s.aabb),m=s.aabb.GetPerimeter(),u=c.GetPerimeter(),_=u-m+l),a<h&&a<_)break;i=h<_?t:s}const s=i.parent,n=this.AllocateNode();n.parent=s,n.aabb.Combine2(e,i.aabb),n.height=i.height+1,null!==s?(s.child1===i?s.child1=n:s.child2=n,n.child1=i,n.child2=t,i.parent=n,t.parent=n):(n.child1=i,n.child2=t,i.parent=n,t.parent=n,this.m_root=n);let r=t.parent;for(;null!==r;){r=this.Balance(r);const t=Xp(r.child1),e=Xp(r.child2);r.height=1+Jd(t.height,e.height),r.aabb.Combine2(t.aabb,e.aabb),r=r.parent}}RemoveLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=Xp(t.parent),i=e&&e.parent,s=Xp(e.child1===t?e.child2:e.child1);if(null!==i){i.child1===e?i.child1=s:i.child2=s,s.parent=i,this.FreeNode(e);let t=i;for(;null!==t;){t=this.Balance(t);const e=Xp(t.child1),i=Xp(t.child2);t.aabb.Combine2(e.aabb,i.aabb),t.height=1+Jd(e.height,i.height),t=t.parent}}else this.m_root=s,s.parent=null,this.FreeNode(e)}Balance(t){if(t.IsLeaf()||t.height<2)return t;const e=Xp(t.child1),i=Xp(t.child2),s=i.height-e.height;if(s>1){const s=Xp(i.child1),n=Xp(i.child2);return i.child1=t,i.parent=t.parent,t.parent=i,null!==i.parent?i.parent.child1===t?i.parent.child1=i:i.parent.child2=i:this.m_root=i,s.height>n.height?(i.child2=s,t.child2=n,n.parent=t,t.aabb.Combine2(e.aabb,n.aabb),i.aabb.Combine2(t.aabb,s.aabb),t.height=1+Jd(e.height,n.height),i.height=1+Jd(t.height,s.height)):(i.child2=n,t.child2=s,s.parent=t,t.aabb.Combine2(e.aabb,s.aabb),i.aabb.Combine2(t.aabb,n.aabb),t.height=1+Jd(e.height,s.height),i.height=1+Jd(t.height,n.height)),i}if(s<-1){const s=Xp(e.child1),n=Xp(e.child2);return e.child1=t,e.parent=t.parent,t.parent=e,null!==e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.m_root=e,s.height>n.height?(e.child2=s,t.child1=n,n.parent=t,t.aabb.Combine2(i.aabb,n.aabb),e.aabb.Combine2(t.aabb,s.aabb),t.height=1+Jd(i.height,n.height),e.height=1+Jd(t.height,s.height)):(e.child2=n,t.child1=s,s.parent=t,t.aabb.Combine2(i.aabb,s.aabb),e.aabb.Combine2(t.aabb,n.aabb),t.height=1+Jd(i.height,s.height),e.height=1+Jd(t.height,n.height)),e}return t}GetHeight(){return null===this.m_root?0:this.m_root.height}static GetAreaNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;let e=t.aabb.GetPerimeter();return e+=Zp.GetAreaNode(t.child1),e+=Zp.GetAreaNode(t.child2),e}GetAreaRatio(){if(null===this.m_root)return 0;const t=this.m_root.aabb.GetPerimeter();return Zp.GetAreaNode(this.m_root)/t}static ComputeHeightNode(t){return null===t||t.IsLeaf()?0:1+Jd(Zp.ComputeHeightNode(t.child1),Zp.ComputeHeightNode(t.child2))}ComputeHeight(){return Zp.ComputeHeightNode(this.m_root)}ValidateStructure(t){if(null===t)return;if(this.m_root,t.IsLeaf())return;const e=Xp(t.child1),i=Xp(t.child2);this.ValidateStructure(e),this.ValidateStructure(i)}ValidateMetrics(t){if(null===t)return;if(t.IsLeaf())return;const e=Xp(t.child1),i=Xp(t.child2);Zp.s_aabb.Combine2(e.aabb,i.aabb),this.ValidateMetrics(e),this.ValidateMetrics(i)}Validate(){}static GetMaxBalanceNode(t,e){if(null===t)return e;if(t.height<=1)return e;const i=Xp(t.child1),s=Xp(t.child2);return Jd(e,qd(s.height-i.height))}GetMaxBalance(){return Zp.GetMaxBalanceNode(this.m_root,0)}RebuildBottomUp(){this.Validate()}static ShiftOriginNode(t,e){if(null===t)return;if(t.height<=1)return;const i=t.child1,s=t.child2;Zp.ShiftOriginNode(i,e),Zp.ShiftOriginNode(s,e),t.aabb.lowerBound.SelfSub(e),t.aabb.upperBound.SelfSub(e)}ShiftOrigin(t){Zp.ShiftOriginNode(this.m_root,t)}}Zp.s_r=new ep,Zp.s_v=new ep,Zp.s_abs_v=new ep,Zp.s_segmentAABB=new Op,Zp.s_subInput=new kp,Zp.s_combinedAABB=new Op,Zp.s_aabb=new Op,Zp.s_node_id=0,Zp.MoveProxy_s_fatAABB=new Op,Zp.MoveProxy_s_hugeAABB=new Op;class Yp{constructor(t,e){this.proxyA=t,this.proxyB=e}}class Qp{constructor(){this.m_tree=new Zp,this.m_proxyCount=0,this.m_moveCount=0,this.m_moveBuffer=[],this.m_pairCount=0,this.m_pairBuffer=[]}CreateProxy(t,e){const i=this.m_tree.CreateProxy(t,e);return++this.m_proxyCount,this.BufferMove(i),i}DestroyProxy(t){this.UnBufferMove(t),--this.m_proxyCount,this.m_tree.DestroyProxy(t)}MoveProxy(t,e,i){this.m_tree.MoveProxy(t,e,i)&&this.BufferMove(t)}TouchProxy(t){this.BufferMove(t)}GetProxyCount(){return this.m_proxyCount}UpdatePairs(t){this.m_pairCount=0;for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];if(null===e)continue;const i=e.aabb;this.m_tree.Query(i,(t=>{if(t.m_id===e.m_id)return!0;if(t.moved&&t.m_id>e.m_id)return!0;let i,s;if(t.m_id<e.m_id?(i=t,s=e):(i=e,s=t),this.m_pairCount===this.m_pairBuffer.length)this.m_pairBuffer[this.m_pairCount]=new Yp(i,s);else{const t=this.m_pairBuffer[this.m_pairCount];t.proxyA=i,t.proxyB=s}return++this.m_pairCount,!0}))}for(let e=0;e<this.m_pairCount;++e){const i=this.m_pairBuffer[e];t(i.proxyA.userData,i.proxyB.userData)}for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];null!==e&&(e.moved=!1)}this.m_moveCount=0}Query(t,e){this.m_tree.Query(t,e)}QueryPoint(t,e){this.m_tree.QueryPoint(t,e)}RayCast(t,e){this.m_tree.RayCast(t,e)}GetTreeHeight(){return this.m_tree.GetHeight()}GetTreeBalance(){return this.m_tree.GetMaxBalance()}GetTreeQuality(){return this.m_tree.GetAreaRatio()}ShiftOrigin(t){this.m_tree.ShiftOrigin(t)}BufferMove(t){this.m_moveBuffer[this.m_moveCount]=t,++this.m_moveCount}UnBufferMove(t){for(let e=0;e<this.m_moveCount;++e)this.m_moveBuffer[e]===t&&(this.m_moveBuffer[e]=null)}}class Kp{constructor(){this.m_start=Date.now()}Reset(){return this.m_start=Date.now(),this}GetMilliseconds(){return Date.now()-this.m_start}}let $p=0,tf=0,ef=0,sf=0;const nf=new ap,rf=new ap,of=new ep,af=new ep,lf=new ep,hf=new ep,cf=new ep;class mf{constructor(){this.proxyA=new _p,this.proxyB=new _p,this.sweepA=new lp,this.sweepB=new lp,this.tMax=0}}var uf,_f;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_failed=1]="e_failed",t[t.e_overlapped=2]="e_overlapped",t[t.e_touching=3]="e_touching",t[t.e_separated=4]="e_separated"}(uf||(uf={}));class df{constructor(){this.state=uf.e_unknown,this.t=0}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_points=0]="e_points",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(_f||(_f={}));const pf=new Kp,ff=new dp,yf=new pp,gf=new fp,xf=new class{constructor(){this.m_sweepA=new lp,this.m_sweepB=new lp,this.m_type=_f.e_unknown,this.m_localPoint=new ep,this.m_axis=new ep}Initialize(t,e,i,s,n,r){this.m_proxyA=e,this.m_proxyB=s;const o=t.count;this.m_sweepA.Copy(i),this.m_sweepB.Copy(n);const a=nf,l=rf;if(this.m_sweepA.GetTransform(a,r),this.m_sweepB.GetTransform(l,r),1===o){this.m_type=_f.e_points;const e=this.m_proxyA.GetVertex(t.indexA[0]),i=this.m_proxyB.GetVertex(t.indexB[0]),s=ap.MulXV(a,e,of),n=ap.MulXV(l,i,af);ep.SubVV(n,s,this.m_axis);const r=this.m_axis.Normalize();return this.m_localPoint.SetZero(),r}if(t.indexA[0]===t.indexA[1]){this.m_type=_f.e_faceB;const e=this.m_proxyB.GetVertex(t.indexB[0]),i=this.m_proxyB.GetVertex(t.indexB[1]);ep.CrossVOne(ep.SubVV(i,e,ep.s_t0),this.m_axis).SelfNormalize();const s=op.MulRV(l.q,this.m_axis,lf);ep.MidVV(e,i,this.m_localPoint);const n=ap.MulXV(l,this.m_localPoint,af),r=this.m_proxyA.GetVertex(t.indexA[0]),o=ap.MulXV(a,r,of);let h=ep.DotVV(ep.SubVV(o,n,ep.s_t0),s);return h<0&&(this.m_axis.SelfNeg(),h=-h),h}{this.m_type=_f.e_faceA;const e=this.m_proxyA.GetVertex(t.indexA[0]),i=this.m_proxyA.GetVertex(t.indexA[1]);ep.CrossVOne(ep.SubVV(i,e,ep.s_t0),this.m_axis).SelfNormalize();const s=op.MulRV(a.q,this.m_axis,lf);ep.MidVV(e,i,this.m_localPoint);const n=ap.MulXV(a,this.m_localPoint,of),r=this.m_proxyB.GetVertex(t.indexB[0]),o=ap.MulXV(l,r,af);let h=ep.DotVV(ep.SubVV(o,n,ep.s_t0),s);return h<0&&(this.m_axis.SelfNeg(),h=-h),h}}FindMinSeparation(t,e,i){const s=nf,n=rf;switch(this.m_sweepA.GetTransform(s,i),this.m_sweepB.GetTransform(n,i),this.m_type){case _f.e_points:{const i=op.MulTRV(s.q,this.m_axis,hf),r=op.MulTRV(n.q,ep.NegV(this.m_axis,ep.s_t0),cf);t[0]=this.m_proxyA.GetSupport(i),e[0]=this.m_proxyB.GetSupport(r);const o=this.m_proxyA.GetVertex(t[0]),a=this.m_proxyB.GetVertex(e[0]),l=ap.MulXV(s,o,of),h=ap.MulXV(n,a,af);return ep.DotVV(ep.SubVV(h,l,ep.s_t0),this.m_axis)}case _f.e_faceA:{const i=op.MulRV(s.q,this.m_axis,lf),r=ap.MulXV(s,this.m_localPoint,of),o=op.MulTRV(n.q,ep.NegV(i,ep.s_t0),cf);t[0]=-1,e[0]=this.m_proxyB.GetSupport(o);const a=this.m_proxyB.GetVertex(e[0]),l=ap.MulXV(n,a,af);return ep.DotVV(ep.SubVV(l,r,ep.s_t0),i)}case _f.e_faceB:{const i=op.MulRV(n.q,this.m_axis,lf),r=ap.MulXV(n,this.m_localPoint,af),o=op.MulTRV(s.q,ep.NegV(i,ep.s_t0),hf);e[0]=-1,t[0]=this.m_proxyA.GetSupport(o);const a=this.m_proxyA.GetVertex(t[0]),l=ap.MulXV(s,a,of);return ep.DotVV(ep.SubVV(l,r,ep.s_t0),i)}default:return t[0]=-1,e[0]=-1,0}}Evaluate(t,e,i){const s=nf,n=rf;switch(this.m_sweepA.GetTransform(s,i),this.m_sweepB.GetTransform(n,i),this.m_type){case _f.e_points:{const i=this.m_proxyA.GetVertex(t),r=this.m_proxyB.GetVertex(e),o=ap.MulXV(s,i,of),a=ap.MulXV(n,r,af);return ep.DotVV(ep.SubVV(a,o,ep.s_t0),this.m_axis)}case _f.e_faceA:{const t=op.MulRV(s.q,this.m_axis,lf),i=ap.MulXV(s,this.m_localPoint,of),r=this.m_proxyB.GetVertex(e),o=ap.MulXV(n,r,af);return ep.DotVV(ep.SubVV(o,i,ep.s_t0),t)}case _f.e_faceB:{const e=op.MulRV(n.q,this.m_axis,lf),i=ap.MulXV(n,this.m_localPoint,af),r=this.m_proxyA.GetVertex(t),o=ap.MulXV(s,r,of);return ep.DotVV(ep.SubVV(o,i,ep.s_t0),e)}default:return 0}}},vf=[0],Sf=[0],wf=new lp,bf=new lp;function Cf(t,e){const i=pf.Reset();t.state=uf.e_unknown,t.t=e.tMax;const s=e.proxyA,n=e.proxyB,r=Jd(8,Jd(s.m_count,n.m_count)),o=wf.Copy(e.sweepA),a=bf.Copy(e.sweepB);o.Normalize(),a.Normalize();const l=e.tMax,h=s.m_radius+n.m_radius,c=Jd(Gd,h-.015),m=.00125;let u=0,_=0;const d=ff;d.count=0;const p=yf;for(p.proxyA.Copy(e.proxyA),p.proxyB.Copy(e.proxyB),p.useRadii=!1;;){const e=nf,i=rf;o.GetTransform(e,u),a.GetTransform(i,u),p.transformA.Copy(e),p.transformB.Copy(i);const h=gf;if(Vp(h,d,p),h.distance<=0){t.state=uf.e_overlapped,t.t=0;break}if(h.distance<c+m){t.state=uf.e_touching,t.t=u;break}const f=xf;f.Initialize(d,s,o,n,a,u);let y=!1,g=l,x=0;for(;;){const e=vf,i=Sf;let s=f.FindMinSeparation(e,i,g);if(s>c+m){t.state=uf.e_separated,t.t=l,y=!0;break}if(s>c-m){u=g;break}let n=f.Evaluate(e[0],i[0],u);if(n<c-m){t.state=uf.e_failed,t.t=u,y=!0;break}if(n<=c+m){t.state=uf.e_touching,t.t=u,y=!0;break}let o=0,a=u,h=g;for(;;){let t=0;t=1&o?a+(c-n)*(h-a)/(s-n):.5*(a+h),++o;const r=f.Evaluate(e[0],i[0],t);if(qd(r-c)<m){g=t;break}if(r>c?(a=t,n=r):(h=t,s=r),50===o)break}if(sf=Jd(sf,o),++x,x===r)break}if(++_,y)break;if(20===_){t.state=uf.e_failed,t.t=u;break}}ef=Jd(ef,_);const f=i.GetMilliseconds();tf=Jd(tf,f),$p+=f}const Af=new ep,Bf=new ep,Mf=new ep,Vf=new ep,Tf=new ep,Pf=new ap,Df=new ep,If=new ep;function Ef(t,e,i,s,n){const r=e.m_count,o=s.m_count,a=e.m_normals,l=e.m_vertices,h=s.m_vertices,c=ap.MulTXX(n,i,Pf);let m=0,u=-Id;for(let t=0;t<r;++t){const e=op.MulRV(c.q,a[t],Df),i=ap.MulXV(c,l[t],If);let s=Id;for(let t=0;t<o;++t){const n=ep.DotVV(e,ep.SubVV(h[t],i,ep.s_t0));n<s&&(s=n)}s>u&&(u=s,m=t)}return t[0]=m,u}const Rf=new ep,Lf=[new Fp,new Fp],Gf=[new Fp,new Fp],Ff=[new Fp,new Fp],kf=[0],zf=[0],Of=new ep,Nf=new ep,Uf=new ep,Wf=new ep,jf=new ep,Hf=new ep,qf=new ep,Xf=new ep;const Jf=new ep,Zf=new ep,Yf=new ep,Qf=new ep,Kf=new ep,$f=new ep,ty=new ep,ey=new Ep;function iy(t,e,i,s,n){t.pointCount=0;const r=ap.MulTXV(i,ap.MulXV(n,s.m_p,ep.s_t0),Jf),o=e.m_vertex1,a=e.m_vertex2,l=ep.SubVV(a,o,Zf),h=ty.Set(l.y,-l.x),c=ep.DotVV(h,ep.SubVV(r,o,ep.s_t0));if(e.m_oneSided&&c<0)return;const m=ep.DotVV(l,ep.SubVV(a,r,ep.s_t0)),u=ep.DotVV(l,ep.SubVV(r,o,ep.s_t0)),_=e.m_radius+s.m_radius,d=ey;if(d.cf.indexB=0,d.cf.typeB=Tp.e_vertex,u<=0){const i=o,n=ep.SubVV(r,i,Yf);if(ep.DotVV(n,n)>_*_)return;if(e.m_oneSided){const t=e.m_vertex0,i=o,s=ep.SubVV(i,t,Qf);if(ep.DotVV(s,ep.SubVV(i,r,ep.s_t0))>0)return}return d.cf.indexA=0,d.cf.typeA=Tp.e_vertex,t.pointCount=1,t.type=Pp.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(i),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(s.m_p)}if(m<=0){const i=a,n=ep.SubVV(r,i,Yf);if(ep.DotVV(n,n)>_*_)return;if(e.m_oneSided){const t=e.m_vertex3,i=a,s=ep.SubVV(t,i,Kf);if(ep.DotVV(s,ep.SubVV(r,i,ep.s_t0))>0)return}return d.cf.indexA=1,d.cf.typeA=Tp.e_vertex,t.pointCount=1,t.type=Pp.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(i),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(s.m_p)}const p=ep.DotVV(l,l),f=$f;f.x=1/p*(m*o.x+u*a.x),f.y=1/p*(m*o.y+u*a.y);const y=ep.SubVV(r,f,Yf);ep.DotVV(y,y)>_*_||(c<0&&h.Set(-h.x,-h.y),h.Normalize(),d.cf.indexA=0,d.cf.typeA=Tp.e_face,t.pointCount=1,t.type=Pp.e_faceA,t.localNormal.Copy(h),t.localPoint.Copy(o),t.points[0].id.Copy(d),t.points[0].localPoint.Copy(s.m_p))}var sy;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(sy||(sy={}));class ny{constructor(){this.normal=new ep,this.type=sy.e_unknown,this.index=0,this.separation=0}}const ry=new ny,oy=[new ep,new ep],ay=new ny,ly=new ep,hy=new ap,cy=new ep,my=new ep,uy=new ep,_y=new ep,dy=new ep,py=new ep,fy=new ep,yy=new class{constructor(){this.vertices=[],this.normals=[],this.count=0}},gy=new class{constructor(){this.i1=0,this.i2=0,this.v1=new ep,this.v2=new ep,this.normal=new ep,this.sideNormal1=new ep,this.sideOffset1=0,this.sideNormal2=new ep,this.sideOffset2=0}},xy=[new Fp,new Fp],vy=[new Fp,new Fp],Sy=[new Fp,new Fp];function wy(t,e,i,s,n){t.pointCount=0;const r=ap.MulTXX(i,n,hy),o=ap.MulXV(r,s.m_centroid,cy),a=e.m_vertex1,l=e.m_vertex2,h=ep.SubVV(l,a,my);h.Normalize();const c=uy.Set(h.y,-h.x),m=ep.DotVV(c,ep.SubVV(o,a,ep.s_t0)),u=e.m_oneSided;if(u&&m<0)return;const _=yy;_.count=s.m_count;for(let t=0;t<s.m_count;++t)_.vertices.length<=t&&_.vertices.push(new ep),_.normals.length<=t&&_.normals.push(new ep),ap.MulXV(r,s.m_vertices[t],_.vertices[t]),op.MulRV(r.q,s.m_normals[t],_.normals[t]);const d=s.m_radius+e.m_radius,p=function(t,e,i){const s=ry;s.type=sy.e_edgeA,s.index=-1,s.separation=-Number.MAX_VALUE,s.normal.SetZero();const n=oy;n[0].Copy(i),n[1].Copy(i).SelfNeg();for(let i=0;i<2;++i){let r=Number.MAX_VALUE;for(let s=0;s<t.count;++s){const o=ep.DotVV(n[i],ep.SubVV(t.vertices[s],e,ep.s_t0));o<r&&(r=o)}r>s.separation&&(s.index=i,s.separation=r,s.normal.Copy(n[i]))}return s}(_,a,c);if(p.separation>d)return;const f=function(t,e,i){const s=ay;s.type=sy.e_unknown,s.index=-1,s.separation=-Number.MAX_VALUE,s.normal.SetZero();for(let n=0;n<t.count;++n){const r=ep.NegV(t.normals[n],ly),o=Xd(ep.DotVV(r,ep.SubVV(t.vertices[n],e,ep.s_t0)),ep.DotVV(r,ep.SubVV(t.vertices[n],i,ep.s_t0)));o>s.separation&&(s.type=sy.e_edgeB,s.index=n,s.separation=o,s.normal.Copy(r))}return s}(_,a,l);if(f.separation>d)return;let y;if(y=f.separation-d>.98*(p.separation-d)+.001?f:p,u){const t=ep.SubVV(a,e.m_vertex0,_y);t.Normalize();const i=dy.Set(t.y,-t.x),s=ep.CrossVV(t,h)>=0,n=ep.SubVV(e.m_vertex3,l,py);n.Normalize();const r=fy.Set(n.y,-n.x),o=ep.CrossVV(h,n)>=0,c=.1;if(ep.DotVV(y.normal,h)<=0)if(s){if(ep.CrossVV(y.normal,i)>c)return}else y=p;else if(o){if(ep.CrossVV(r,y.normal)>c)return}else y=p}const g=xy,x=gy;if(y.type===sy.e_edgeA){t.type=Pp.e_faceA;let e=0,i=ep.DotVV(y.normal,_.normals[0]);for(let t=1;t<_.count;++t){const s=ep.DotVV(y.normal,_.normals[t]);s<i&&(i=s,e=t)}const s=e,n=s+1<_.count?s+1:0;g[0].v.Copy(_.vertices[s]),g[0].id.cf.indexA=0,g[0].id.cf.indexB=s,g[0].id.cf.typeA=Tp.e_face,g[0].id.cf.typeB=Tp.e_vertex,g[1].v.Copy(_.vertices[n]),g[1].id.cf.indexA=0,g[1].id.cf.indexB=n,g[1].id.cf.typeA=Tp.e_face,g[1].id.cf.typeB=Tp.e_vertex,x.i1=0,x.i2=1,x.v1.Copy(a),x.v2.Copy(l),x.normal.Copy(y.normal),x.sideNormal1.Copy(h).SelfNeg(),x.sideNormal2.Copy(h)}else t.type=Pp.e_faceB,g[0].v.Copy(l),g[0].id.cf.indexA=1,g[0].id.cf.indexB=y.index,g[0].id.cf.typeA=Tp.e_vertex,g[0].id.cf.typeB=Tp.e_face,g[1].v.Copy(a),g[1].id.cf.indexA=0,g[1].id.cf.indexB=y.index,g[1].id.cf.typeA=Tp.e_vertex,g[1].id.cf.typeB=Tp.e_face,x.i1=y.index,x.i2=x.i1+1<_.count?x.i1+1:0,x.v1.Copy(_.vertices[x.i1]),x.v2.Copy(_.vertices[x.i2]),x.normal.Copy(_.normals[x.i1]),x.sideNormal1.Set(x.normal.y,-x.normal.x),x.sideNormal2.Copy(x.sideNormal1).SelfNeg();x.sideOffset1=ep.DotVV(x.sideNormal1,x.v1),x.sideOffset2=ep.DotVV(x.sideNormal2,x.v2);const v=vy,S=Sy;let w;if(w=Up(v,g,x.sideNormal1,x.sideOffset1,x.i1),w<2)return;if(w=Up(S,v,x.sideNormal2,x.sideOffset2,x.i2),w<2)return;y.type===sy.e_edgeA?(t.localNormal.Copy(x.normal),t.localPoint.Copy(x.v1)):(t.localNormal.Copy(s.m_normals[x.i1]),t.localPoint.Copy(s.m_vertices[x.i1]));let b=0;for(let e=0;e<2;++e)if(ep.DotVV(x.normal,ep.SubVV(S[e].v,x.v1,ep.s_t0))<=d){const i=t.points[b];y.type===sy.e_edgeA?(ap.MulTXV(r,S[e].v,i.localPoint),i.id.Copy(S[e].id)):(i.localPoint.Copy(S[e].v),i.id.cf.typeA=S[e].id.cf.typeB,i.id.cf.typeB=S[e].id.cf.typeA,i.id.cf.indexA=S[e].id.cf.indexB,i.id.cf.indexB=S[e].id.cf.indexA),++b}t.pointCount=b}class by{constructor(){this.mass=0,this.center=new ep(0,0),this.I=0}}var Cy,Ay,By;!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circleShape=0]="e_circleShape",t[t.e_edgeShape=1]="e_edgeShape",t[t.e_polygonShape=2]="e_polygonShape",t[t.e_chainShape=3]="e_chainShape",t[t.e_shapeTypeCount=4]="e_shapeTypeCount"}(Cy||(Cy={}));class My{constructor(t,e){this.m_type=Cy.e_unknown,this.m_radius=0,this.m_type=t,this.m_radius=e}Copy(t){return this.m_radius=t.m_radius,this}GetType(){return this.m_type}}class Vy extends My{constructor(t=0){super(Cy.e_circleShape,t),this.m_p=new ep}Set(t,e=this.m_radius){return this.m_p.Copy(t),this.m_radius=e,this}Clone(){return(new Vy).Copy(this)}Copy(t){return super.Copy(t),this.m_p.Copy(t.m_p),this}GetChildCount(){return 1}TestPoint(t,e){const i=ap.MulXV(t,this.m_p,Vy.TestPoint_s_center),s=ep.SubVV(e,i,Vy.TestPoint_s_d);return ep.DotVV(s,s)<=Yd(this.m_radius)}ComputeDistance(t,e,i,s){const n=ap.MulXV(t,this.m_p,Vy.ComputeDistance_s_center);return ep.SubVV(e,n,i),i.Normalize()-this.m_radius}RayCast(t,e,i,s){const n=ap.MulXV(i,this.m_p,Vy.RayCast_s_position),r=ep.SubVV(e.p1,n,Vy.RayCast_s_s),o=ep.DotVV(r,r)-Yd(this.m_radius),a=ep.SubVV(e.p2,e.p1,Vy.RayCast_s_r),l=ep.DotVV(r,a),h=ep.DotVV(a,a),c=l*l-h*o;if(c<0||h<Ed)return!1;let m=-(l+Kd(c));return 0<=m&&m<=e.maxFraction*h&&(m/=h,t.fraction=m,ep.AddVMulSV(r,m,a,t.normal).SelfNormalize(),!0)}ComputeAABB(t,e,i){const s=ap.MulXV(e,this.m_p,Vy.ComputeAABB_s_p);t.lowerBound.Set(s.x-this.m_radius,s.y-this.m_radius),t.upperBound.Set(s.x+this.m_radius,s.y+this.m_radius)}ComputeMass(t,e){const i=Yd(this.m_radius);t.mass=e*Ld*i,t.center.Copy(this.m_p),t.I=t.mass*(.5*i+ep.DotVV(this.m_p,this.m_p))}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_p),t.m_count=1,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){const n=ap.MulXV(i,this.m_p,new ep),r=-(ep.DotVV(t,n)-e);if(r<-this.m_radius+Ed)return 0;if(r>this.m_radius)return s.Copy(n),Ld*this.m_radius*this.m_radius;const o=this.m_radius*this.m_radius,a=r*r,l=o*(tp(r/this.m_radius)+1.570796326795)+r*Kd(o-a),h=-2/3*$d(o-a,1.5)/l;return s.x=n.x+t.x*h,s.y=n.y+t.y*h,l}Dump(t){t("    const shape: b2CircleShape = new b2CircleShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_p.Set(%.15f, %.15f);\n",this.m_p.x,this.m_p.y)}}Vy.TestPoint_s_center=new ep,Vy.TestPoint_s_d=new ep,Vy.ComputeDistance_s_center=new ep,Vy.RayCast_s_position=new ep,Vy.RayCast_s_s=new ep,Vy.RayCast_s_r=new ep,Vy.ComputeAABB_s_p=new ep;class Ty extends My{constructor(){super(Cy.e_polygonShape,kd),this.m_centroid=new ep(0,0),this.m_vertices=[],this.m_normals=[],this.m_count=0}Clone(){return(new Ty).Copy(this)}Copy(t){super.Copy(t),this.m_centroid.Copy(t.m_centroid),this.m_count=t.m_count,this.m_vertices=ep.MakeArray(this.m_count),this.m_normals=ep.MakeArray(this.m_count);for(let e=0;e<this.m_count;++e)this.m_vertices[e].Copy(t.m_vertices[e]),this.m_normals[e].Copy(t.m_normals[e]);return this}GetChildCount(){return 1}Set(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._Set((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2)}{const e=t[0],i=t[1]||e.length;return this._Set((t=>e[t]),i)}}_Set(t,e){if(e<3)return this.SetAsBox(1,1);let i=e;const s=[];for(let e=0;e<i;++e){const i=t(e);let n=!0;for(let t=0;t<s.length;++t)if(ep.DistanceSquaredVV(i,s[t])<625e-8){n=!1;break}n&&s.push(i)}if(i=s.length,i<3)return this.SetAsBox(1,1);let n=0,r=s[0].x;for(let t=1;t<i;++t){const e=s[t].x;(e>r||e===r&&s[t].y<s[n].y)&&(n=t,r=e)}const o=[];let a=0,l=n;for(;;){o[a]=l;let t=0;for(let e=1;e<i;++e){if(t===l){t=e;continue}const i=ep.SubVV(s[t],s[o[a]],Ty.Set_s_r),n=ep.SubVV(s[e],s[o[a]],Ty.Set_s_v),r=ep.CrossVV(i,n);r<0&&(t=e),0===r&&n.LengthSquared()>i.LengthSquared()&&(t=e)}if(++a,l=t,t===n)break}this.m_count=a,this.m_vertices=ep.MakeArray(this.m_count),this.m_normals=ep.MakeArray(this.m_count);for(let t=0;t<a;++t)this.m_vertices[t].Copy(s[o[t]]);for(let t=0;t<a;++t){const e=this.m_vertices[t],i=this.m_vertices[(t+1)%a],s=ep.SubVV(i,e,ep.s_t0);ep.CrossVOne(s,this.m_normals[t]).SelfNormalize()}return Ty.ComputeCentroid(this.m_vertices,a,this.m_centroid),this}SetAsBox(t,e,i,s=0){if(this.m_count=4,this.m_vertices=ep.MakeArray(this.m_count),this.m_normals=ep.MakeArray(this.m_count),this.m_vertices[0].Set(-t,-e),this.m_vertices[1].Set(t,-e),this.m_vertices[2].Set(t,e),this.m_vertices[3].Set(-t,e),this.m_normals[0].Set(0,-1),this.m_normals[1].Set(1,0),this.m_normals[2].Set(0,1),this.m_normals[3].Set(-1,0),this.m_centroid.SetZero(),i){this.m_centroid.Copy(i);const t=new ap;t.SetPosition(i),t.SetRotationAngle(s);for(let e=0;e<this.m_count;++e)ap.MulXV(t,this.m_vertices[e],this.m_vertices[e]),op.MulRV(t.q,this.m_normals[e],this.m_normals[e])}return this}TestPoint(t,e){const i=ap.MulTXV(t,e,Ty.TestPoint_s_pLocal);for(let t=0;t<this.m_count;++t)if(ep.DotVV(this.m_normals[t],ep.SubVV(i,this.m_vertices[t],ep.s_t0))>0)return!1;return!0}ComputeDistance(t,e,i,s){const n=ap.MulTXV(t,e,Ty.ComputeDistance_s_pLocal);let r=-Id;const o=Ty.ComputeDistance_s_normalForMaxDistance.Copy(n);for(let t=0;t<this.m_count;++t){const e=ep.DotVV(this.m_normals[t],ep.SubVV(n,this.m_vertices[t],ep.s_t0));e>r&&(r=e,o.Copy(this.m_normals[t]))}if(r>0){const e=Ty.ComputeDistance_s_minDistance.Copy(o);let s=r*r;for(let t=0;t<this.m_count;++t){const i=ep.SubVV(n,this.m_vertices[t],Ty.ComputeDistance_s_distance),r=i.LengthSquared();s>r&&(e.Copy(i),s=r)}return op.MulRV(t.q,e,i),i.Normalize(),Math.sqrt(s)}return op.MulRV(t.q,o,i),r}RayCast(t,e,i,s){const n=ap.MulTXV(i,e.p1,Ty.RayCast_s_p1),r=ap.MulTXV(i,e.p2,Ty.RayCast_s_p2),o=ep.SubVV(r,n,Ty.RayCast_s_d);let a=0,l=e.maxFraction,h=-1;for(let t=0;t<this.m_count;++t){const e=ep.DotVV(this.m_normals[t],ep.SubVV(this.m_vertices[t],n,ep.s_t0)),i=ep.DotVV(this.m_normals[t],o);if(0===i){if(e<0)return!1}else i<0&&e<a*i?(a=e/i,h=t):i>0&&e<l*i&&(l=e/i);if(l<a)return!1}return h>=0&&(t.fraction=a,op.MulRV(i.q,this.m_normals[h],t.normal),!0)}ComputeAABB(t,e,i){const s=ap.MulXV(e,this.m_vertices[0],t.lowerBound),n=t.upperBound.Copy(s);for(let t=0;t<this.m_count;++t){const i=ap.MulXV(e,this.m_vertices[t],Ty.ComputeAABB_s_v);ep.MinV(i,s,s),ep.MaxV(i,n,n)}const r=this.m_radius;s.SelfSubXY(r,r),n.SelfAddXY(r,r)}ComputeMass(t,e){const i=Ty.ComputeMass_s_center.SetZero();let s=0,n=0;const r=Ty.ComputeMass_s_s.Copy(this.m_vertices[0]),o=1/3;for(let t=0;t<this.m_count;++t){const e=ep.SubVV(this.m_vertices[t],r,Ty.ComputeMass_s_e1),a=ep.SubVV(this.m_vertices[(t+1)%this.m_count],r,Ty.ComputeMass_s_e2),l=ep.CrossVV(e,a),h=.5*l;s+=h,i.SelfAdd(ep.MulSV(h*o,ep.AddVV(e,a,ep.s_t0),ep.s_t1));const c=e.x,m=e.y,u=a.x,_=a.y;n+=.25*o*l*(c*c+u*c+u*u+(m*m+_*m+_*_))}t.mass=e*s,i.SelfMul(1/s),ep.AddVV(i,r,t.center),t.I=e*n,t.I+=t.mass*(ep.DotVV(t.center,t.center)-ep.DotVV(i,i))}Validate(){for(let t=0;t<this.m_count;++t){const e=t,i=(t+1)%this.m_count,s=this.m_vertices[e],n=ep.SubVV(this.m_vertices[i],s,Ty.Validate_s_e);for(let t=0;t<this.m_count;++t){if(t===e||t===i)continue;const r=ep.SubVV(this.m_vertices[t],s,Ty.Validate_s_v);if(ep.CrossVV(n,r)<0)return!1}}return!0}SetupDistanceProxy(t,e){t.m_vertices=this.m_vertices,t.m_count=this.m_count,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){const n=op.MulTRV(i.q,t,Ty.ComputeSubmergedArea_s_normalL),r=e-ep.DotVV(t,i.p),o=[];let a=0,l=-1,h=-1,c=!1;for(let t=0;t<this.m_count;++t){o[t]=ep.DotVV(n,this.m_vertices[t])-r;const e=o[t]<-1e-5;t>0&&(e?c||(l=t-1,a++):c&&(h=t-1,a++)),c=e}switch(a){case 0:if(c){const t=Ty.ComputeSubmergedArea_s_md;return this.ComputeMass(t,1),ap.MulXV(i,t.center,s),t.mass}return 0;case 1:-1===l?l=this.m_count-1:h=this.m_count-1}const m=(l+1)%this.m_count,u=(h+1)%this.m_count,_=(0-o[l])/(o[m]-o[l]),d=(0-o[h])/(o[u]-o[h]),p=Ty.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[l].x*(1-_)+this.m_vertices[m].x*_,this.m_vertices[l].y*(1-_)+this.m_vertices[m].y*_),f=Ty.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[h].x*(1-d)+this.m_vertices[u].x*d,this.m_vertices[h].y*(1-d)+this.m_vertices[u].y*d);let y=0;const g=Ty.ComputeSubmergedArea_s_center.SetZero();let x,v=this.m_vertices[m],S=m;for(;S!==u;){S=(S+1)%this.m_count,x=S===u?f:this.m_vertices[S];const t=.5*((v.x-p.x)*(x.y-p.y)-(v.y-p.y)*(x.x-p.x));y+=t,g.x+=t*(p.x+v.x+x.x)/3,g.y+=t*(p.y+v.y+x.y)/3,v=x}return g.SelfMul(1/y),ap.MulXV(i,g,s),y}Dump(t){t("    const shape: b2PolygonShape = new b2PolygonShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new b2Vec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.Set(vs, %d);\n",this.m_count)}static ComputeCentroid(t,e,i){const s=i;s.SetZero();let n=0;const r=Ty.ComputeCentroid_s_s.Copy(t[0]),o=1/3;for(let i=0;i<e;++i){const a=ep.SubVV(t[0],r,Ty.ComputeCentroid_s_p1),l=ep.SubVV(t[i],r,Ty.ComputeCentroid_s_p2),h=ep.SubVV(t[(i+1)%e],r,Ty.ComputeCentroid_s_p3),c=ep.SubVV(l,a,Ty.ComputeCentroid_s_e1),m=ep.SubVV(h,a,Ty.ComputeCentroid_s_e2),u=.5*ep.CrossVV(c,m);n+=u,s.x+=u*o*(a.x+l.x+h.x),s.y+=u*o*(a.y+l.y+h.y)}return s.x=1/n*s.x+r.x,s.y=1/n*s.y+r.y,s}}Ty.Set_s_r=new ep,Ty.Set_s_v=new ep,Ty.TestPoint_s_pLocal=new ep,Ty.ComputeDistance_s_pLocal=new ep,Ty.ComputeDistance_s_normalForMaxDistance=new ep,Ty.ComputeDistance_s_minDistance=new ep,Ty.ComputeDistance_s_distance=new ep,Ty.RayCast_s_p1=new ep,Ty.RayCast_s_p2=new ep,Ty.RayCast_s_d=new ep,Ty.ComputeAABB_s_v=new ep,Ty.ComputeMass_s_center=new ep,Ty.ComputeMass_s_s=new ep,Ty.ComputeMass_s_e1=new ep,Ty.ComputeMass_s_e2=new ep,Ty.Validate_s_e=new ep,Ty.Validate_s_v=new ep,Ty.ComputeSubmergedArea_s_normalL=new ep,Ty.ComputeSubmergedArea_s_md=new by,Ty.ComputeSubmergedArea_s_intoVec=new ep,Ty.ComputeSubmergedArea_s_outoVec=new ep,Ty.ComputeSubmergedArea_s_center=new ep,Ty.ComputeCentroid_s_s=new ep,Ty.ComputeCentroid_s_p1=new ep,Ty.ComputeCentroid_s_p2=new ep,Ty.ComputeCentroid_s_p3=new ep,Ty.ComputeCentroid_s_e1=new ep,Ty.ComputeCentroid_s_e2=new ep;class Py extends My{constructor(){super(Cy.e_edgeShape,kd),this.m_vertex1=new ep,this.m_vertex2=new ep,this.m_vertex0=new ep,this.m_vertex3=new ep,this.m_oneSided=!1}SetOneSided(t,e,i,s){return this.m_vertex0.Copy(t),this.m_vertex1.Copy(e),this.m_vertex2.Copy(i),this.m_vertex3.Copy(s),this.m_oneSided=!0,this}SetTwoSided(t,e){return this.m_vertex1.Copy(t),this.m_vertex2.Copy(e),this.m_oneSided=!1,this}Clone(){return(new Py).Copy(this)}Copy(t){return super.Copy(t),this.m_vertex1.Copy(t.m_vertex1),this.m_vertex2.Copy(t.m_vertex2),this.m_vertex0.Copy(t.m_vertex0),this.m_vertex3.Copy(t.m_vertex3),this.m_oneSided=t.m_oneSided,this}GetChildCount(){return 1}TestPoint(t,e){return!1}ComputeDistance(t,e,i,s){const n=ap.MulXV(t,this.m_vertex1,Py.ComputeDistance_s_v1),r=ap.MulXV(t,this.m_vertex2,Py.ComputeDistance_s_v2),o=ep.SubVV(e,n,Py.ComputeDistance_s_d),a=ep.SubVV(r,n,Py.ComputeDistance_s_s),l=ep.DotVV(o,a);if(l>0){const t=ep.DotVV(a,a);l>t?ep.SubVV(e,r,o):o.SelfMulSub(l/t,a)}return i.Copy(o),i.Normalize()}RayCast(t,e,i,s){const n=ap.MulTXV(i,e.p1,Py.RayCast_s_p1),r=ap.MulTXV(i,e.p2,Py.RayCast_s_p2),o=ep.SubVV(r,n,Py.RayCast_s_d),a=this.m_vertex1,l=this.m_vertex2,h=ep.SubVV(l,a,Py.RayCast_s_e),c=t.normal.Set(h.y,-h.x).SelfNormalize(),m=ep.DotVV(c,ep.SubVV(a,n,ep.s_t0));if(this.m_oneSided&&m>0)return!1;const u=ep.DotVV(c,o);if(0===u)return!1;const _=m/u;if(_<0||e.maxFraction<_)return!1;const d=ep.AddVMulSV(n,_,o,Py.RayCast_s_q),p=ep.SubVV(l,a,Py.RayCast_s_r),f=ep.DotVV(p,p);if(0===f)return!1;const y=ep.DotVV(ep.SubVV(d,a,ep.s_t0),p)/f;return!(y<0||1<y||(t.fraction=_,op.MulRV(i.q,t.normal,t.normal),m>0&&t.normal.SelfNeg(),0))}ComputeAABB(t,e,i){const s=ap.MulXV(e,this.m_vertex1,Py.ComputeAABB_s_v1),n=ap.MulXV(e,this.m_vertex2,Py.ComputeAABB_s_v2);ep.MinV(s,n,t.lowerBound),ep.MaxV(s,n,t.upperBound);const r=this.m_radius;t.lowerBound.SelfSubXY(r,r),t.upperBound.SelfAddXY(r,r)}ComputeMass(t,e){t.mass=0,ep.MidVV(this.m_vertex1,this.m_vertex2,t.center),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertex1),t.m_vertices[1].Copy(this.m_vertex2),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){return s.SetZero(),0}Dump(t){t("    const shape: b2EdgeShape = new b2EdgeShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_vertex0.Set(%.15f, %.15f);\n",this.m_vertex0.x,this.m_vertex0.y),t("    shape.m_vertex1.Set(%.15f, %.15f);\n",this.m_vertex1.x,this.m_vertex1.y),t("    shape.m_vertex2.Set(%.15f, %.15f);\n",this.m_vertex2.x,this.m_vertex2.y),t("    shape.m_vertex3.Set(%.15f, %.15f);\n",this.m_vertex3.x,this.m_vertex3.y),t("    shape.m_oneSided = %s;\n",this.m_oneSided)}}Py.ComputeDistance_s_v1=new ep,Py.ComputeDistance_s_v2=new ep,Py.ComputeDistance_s_d=new ep,Py.ComputeDistance_s_s=new ep,Py.RayCast_s_p1=new ep,Py.RayCast_s_p2=new ep,Py.RayCast_s_d=new ep,Py.RayCast_s_e=new ep,Py.RayCast_s_q=new ep,Py.RayCast_s_r=new ep,Py.ComputeAABB_s_v1=new ep,Py.ComputeAABB_s_v2=new ep;class Dy extends My{constructor(){super(Cy.e_chainShape,kd),this.m_vertices=[],this.m_count=0,this.m_prevVertex=new ep,this.m_nextVertex=new ep}CreateLoop(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._CreateLoop((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2)}{const e=t[0];return this._CreateLoop((t=>e[t]),e.length)}}_CreateLoop(t,e){if(e<3)return this;this.m_count=e+1,this.m_vertices=ep.MakeArray(this.m_count);for(let i=0;i<e;++i)this.m_vertices[i].Copy(t(i));return this.m_vertices[e].Copy(this.m_vertices[0]),this.m_prevVertex.Copy(this.m_vertices[this.m_count-2]),this.m_nextVertex.Copy(this.m_vertices[1]),this}CreateChain(...t){if("number"==typeof t[0][0]){const e=t[0],i=t[1],s=t[2];if(e.length%2!=0)throw new Error;return this._CreateChain((t=>({x:e[2*t],y:e[2*t+1]})),e.length/2,i,s)}{const e=t[0],i=t[1],s=t[2];return this._CreateChain((t=>e[t]),e.length,i,s)}}_CreateChain(t,e,i,s){this.m_count=e,this.m_vertices=ep.MakeArray(e);for(let i=0;i<e;++i)this.m_vertices[i].Copy(t(i));return this.m_prevVertex.Copy(i),this.m_nextVertex.Copy(s),this}Clone(){return(new Dy).Copy(this)}Copy(t){return super.Copy(t),this._CreateChain((e=>t.m_vertices[e]),t.m_count,t.m_prevVertex,t.m_nextVertex),this.m_prevVertex.Copy(t.m_prevVertex),this.m_nextVertex.Copy(t.m_nextVertex),this}GetChildCount(){return this.m_count-1}GetChildEdge(t,e){t.m_radius=this.m_radius,t.m_vertex1.Copy(this.m_vertices[e]),t.m_vertex2.Copy(this.m_vertices[e+1]),t.m_oneSided=!0,e>0?t.m_vertex0.Copy(this.m_vertices[e-1]):t.m_vertex0.Copy(this.m_prevVertex),e<this.m_count-2?t.m_vertex3.Copy(this.m_vertices[e+2]):t.m_vertex3.Copy(this.m_nextVertex)}TestPoint(t,e){return!1}ComputeDistance(t,e,i,s){const n=Dy.ComputeDistance_s_edgeShape;return this.GetChildEdge(n,s),n.ComputeDistance(t,e,i,0)}RayCast(t,e,i,s){const n=Dy.RayCast_s_edgeShape;return n.m_vertex1.Copy(this.m_vertices[s]),n.m_vertex2.Copy(this.m_vertices[(s+1)%this.m_count]),n.RayCast(t,e,i,0)}ComputeAABB(t,e,i){const s=this.m_vertices[i],n=this.m_vertices[(i+1)%this.m_count],r=ap.MulXV(e,s,Dy.ComputeAABB_s_v1),o=ap.MulXV(e,n,Dy.ComputeAABB_s_v2),a=ep.MinV(r,o,Dy.ComputeAABB_s_lower),l=ep.MaxV(r,o,Dy.ComputeAABB_s_upper);t.lowerBound.x=a.x-this.m_radius,t.lowerBound.y=a.y-this.m_radius,t.upperBound.x=l.x+this.m_radius,t.upperBound.y=l.y+this.m_radius}ComputeMass(t,e){t.mass=0,t.center.SetZero(),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertices[e]),e+1<this.m_count?t.m_vertices[1].Copy(this.m_vertices[e+1]):t.m_vertices[1].Copy(this.m_vertices[0]),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,i,s){return s.SetZero(),0}Dump(t){t("    const shape: b2ChainShape = new b2ChainShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new bVec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.CreateChain(vs, %d);\n",this.m_count),t("    shape.m_prevVertex.Set(%.15f, %.15f);\n",this.m_prevVertex.x,this.m_prevVertex.y),t("    shape.m_nextVertex.Set(%.15f, %.15f);\n",this.m_nextVertex.x,this.m_nextVertex.y)}}Dy.ComputeDistance_s_edgeShape=new Py,Dy.RayCast_s_edgeShape=new Py,Dy.ComputeAABB_s_v1=new ep,Dy.ComputeAABB_s_v2=new ep,Dy.ComputeAABB_s_lower=new ep,Dy.ComputeAABB_s_upper=new ep;class Iy{constructor(){this.categoryBits=1,this.maskBits=65535,this.groupIndex=0}Clone(){return(new Iy).Copy(this)}Copy(t){return this.categoryBits=t.categoryBits,this.maskBits=t.maskBits,this.groupIndex=t.groupIndex||0,this}}Iy.DEFAULT=new Iy;class Ey{constructor(){this.userData=null,this.friction=.2,this.restitution=0,this.restitutionThreshold=1,this.density=0,this.isSensor=!1,this.filter=new Iy}}class Ry{constructor(t,e){this.aabb=new Op,this.childIndex=0,this.fixture=t,this.childIndex=e,this.fixture.m_shape.ComputeAABB(this.aabb,this.fixture.m_body.GetTransform(),e),this.treeNode=this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb,this)}Reset(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode)}Touch(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode)}Synchronize(t,e){if(t===e)this.fixture.m_shape.ComputeAABB(this.aabb,t,this.childIndex),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,ep.ZERO);else{const i=Ry.Synchronize_s_aabb1,s=Ry.Synchronize_s_aabb2;this.fixture.m_shape.ComputeAABB(i,t,this.childIndex),this.fixture.m_shape.ComputeAABB(s,e,this.childIndex),this.aabb.Combine2(i,s);const n=Ry.Synchronize_s_displacement;n.Copy(s.GetCenter()).SelfSub(i.GetCenter()),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,n)}}}Ry.Synchronize_s_aabb1=new Op,Ry.Synchronize_s_aabb2=new Op,Ry.Synchronize_s_displacement=new ep;class Ly{constructor(t,e){this.m_density=0,this.m_next=null,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=1,this.m_proxies=[],this.m_filter=new Iy,this.m_isSensor=!1,this.m_userData=null,this.m_body=t,this.m_shape=e.shape.Clone(),this.m_userData=Dd(e.userData,null),this.m_friction=Dd(e.friction,.2),this.m_restitution=Dd(e.restitution,0),this.m_restitutionThreshold=Dd(e.restitutionThreshold,0),this.m_filter.Copy(Dd(e.filter,Iy.DEFAULT)),this.m_isSensor=Dd(e.isSensor,!1),this.m_density=Dd(e.density,0)}get m_proxyCount(){return this.m_proxies.length}Reset(){}GetType(){return this.m_shape.GetType()}GetShape(){return this.m_shape}SetSensor(t){t!==this.m_isSensor&&(this.m_body.SetAwake(!0),this.m_isSensor=t)}IsSensor(){return this.m_isSensor}SetFilterData(t){this.m_filter.Copy(t),this.Refilter()}GetFilterData(){return this.m_filter}Refilter(){let t=this.m_body.GetContactList();for(;t;){const e=t.contact,i=e.GetFixtureA(),s=e.GetFixtureB();i!==this&&s!==this||e.FlagForFiltering(),t=t.next}this.TouchProxies()}GetBody(){return this.m_body}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}TestPoint(t){return this.m_shape.TestPoint(this.m_body.GetTransform(),t)}ComputeDistance(t,e,i){return this.m_shape.ComputeDistance(this.m_body.GetTransform(),t,e,i)}RayCast(t,e,i){return this.m_shape.RayCast(t,e,this.m_body.GetTransform(),i)}GetMassData(t=new by){return this.m_shape.ComputeMass(t,this.m_density),t}SetDensity(t){this.m_density=t}GetDensity(){return this.m_density}GetFriction(){return this.m_friction}SetFriction(t){this.m_friction=t}GetRestitution(){return this.m_restitution}SetRestitution(t){this.m_restitution=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetAABB(t){return this.m_proxies[t].aabb}Dump(t,e){t("    const fd: b2FixtureDef = new b2FixtureDef();\n"),t("    fd.friction = %.15f;\n",this.m_friction),t("    fd.restitution = %.15f;\n",this.m_restitution),t("    fd.restitutionThreshold = %.15f;\n",this.m_restitutionThreshold),t("    fd.density = %.15f;\n",this.m_density),t("    fd.isSensor = %s;\n",this.m_isSensor?"true":"false"),t("    fd.filter.categoryBits = %d;\n",this.m_filter.categoryBits),t("    fd.filter.maskBits = %d;\n",this.m_filter.maskBits),t("    fd.filter.groupIndex = %d;\n",this.m_filter.groupIndex),this.m_shape.Dump(t),t("\n"),t("    fd.shape = shape;\n"),t("\n"),t("    bodies[%d].CreateFixture(fd);\n",e)}CreateProxies(){if(0!==this.m_proxies.length)throw new Error;for(let t=0;t<this.m_shape.GetChildCount();++t)this.m_proxies[t]=new Ry(this,t)}DestroyProxies(){for(const t of this.m_proxies)t.Reset();this.m_proxies.length=0}TouchProxies(){for(const t of this.m_proxies)t.Touch()}SynchronizeProxies(t,e){for(const i of this.m_proxies)i.Synchronize(t,e)}}!function(t){t[t.b2_unknown=-1]="b2_unknown",t[t.b2_staticBody=0]="b2_staticBody",t[t.b2_kinematicBody=1]="b2_kinematicBody",t[t.b2_dynamicBody=2]="b2_dynamicBody"}(Ay||(Ay={}));class Gy{constructor(){this.type=Ay.b2_staticBody,this.position=new ep(0,0),this.angle=0,this.linearVelocity=new ep(0,0),this.angularVelocity=0,this.linearDamping=0,this.angularDamping=0,this.allowSleep=!0,this.awake=!0,this.fixedRotation=!1,this.bullet=!1,this.enabled=!0,this.userData=null,this.gravityScale=1}}class Fy{constructor(t,e){this.m_type=Ay.b2_staticBody,this.m_islandFlag=!1,this.m_awakeFlag=!1,this.m_autoSleepFlag=!1,this.m_bulletFlag=!1,this.m_fixedRotationFlag=!1,this.m_enabledFlag=!1,this.m_toiFlag=!1,this.m_islandIndex=0,this.m_xf=new ap,this.m_xf0=new ap,this.m_sweep=new lp,this.m_linearVelocity=new ep,this.m_angularVelocity=0,this.m_force=new ep,this.m_torque=0,this.m_prev=null,this.m_next=null,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_jointList=null,this.m_contactList=null,this.m_mass=1,this.m_invMass=1,this.m_I=0,this.m_invI=0,this.m_linearDamping=0,this.m_angularDamping=0,this.m_gravityScale=1,this.m_sleepTime=0,this.m_userData=null,this.m_controllerList=null,this.m_controllerCount=0,this.m_bulletFlag=Dd(t.bullet,!1),this.m_fixedRotationFlag=Dd(t.fixedRotation,!1),this.m_autoSleepFlag=Dd(t.allowSleep,!0),Dd(t.awake,!0)&&Dd(t.type,Ay.b2_staticBody)!==Ay.b2_staticBody&&(this.m_awakeFlag=!0),this.m_enabledFlag=Dd(t.enabled,!0),this.m_world=e,this.m_xf.p.Copy(Dd(t.position,ep.ZERO)),this.m_xf.q.SetAngle(Dd(t.angle,0)),this.m_xf0.Copy(this.m_xf),this.m_sweep.localCenter.SetZero(),this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle(),this.m_sweep.alpha0=0,this.m_linearVelocity.Copy(Dd(t.linearVelocity,ep.ZERO)),this.m_angularVelocity=Dd(t.angularVelocity,0),this.m_linearDamping=Dd(t.linearDamping,0),this.m_angularDamping=Dd(t.angularDamping,0),this.m_gravityScale=Dd(t.gravityScale,1),this.m_force.SetZero(),this.m_torque=0,this.m_sleepTime=0,this.m_type=Dd(t.type,Ay.b2_staticBody),this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_userData=t.userData,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_controllerList=null,this.m_controllerCount=0}CreateFixture(t,e=0){return t instanceof My?this.CreateFixtureShapeDensity(t,e):this.CreateFixtureDef(t)}CreateFixtureDef(t){if(this.m_world.IsLocked())throw new Error;const e=new Ly(this,t);return this.m_enabledFlag&&e.CreateProxies(),e.m_next=this.m_fixtureList,this.m_fixtureList=e,++this.m_fixtureCount,e.m_density>0&&this.ResetMassData(),this.m_world.m_newContacts=!0,e}CreateFixtureShapeDensity(t,e=0){const i=Fy.CreateFixtureShapeDensity_s_def;return i.shape=t,i.density=e,this.CreateFixtureDef(i)}DestroyFixture(t){if(this.m_world.IsLocked())throw new Error;let e=this.m_fixtureList,i=null;for(;null!==e;){if(e===t){i?i.m_next=t.m_next:this.m_fixtureList=t.m_next;break}i=e,e=e.m_next}let s=this.m_contactList;for(;s;){const e=s.contact;s=s.next;const i=e.GetFixtureA(),n=e.GetFixtureB();t!==i&&t!==n||this.m_world.m_contactManager.Destroy(e)}this.m_enabledFlag&&t.DestroyProxies(),t.m_next=null,t.Reset(),--this.m_fixtureCount,this.ResetMassData()}SetTransformVec(t,e){this.SetTransformXY(t.x,t.y,e)}SetTransformXY(t,e,i){if(this.m_world.IsLocked())throw new Error;this.m_xf.q.SetAngle(i),this.m_xf.p.Set(t,e),this.m_xf0.Copy(this.m_xf),ap.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.a=i,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_sweep.a0=i;for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf);this.m_world.m_newContacts=!0}SetTransform(t){this.SetTransformVec(t.p,t.GetAngle())}GetTransform(){return this.m_xf}GetPosition(){return this.m_xf.p}SetPosition(t){this.SetTransformVec(t,this.GetAngle())}SetPositionXY(t,e){this.SetTransformXY(t,e,this.GetAngle())}GetAngle(){return this.m_sweep.a}SetAngle(t){this.SetTransformVec(this.GetPosition(),t)}GetWorldCenter(){return this.m_sweep.c}GetLocalCenter(){return this.m_sweep.localCenter}SetLinearVelocity(t){this.m_type!==Ay.b2_staticBody&&(ep.DotVV(t,t)>0&&this.SetAwake(!0),this.m_linearVelocity.Copy(t))}GetLinearVelocity(){return this.m_linearVelocity}SetAngularVelocity(t){this.m_type!==Ay.b2_staticBody&&(t*t>0&&this.SetAwake(!0),this.m_angularVelocity=t)}GetAngularVelocity(){return this.m_angularVelocity}GetDefinition(t){return t.type=this.GetType(),t.allowSleep=this.m_autoSleepFlag,t.angle=this.GetAngle(),t.angularDamping=this.m_angularDamping,t.gravityScale=this.m_gravityScale,t.angularVelocity=this.m_angularVelocity,t.fixedRotation=this.m_fixedRotationFlag,t.bullet=this.m_bulletFlag,t.awake=this.m_awakeFlag,t.linearDamping=this.m_linearDamping,t.linearVelocity.Copy(this.GetLinearVelocity()),t.position.Copy(this.GetPosition()),t.userData=this.GetUserData(),t}ApplyForce(t,e,i=!0){this.m_type===Ay.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y,this.m_torque+=(e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x))}ApplyForceToCenter(t,e=!0){this.m_type===Ay.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y))}ApplyTorque(t,e=!0){this.m_type===Ay.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_torque+=t))}ApplyLinearImpulse(t,e,i=!0){this.m_type===Ay.b2_dynamicBody&&(i&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y,this.m_angularVelocity+=this.m_invI*((e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x)))}ApplyLinearImpulseToCenter(t,e=!0){this.m_type===Ay.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y))}ApplyAngularImpulse(t,e=!0){this.m_type===Ay.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*t))}GetMass(){return this.m_mass}GetInertia(){return this.m_I+this.m_mass*ep.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter)}GetMassData(t){return t.mass=this.m_mass,t.I=this.m_I+this.m_mass*ep.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter),t.center.Copy(this.m_sweep.localCenter),t}SetMassData(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type!==Ay.b2_dynamicBody)return;this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=t.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,t.I>0&&!this.m_fixedRotationFlag&&(this.m_I=t.I-this.m_mass*ep.DotVV(t.center,t.center),this.m_invI=1/this.m_I);const e=Fy.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t.center),ap.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),ep.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,ep.SubVV(this.m_sweep.c,e,ep.s_t0),this.m_linearVelocity)}ResetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_sweep.localCenter.SetZero(),this.m_type===Ay.b2_staticBody||this.m_type===Ay.b2_kinematicBody)return this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);const t=Fy.ResetMassData_s_localCenter.SetZero();for(let e=this.m_fixtureList;e;e=e.m_next){if(0===e.m_density)continue;const i=e.GetMassData(Fy.ResetMassData_s_massData);this.m_mass+=i.mass,t.x+=i.center.x*i.mass,t.y+=i.center.y*i.mass,this.m_I+=i.I}this.m_mass>0&&(this.m_invMass=1/this.m_mass,t.x*=this.m_invMass,t.y*=this.m_invMass),this.m_I>0&&!this.m_fixedRotationFlag?(this.m_I-=this.m_mass*ep.DotVV(t,t),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0);const e=Fy.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t),ap.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),ep.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,ep.SubVV(this.m_sweep.c,e,ep.s_t0),this.m_linearVelocity)}GetWorldPoint(t,e){return ap.MulXV(this.m_xf,t,e)}GetWorldVector(t,e){return op.MulRV(this.m_xf.q,t,e)}GetLocalPoint(t,e){return ap.MulTXV(this.m_xf,t,e)}GetLocalVector(t,e){return op.MulTRV(this.m_xf.q,t,e)}GetLinearVelocityFromWorldPoint(t,e){return ep.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,ep.SubVV(t,this.m_sweep.c,ep.s_t0),e)}GetLinearVelocityFromLocalPoint(t,e){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t,e),e)}GetLinearDamping(){return this.m_linearDamping}SetLinearDamping(t){this.m_linearDamping=t}GetAngularDamping(){return this.m_angularDamping}SetAngularDamping(t){this.m_angularDamping=t}GetGravityScale(){return this.m_gravityScale}SetGravityScale(t){this.m_gravityScale=t}SetType(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type===t)return;this.m_type=t,this.ResetMassData(),this.m_type===Ay.b2_staticBody&&(this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_sweep.a0=this.m_sweep.a,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_awakeFlag=!1,this.SynchronizeFixtures()),this.SetAwake(!0),this.m_force.SetZero(),this.m_torque=0;let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.m_contactManager.Destroy(t.contact)}this.m_contactList=null;for(let t=this.m_fixtureList;t;t=t.m_next)t.TouchProxies()}GetType(){return this.m_type}SetBullet(t){this.m_bulletFlag=t}IsBullet(){return this.m_bulletFlag}SetSleepingAllowed(t){this.m_autoSleepFlag=t,t||this.SetAwake(!0)}IsSleepingAllowed(){return this.m_autoSleepFlag}SetAwake(t){this.m_type!==Ay.b2_staticBody&&(t?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_force.SetZero(),this.m_torque=0))}IsAwake(){return this.m_awakeFlag}SetEnabled(t){if(this.m_world.IsLocked())throw new Error;if(t!==this.IsEnabled())if(this.m_enabledFlag=t,t){for(let t=this.m_fixtureList;t;t=t.m_next)t.CreateProxies();this.m_world.m_newContacts=!0}else{for(let t=this.m_fixtureList;t;t=t.m_next)t.DestroyProxies();let t=this.m_contactList;for(;t;){const e=t;t=t.next,this.m_world.m_contactManager.Destroy(e.contact)}this.m_contactList=null}}IsEnabled(){return this.m_enabledFlag}SetFixedRotation(t){this.m_fixedRotationFlag!==t&&(this.m_fixedRotationFlag=t,this.m_angularVelocity=0,this.ResetMassData())}IsFixedRotation(){return this.m_fixedRotationFlag}GetFixtureList(){return this.m_fixtureList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactList}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}GetWorld(){return this.m_world}Dump(t){const e=this.m_islandIndex;t("{\n"),t("  const bd: b2BodyDef = new b2BodyDef();\n");let i="";switch(this.m_type){case Ay.b2_staticBody:i="b2BodyType.b2_staticBody";break;case Ay.b2_kinematicBody:i="b2BodyType.b2_kinematicBody";break;case Ay.b2_dynamicBody:i="b2BodyType.b2_dynamicBody"}t("  bd.type = %s;\n",i),t("  bd.position.Set(%.15f, %.15f);\n",this.m_xf.p.x,this.m_xf.p.y),t("  bd.angle = %.15f;\n",this.m_sweep.a),t("  bd.linearVelocity.Set(%.15f, %.15f);\n",this.m_linearVelocity.x,this.m_linearVelocity.y),t("  bd.angularVelocity = %.15f;\n",this.m_angularVelocity),t("  bd.linearDamping = %.15f;\n",this.m_linearDamping),t("  bd.angularDamping = %.15f;\n",this.m_angularDamping),t("  bd.allowSleep = %s;\n",this.m_autoSleepFlag?"true":"false"),t("  bd.awake = %s;\n",this.m_awakeFlag?"true":"false"),t("  bd.fixedRotation = %s;\n",this.m_fixedRotationFlag?"true":"false"),t("  bd.bullet = %s;\n",this.m_bulletFlag?"true":"false"),t("  bd.active = %s;\n",this.m_enabledFlag?"true":"false"),t("  bd.gravityScale = %.15f;\n",this.m_gravityScale),t("\n"),t("  bodies[%d] = this.m_world.CreateBody(bd);\n",this.m_islandIndex),t("\n");for(let i=this.m_fixtureList;i;i=i.m_next)t("  {\n"),i.Dump(t,e),t("  }\n");t("}\n")}SynchronizeFixtures(){if(this.m_awakeFlag){const t=Fy.SynchronizeFixtures_s_xf1;t.q.SetAngle(this.m_sweep.a0),op.MulRV(t.q,this.m_sweep.localCenter,t.p),ep.SubVV(this.m_sweep.c0,t.p,t.p);for(let e=this.m_fixtureList;e;e=e.m_next)e.SynchronizeProxies(t,this.m_xf)}else for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf)}SynchronizeTransform(){this.m_xf.q.SetAngle(this.m_sweep.a),op.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),ep.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}ShouldCollide(t){return(this.m_type!==Ay.b2_staticBody||t.m_type!==Ay.b2_staticBody)&&this.ShouldCollideConnected(t)}ShouldCollideConnected(t){for(let e=this.m_jointList;e;e=e.next)if(e.other===t&&!e.joint.m_collideConnected)return!1;return!0}Advance(t){this.m_sweep.Advance(t),this.m_sweep.c.Copy(this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_xf.q.SetAngle(this.m_sweep.a),op.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),ep.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}GetControllerList(){return this.m_controllerList}GetControllerCount(){return this.m_controllerCount}}Fy.CreateFixtureShapeDensity_s_def=new Ey,Fy.SetMassData_s_oldCenter=new ep,Fy.ResetMassData_s_localCenter=new ep,Fy.ResetMassData_s_oldCenter=new ep,Fy.ResetMassData_s_massData=new by,Fy.SynchronizeFixtures_s_xf1=new ap,function(t){t[t.e_unknownJoint=0]="e_unknownJoint",t[t.e_revoluteJoint=1]="e_revoluteJoint",t[t.e_prismaticJoint=2]="e_prismaticJoint",t[t.e_distanceJoint=3]="e_distanceJoint",t[t.e_pulleyJoint=4]="e_pulleyJoint",t[t.e_mouseJoint=5]="e_mouseJoint",t[t.e_gearJoint=6]="e_gearJoint",t[t.e_wheelJoint=7]="e_wheelJoint",t[t.e_weldJoint=8]="e_weldJoint",t[t.e_frictionJoint=9]="e_frictionJoint",t[t.e_ropeJoint=10]="e_ropeJoint",t[t.e_motorJoint=11]="e_motorJoint",t[t.e_areaJoint=12]="e_areaJoint"}(By||(By={}));class ky{constructor(t){this._other=null,this.prev=null,this.next=null,this.joint=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class zy{constructor(t){this.m_type=By.e_unknownJoint,this.m_prev=null,this.m_next=null,this.m_edgeA=new ky(this),this.m_edgeB=new ky(this),this.m_index=0,this.m_islandFlag=!1,this.m_collideConnected=!1,this.m_userData=null,this.m_type=t.type,this.m_edgeA.other=t.bodyB,this.m_edgeB.other=t.bodyA,this.m_bodyA=t.bodyA,this.m_bodyB=t.bodyB,this.m_collideConnected=Dd(t.collideConnected,!1),this.m_userData=Dd(t.userData,null)}GetType(){return this.m_type}GetBodyA(){return this.m_bodyA}GetBodyB(){return this.m_bodyB}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}IsEnabled(){return this.m_bodyA.IsEnabled()&&this.m_bodyB.IsEnabled()}GetCollideConnected(){return this.m_collideConnected}Dump(t){t("// Dump is not supported for this joint type.\n")}ShiftOrigin(t){}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=e.p,n=i.p,r=this.GetAnchorA(zy.Draw_s_p1),o=this.GetAnchorB(zy.Draw_s_p2),a=zy.Draw_s_color.SetRGB(.5,.8,.8);switch(this.m_type){case By.e_distanceJoint:t.DrawSegment(r,o,a);break;case By.e_pulleyJoint:{const e=this,i=e.GetGroundAnchorA(),s=e.GetGroundAnchorB();t.DrawSegment(i,r,a),t.DrawSegment(s,o,a),t.DrawSegment(i,s,a)}break;case By.e_mouseJoint:{const e=zy.Draw_s_c;e.Set(0,1,0),t.DrawPoint(r,4,e),t.DrawPoint(o,4,e),e.Set(.8,.8,.8),t.DrawSegment(r,o,e)}break;default:t.DrawSegment(s,r,a),t.DrawSegment(r,o,a),t.DrawSegment(n,o,a)}}}zy.Draw_s_p1=new ep,zy.Draw_s_p2=new ep,zy.Draw_s_color=new hp(.5,.8,.8),zy.Draw_s_c=new hp;class Oy extends class{constructor(t){this.type=By.e_unknownJoint,this.userData=null,this.collideConnected=!1,this.type=t}}{constructor(){super(By.e_distanceJoint),this.localAnchorA=new ep,this.localAnchorB=new ep,this.length=1,this.minLength=0,this.maxLength=Id,this.stiffness=0,this.damping=0}Initialize(t,e,i,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(i,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.length=Jd(ep.DistanceVV(i,s),Gd),this.minLength=this.length,this.maxLength=this.length}}class Ny extends zy{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_length=0,this.m_minLength=0,this.m_maxLength=0,this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_gamma=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_u=new ep,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_currentLength=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_softMass=0,this.m_mass=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_length=Jd(Dd(t.length,this.GetCurrentLength()),Gd),this.m_minLength=Jd(Dd(t.minLength,this.m_length),Gd),this.m_maxLength=Jd(Dd(t.maxLength,this.m_length),this.m_minLength),this.m_stiffness=Dd(t.stiffness,0),this.m_damping=Dd(t.damping,0)}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.x,e.y=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.y,e}GetReactionTorque(t){return 0}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetLength(t){return this.m_impulse=0,this.m_length=Jd(Gd,t),this.m_length}GetLength(){return this.m_length}SetMinLength(t){return this.m_lowerImpulse=0,this.m_minLength=Zd(t,Gd,this.m_maxLength),this.m_minLength}SetMaxLength(t){return this.m_upperImpulse=0,this.m_maxLength=Jd(t,this.m_minLength),this.m_maxLength}GetCurrentLength(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,new ep),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,new ep);return ep.DistanceVV(t,e)}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.length = %.15f;\n",this.m_length),t("  jd.minLength = %.15f;\n",this.m_minLength),t("  jd.maxLength = %.15f;\n",this.m_maxLength),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),op.MulRV(h,this.m_lalcA,this.m_rA),ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),op.MulRV(c,this.m_lalcB,this.m_rB),this.m_u.x=r.x+this.m_rB.x-e.x-this.m_rA.x,this.m_u.y=r.y+this.m_rB.y-e.y-this.m_rA.y,this.m_currentLength=this.m_u.Length(),this.m_currentLength>Gd?this.m_u.SelfMul(1/this.m_currentLength):(this.m_u.SetZero(),this.m_mass=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0);const m=ep.CrossVV(this.m_rA,this.m_u),u=ep.CrossVV(this.m_rB,this.m_u);let _=this.m_invMassA+this.m_invIA*m*m+this.m_invMassB+this.m_invIB*u*u;if(this.m_mass=0!==_?1/_:0,this.m_stiffness>0&&this.m_minLength<this.m_maxLength){const e=this.m_currentLength-this.m_length,i=this.m_damping,s=this.m_stiffness,n=t.step.dt;this.m_gamma=n*(i+n*s),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=e*n*s*this.m_gamma,_+=this.m_gamma,this.m_softMass=0!==_?1/_:0}else this.m_gamma=0,this.m_bias=0,this.m_softMass=this.m_mass;if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=ep.MulSV(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse,this.m_u,Ny.InitVelocityConstraints_s_P);s.SelfMulSub(this.m_invMassA,e),n-=this.m_invIA*ep.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,e),l+=this.m_invIB*ep.CrossVV(this.m_rB,e)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;if(this.m_minLength<this.m_maxLength){if(this.m_stiffness>0){const t=ep.AddVCrossSV(e,i,this.m_rA,Ny.SolveVelocityConstraints_s_vpA),r=ep.AddVCrossSV(s,n,this.m_rB,Ny.SolveVelocityConstraints_s_vpB),o=ep.DotVV(this.m_u,ep.SubVV(r,t,ep.s_t0)),a=-this.m_softMass*(o+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=a;const l=ep.MulSV(a,this.m_u,Ny.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),i-=this.m_invIA*ep.CrossVV(this.m_rA,l),s.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*ep.CrossVV(this.m_rB,l)}{const r=Jd(0,this.m_currentLength-this.m_minLength)*t.step.inv_dt,o=ep.AddVCrossSV(e,i,this.m_rA,Ny.SolveVelocityConstraints_s_vpA),a=ep.AddVCrossSV(s,n,this.m_rB,Ny.SolveVelocityConstraints_s_vpB),l=ep.DotVV(this.m_u,ep.SubVV(a,o,ep.s_t0));let h=-this.m_mass*(l+r);const c=this.m_lowerImpulse;this.m_lowerImpulse=Jd(0,this.m_lowerImpulse+h),h=this.m_lowerImpulse-c;const m=ep.MulSV(h,this.m_u,Ny.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),i-=this.m_invIA*ep.CrossVV(this.m_rA,m),s.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*ep.CrossVV(this.m_rB,m)}{const r=Jd(0,this.m_maxLength-this.m_currentLength)*t.step.inv_dt,o=ep.AddVCrossSV(e,i,this.m_rA,Ny.SolveVelocityConstraints_s_vpA),a=ep.AddVCrossSV(s,n,this.m_rB,Ny.SolveVelocityConstraints_s_vpB),l=ep.DotVV(this.m_u,ep.SubVV(o,a,ep.s_t0));let h=-this.m_mass*(l+r);const c=this.m_upperImpulse;this.m_upperImpulse=Jd(0,this.m_upperImpulse+h),h=this.m_upperImpulse-c;const m=ep.MulSV(-h,this.m_u,Ny.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),i-=this.m_invIA*ep.CrossVV(this.m_rA,m),s.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*ep.CrossVV(this.m_rB,m)}}else{const t=ep.AddVCrossSV(e,i,this.m_rA,Ny.SolveVelocityConstraints_s_vpA),r=ep.AddVCrossSV(s,n,this.m_rB,Ny.SolveVelocityConstraints_s_vpB),o=ep.DotVV(this.m_u,ep.SubVV(r,t,ep.s_t0)),a=-this.m_mass*o;this.m_impulse+=a;const l=ep.MulSV(a,this.m_u,Ny.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,l),i-=this.m_invIA*ep.CrossVV(this.m_rA,l),s.SelfMulAdd(this.m_invMassB,l),n+=this.m_invIB*ep.CrossVV(this.m_rB,l)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=op.MulRV(r,this.m_lalcA,this.m_rA),l=op.MulRV(o,this.m_lalcB,this.m_rB),h=this.m_u;h.x=s.x+l.x-e.x-a.x,h.y=s.y+l.y-e.y-a.y;const c=this.m_u.Normalize();let m;if(this.m_minLength==this.m_maxLength)m=c-this.m_minLength;else if(c<this.m_minLength)m=c-this.m_minLength;else{if(!(this.m_maxLength<c))return!0;m=c-this.m_maxLength}const u=-this.m_mass*m,_=ep.MulSV(u,h,Ny.SolvePositionConstraints_s_P);return e.SelfMulSub(this.m_invMassA,_),i-=this.m_invIA*ep.CrossVV(a,_),s.SelfMulAdd(this.m_invMassB,_),n+=this.m_invIB*ep.CrossVV(l,_),t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,qd(m)<Gd}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ap.MulXV(e,this.m_localAnchorA,Ny.Draw_s_pA),n=ap.MulXV(i,this.m_localAnchorB,Ny.Draw_s_pB),r=ep.SubVV(n,s,Ny.Draw_s_axis);r.Normalize();const o=Ny.Draw_s_c1,a=Ny.Draw_s_c2,l=Ny.Draw_s_c3,h=Ny.Draw_s_c4;t.DrawSegment(s,n,h);const c=ep.AddVMulSV(s,this.m_length,r,Ny.Draw_s_pRest);if(t.DrawPoint(c,8,o),this.m_minLength!=this.m_maxLength){if(this.m_minLength>Gd){const e=ep.AddVMulSV(s,this.m_minLength,r,Ny.Draw_s_pMin);t.DrawPoint(e,4,a)}if(this.m_maxLength<Id){const e=ep.AddVMulSV(s,this.m_maxLength,r,Ny.Draw_s_pMax);t.DrawPoint(e,4,l)}}}}Ny.InitVelocityConstraints_s_P=new ep,Ny.SolveVelocityConstraints_s_vpA=new ep,Ny.SolveVelocityConstraints_s_vpB=new ep,Ny.SolveVelocityConstraints_s_P=new ep,Ny.SolvePositionConstraints_s_P=new ep,Ny.Draw_s_pA=new ep,Ny.Draw_s_pB=new ep,Ny.Draw_s_axis=new ep,Ny.Draw_s_c1=new hp(.7,.7,.7),Ny.Draw_s_c2=new hp(.3,.9,.3),Ny.Draw_s_c3=new hp(.9,.3,.3),Ny.Draw_s_c4=new hp(.4,.4,.4),Ny.Draw_s_pRest=new ep,Ny.Draw_s_pMin=new ep,Ny.Draw_s_pMax=new ep;class Uy extends zy{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_impulse=0,this.m_targetArea=0,this.m_delta=new ep,this.m_bodies=t.bodies,this.m_stiffness=Dd(t.stiffness,0),this.m_damping=Dd(t.damping,0),this.m_targetLengths=jd(t.bodies.length),this.m_normals=ep.MakeArray(t.bodies.length),this.m_joints=[],this.m_deltas=ep.MakeArray(t.bodies.length);const e=new Oy;e.stiffness=this.m_stiffness,e.damping=this.m_damping,this.m_targetArea=0;for(let t=0;t<this.m_bodies.length;++t){const i=this.m_bodies[t],s=this.m_bodies[(t+1)%this.m_bodies.length],n=i.GetWorldCenter(),r=s.GetWorldCenter();this.m_targetLengths[t]=ep.DistanceVV(n,r),this.m_targetArea+=ep.CrossVV(n,r),e.Initialize(i,s,n,r),this.m_joints[t]=i.GetWorld().CreateJoint(e)}this.m_targetArea*=.5}GetAnchorA(t){return t}GetAnchorB(t){return t}GetReactionForce(t,e){return e}GetReactionTorque(t){return 0}SetStiffness(t){this.m_stiffness=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetStiffness(t)}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetDamping(t)}GetDamping(){return this.m_damping}Dump(t){t("Area joint dumping is not supported.\n")}InitVelocityConstraints(t){for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[(e+this.m_bodies.length-1)%this.m_bodies.length],s=this.m_bodies[(e+1)%this.m_bodies.length],n=t.positions[i.m_islandIndex].c,r=t.positions[s.m_islandIndex].c,o=this.m_deltas[e];ep.SubVV(r,n,o)}if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],s=t.velocities[i.m_islandIndex].v,n=this.m_deltas[e];s.x+=i.m_invMass*n.y*.5*this.m_impulse,s.y+=i.m_invMass*-n.x*.5*this.m_impulse}}else this.m_impulse=0}SolveVelocityConstraints(t){let e=0,i=0;for(let s=0;s<this.m_bodies.length;++s){const n=this.m_bodies[s],r=t.velocities[n.m_islandIndex].v,o=this.m_deltas[s];e+=o.LengthSquared()/n.GetMass(),i+=ep.CrossVV(r,o)}const s=-2*i/e;this.m_impulse+=s;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],n=t.velocities[i.m_islandIndex].v,r=this.m_deltas[e];n.x+=i.m_invMass*r.y*.5*s,n.y+=i.m_invMass*-r.x*.5*s}}SolvePositionConstraints(t){let e=0,i=0;for(let s=0;s<this.m_bodies.length;++s){const n=this.m_bodies[s],r=this.m_bodies[(s+1)%this.m_bodies.length],o=t.positions[n.m_islandIndex].c,a=t.positions[r.m_islandIndex].c,l=ep.SubVV(a,o,this.m_delta);let h=l.Length();h<Ed&&(h=1),this.m_normals[s].x=l.y/h,this.m_normals[s].y=-l.x/h,e+=h,i+=ep.CrossVV(o,a)}i*=.5;const s=.5*(this.m_targetArea-i)/e;let n=!0;for(let e=0;e<this.m_bodies.length;++e){const i=this.m_bodies[e],r=t.positions[i.m_islandIndex].c,o=(e+1)%this.m_bodies.length,a=ep.AddVV(this.m_normals[e],this.m_normals[o],this.m_delta);a.SelfMul(s);const l=a.LengthSquared();l>Yd(.2)&&a.SelfMul(.2/Kd(l)),l>Yd(Gd)&&(n=!1),r.x+=a.x,r.y+=a.y}return n}}class Wy extends zy{constructor(t){super(t),this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_linearImpulse=new ep,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new np,this.m_angularMass=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_K=new np,this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=Dd(t.maxForce,0),this.m_maxTorque=Dd(t.maxTorque,0),this.m_linearMass.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const h=op.MulRV(a,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const c=op.MulRV(l,this.m_lalcB,this.m_rB),m=this.m_invMassA,u=this.m_invMassB,_=this.m_invIA,d=this.m_invIB,p=this.m_K;if(p.ex.x=m+u+_*h.y*h.y+d*c.y*c.y,p.ex.y=-_*h.x*h.y-d*c.x*c.y,p.ey.x=p.ex.y,p.ey.y=m+u+_*h.x*h.x+d*c.x*c.x,p.GetInverse(this.m_linearMass),this.m_angularMass=_+d,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;i.SelfMulSub(m,e),s-=_*(ep.CrossVV(this.m_rA,e)+this.m_angularImpulse),r.SelfMulAdd(u,e),o+=d*(ep.CrossVV(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=t.step.dt;{const t=n-i;let e=-this.m_angularMass*t;const s=this.m_angularImpulse,r=h*this.m_maxTorque;this.m_angularImpulse=Zd(this.m_angularImpulse+e,-r,r),e=this.m_angularImpulse-s,i-=a*e,n+=l*e}{const t=ep.SubVV(ep.AddVCrossSV(s,n,this.m_rB,ep.s_t0),ep.AddVCrossSV(e,i,this.m_rA,ep.s_t1),Wy.SolveVelocityConstraints_s_Cdot_v2),c=np.MulMV(this.m_linearMass,t,Wy.SolveVelocityConstraints_s_impulseV).SelfNeg(),m=Wy.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(c);const u=h*this.m_maxForce;this.m_linearImpulse.LengthSquared()>u*u&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(u)),ep.SubVV(this.m_linearImpulse,m,c),e.SelfMulSub(r,c),i-=a*ep.CrossVV(this.m_rA,c),s.SelfMulAdd(o,c),n+=l*ep.CrossVV(this.m_rB,c)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_linearImpulse.x,e.y=t*this.m_linearImpulse.y,e}GetReactionTorque(t){return t*this.m_angularImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Wy.SolveVelocityConstraints_s_Cdot_v2=new ep,Wy.SolveVelocityConstraints_s_impulseV=new ep,Wy.SolveVelocityConstraints_s_oldImpulseV=new ep;class jy extends zy{constructor(t){let e,i;super(t),this.m_typeA=By.e_unknownJoint,this.m_typeB=By.e_unknownJoint,this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_localAnchorC=new ep,this.m_localAnchorD=new ep,this.m_localAxisC=new ep,this.m_localAxisD=new ep,this.m_referenceAngleA=0,this.m_referenceAngleB=0,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_indexC=0,this.m_indexD=0,this.m_lcA=new ep,this.m_lcB=new ep,this.m_lcC=new ep,this.m_lcD=new ep,this.m_mA=0,this.m_mB=0,this.m_mC=0,this.m_mD=0,this.m_iA=0,this.m_iB=0,this.m_iC=0,this.m_iD=0,this.m_JvAC=new ep,this.m_JvBD=new ep,this.m_JwA=0,this.m_JwB=0,this.m_JwC=0,this.m_JwD=0,this.m_mass=0,this.m_qA=new op,this.m_qB=new op,this.m_qC=new op,this.m_qD=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_lalcC=new ep,this.m_lalcD=new ep,this.m_joint1=t.joint1,this.m_joint2=t.joint2,this.m_typeA=this.m_joint1.GetType(),this.m_typeB=this.m_joint2.GetType(),this.m_bodyC=this.m_joint1.GetBodyA(),this.m_bodyA=this.m_joint1.GetBodyB();const s=this.m_bodyA.m_xf,n=this.m_bodyA.m_sweep.a,r=this.m_bodyC.m_xf,o=this.m_bodyC.m_sweep.a;if(this.m_typeA===By.e_revoluteJoint){const i=t.joint1;this.m_localAnchorC.Copy(i.m_localAnchorA),this.m_localAnchorA.Copy(i.m_localAnchorB),this.m_referenceAngleA=i.m_referenceAngle,this.m_localAxisC.SetZero(),e=n-o-this.m_referenceAngleA}else{const i=t.joint1;this.m_localAnchorC.Copy(i.m_localAnchorA),this.m_localAnchorA.Copy(i.m_localAnchorB),this.m_referenceAngleA=i.m_referenceAngle,this.m_localAxisC.Copy(i.m_localXAxisA);const n=this.m_localAnchorC,o=op.MulTRV(r.q,ep.AddVV(op.MulRV(s.q,this.m_localAnchorA,ep.s_t0),ep.SubVV(s.p,r.p,ep.s_t1),ep.s_t0),ep.s_t0);e=ep.DotVV(ep.SubVV(o,n,ep.s_t0),this.m_localAxisC)}this.m_bodyD=this.m_joint2.GetBodyA(),this.m_bodyB=this.m_joint2.GetBodyB();const a=this.m_bodyB.m_xf,l=this.m_bodyB.m_sweep.a,h=this.m_bodyD.m_xf,c=this.m_bodyD.m_sweep.a;if(this.m_typeB===By.e_revoluteJoint){const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.SetZero(),i=l-c-this.m_referenceAngleB}else{const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.Copy(e.m_localXAxisA);const s=this.m_localAnchorD,n=op.MulTRV(h.q,ep.AddVV(op.MulRV(a.q,this.m_localAnchorB,ep.s_t0),ep.SubVV(a.p,h.p,ep.s_t1),ep.s_t0),ep.s_t0);i=ep.DotVV(ep.SubVV(n,s,ep.s_t0),this.m_localAxisD)}this.m_ratio=Dd(t.ratio,1),this.m_constant=e+this.m_ratio*i,this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_indexC=this.m_bodyC.m_islandIndex,this.m_indexD=this.m_bodyD.m_islandIndex,this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter),this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter),this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=t.positions[this.m_indexC].a,l=t.velocities[this.m_indexC].v;let h=t.velocities[this.m_indexC].w;const c=t.positions[this.m_indexD].a,m=t.velocities[this.m_indexD].v;let u=t.velocities[this.m_indexD].w;const _=this.m_qA.SetAngle(e),d=this.m_qB.SetAngle(n),p=this.m_qC.SetAngle(a),f=this.m_qD.SetAngle(c);if(this.m_mass=0,this.m_typeA===By.e_revoluteJoint)this.m_JvAC.SetZero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const t=op.MulRV(p,this.m_localAxisC,jy.InitVelocityConstraints_s_u);ep.SubVV(this.m_localAnchorC,this.m_lcC,this.m_lalcC);const e=op.MulRV(p,this.m_lalcC,jy.InitVelocityConstraints_s_rC);ep.SubVV(this.m_localAnchorA,this.m_lcA,this.m_lalcA);const i=op.MulRV(_,this.m_lalcA,jy.InitVelocityConstraints_s_rA);this.m_JvAC.Copy(t),this.m_JwC=ep.CrossVV(e,t),this.m_JwA=ep.CrossVV(i,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_typeB===By.e_revoluteJoint)this.m_JvBD.SetZero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const t=op.MulRV(f,this.m_localAxisD,jy.InitVelocityConstraints_s_u);ep.SubVV(this.m_localAnchorD,this.m_lcD,this.m_lalcD);const e=op.MulRV(f,this.m_lalcD,jy.InitVelocityConstraints_s_rD);ep.SubVV(this.m_localAnchorB,this.m_lcB,this.m_lalcB);const i=op.MulRV(d,this.m_lalcB,jy.InitVelocityConstraints_s_rB);ep.MulSV(this.m_ratio,t,this.m_JvBD),this.m_JwD=this.m_ratio*ep.CrossVV(e,t),this.m_JwB=this.m_ratio*ep.CrossVV(i,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,t.step.warmStarting?(i.SelfMulAdd(this.m_mA*this.m_impulse,this.m_JvAC),s+=this.m_iA*this.m_impulse*this.m_JwA,r.SelfMulAdd(this.m_mB*this.m_impulse,this.m_JvBD),o+=this.m_iB*this.m_impulse*this.m_JwB,l.SelfMulSub(this.m_mC*this.m_impulse,this.m_JvAC),h-=this.m_iC*this.m_impulse*this.m_JwC,m.SelfMulSub(this.m_mD*this.m_impulse,this.m_JvBD),u-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o,t.velocities[this.m_indexC].w=h,t.velocities[this.m_indexD].w=u}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=t.velocities[this.m_indexC].v;let o=t.velocities[this.m_indexC].w;const a=t.velocities[this.m_indexD].v;let l=t.velocities[this.m_indexD].w,h=ep.DotVV(this.m_JvAC,ep.SubVV(e,r,ep.s_t0))+ep.DotVV(this.m_JvBD,ep.SubVV(s,a,ep.s_t0));h+=this.m_JwA*i-this.m_JwC*o+(this.m_JwB*n-this.m_JwD*l);const c=-this.m_mass*h;this.m_impulse+=c,e.SelfMulAdd(this.m_mA*c,this.m_JvAC),i+=this.m_iA*c*this.m_JwA,s.SelfMulAdd(this.m_mB*c,this.m_JvBD),n+=this.m_iB*c*this.m_JwB,r.SelfMulSub(this.m_mC*c,this.m_JvAC),o-=this.m_iC*c*this.m_JwC,a.SelfMulSub(this.m_mD*c,this.m_JvBD),l-=this.m_iD*c*this.m_JwD,t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n,t.velocities[this.m_indexC].w=o,t.velocities[this.m_indexD].w=l}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=t.positions[this.m_indexC].c;let o=t.positions[this.m_indexC].a;const a=t.positions[this.m_indexD].c;let l=t.positions[this.m_indexD].a;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(n),m=this.m_qC.SetAngle(o),u=this.m_qD.SetAngle(l);let _,d;const p=this.m_JvAC,f=this.m_JvBD;let y,g,x,v,S=0;if(this.m_typeA===By.e_revoluteJoint)p.SetZero(),y=1,x=1,S+=this.m_iA+this.m_iC,_=i-o-this.m_referenceAngleA;else{const t=op.MulRV(m,this.m_localAxisC,jy.SolvePositionConstraints_s_u),i=op.MulRV(m,this.m_lalcC,jy.SolvePositionConstraints_s_rC),s=op.MulRV(h,this.m_lalcA,jy.SolvePositionConstraints_s_rA);p.Copy(t),x=ep.CrossVV(i,t),y=ep.CrossVV(s,t),S+=this.m_mC+this.m_mA+this.m_iC*x*x+this.m_iA*y*y;const n=this.m_lalcC,o=op.MulTRV(m,ep.AddVV(s,ep.SubVV(e,r,ep.s_t0),ep.s_t0),ep.s_t0);_=ep.DotVV(ep.SubVV(o,n,ep.s_t0),this.m_localAxisC)}if(this.m_typeB===By.e_revoluteJoint)f.SetZero(),g=this.m_ratio,v=this.m_ratio,S+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),d=n-l-this.m_referenceAngleB;else{const t=op.MulRV(u,this.m_localAxisD,jy.SolvePositionConstraints_s_u),e=op.MulRV(u,this.m_lalcD,jy.SolvePositionConstraints_s_rD),i=op.MulRV(c,this.m_lalcB,jy.SolvePositionConstraints_s_rB);ep.MulSV(this.m_ratio,t,f),v=this.m_ratio*ep.CrossVV(e,t),g=this.m_ratio*ep.CrossVV(i,t),S+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*v*v+this.m_iB*g*g;const n=this.m_lalcD,r=op.MulTRV(u,ep.AddVV(i,ep.SubVV(s,a,ep.s_t0),ep.s_t0),ep.s_t0);d=ep.DotVV(ep.SubVV(r,n,ep.s_t0),this.m_localAxisD)}const w=_+this.m_ratio*d-this.m_constant;let b=0;return S>0&&(b=-w/S),e.SelfMulAdd(this.m_mA*b,p),i+=this.m_iA*b*y,s.SelfMulAdd(this.m_mB*b,f),n+=this.m_iB*b*g,r.SelfMulSub(this.m_mC*b,p),o-=this.m_iC*b*x,a.SelfMulSub(this.m_mD*b,f),l-=this.m_iD*b*v,t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,t.positions[this.m_indexC].a=o,t.positions[this.m_indexD].a=l,!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return ep.MulSV(t*this.m_impulse,this.m_JvAC,e)}GetReactionTorque(t){return t*this.m_impulse*this.m_JwA}GetJoint1(){return this.m_joint1}GetJoint2(){return this.m_joint2}GetRatio(){return this.m_ratio}SetRatio(t){this.m_ratio=t}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex,s=this.m_joint1.m_index,n=this.m_joint2.m_index;t("  const jd: b2GearJointDef = new b2GearJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.joint1 = joints[%d];\n",s),t("  jd.joint2 = joints[%d];\n",n),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}jy.InitVelocityConstraints_s_u=new ep,jy.InitVelocityConstraints_s_rA=new ep,jy.InitVelocityConstraints_s_rB=new ep,jy.InitVelocityConstraints_s_rC=new ep,jy.InitVelocityConstraints_s_rD=new ep,jy.SolvePositionConstraints_s_u=new ep,jy.SolvePositionConstraints_s_rA=new ep,jy.SolvePositionConstraints_s_rB=new ep,jy.SolvePositionConstraints_s_rC=new ep,jy.SolvePositionConstraints_s_rD=new ep;class Hy extends zy{constructor(t){super(t),this.m_linearOffset=new ep,this.m_angularOffset=0,this.m_linearImpulse=new ep,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_correctionFactor=.3,this.m_indexA=0,this.m_indexB=0,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_linearError=new ep,this.m_angularError=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new np,this.m_angularMass=0,this.m_qA=new op,this.m_qB=new op,this.m_K=new np,this.m_linearOffset.Copy(Dd(t.linearOffset,ep.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=Dd(t.maxForce,0),this.m_maxTorque=Dd(t.maxTorque,0),this.m_correctionFactor=Dd(t.correctionFactor,.3)}GetAnchorA(t){const e=this.m_bodyA.GetPosition();return t.x=e.x,t.y=e.y,t}GetAnchorB(t){const e=this.m_bodyB.GetPosition();return t.x=e.x,t.y=e.y,t}GetReactionForce(t,e){return ep.MulSV(t,this.m_linearImpulse,e)}GetReactionTorque(t){return t*this.m_angularImpulse}SetLinearOffset(t){ep.IsEqualToV(t,this.m_linearOffset)||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_linearOffset.Copy(t))}GetLinearOffset(){return this.m_linearOffset}SetAngularOffset(t){t!==this.m_angularOffset&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_angularOffset=t)}GetAngularOffset(){return this.m_angularOffset}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o),m=op.MulRV(h,ep.SubVV(this.m_linearOffset,this.m_localCenterA,ep.s_t0),this.m_rA),u=op.MulRV(c,ep.NegV(this.m_localCenterB,ep.s_t0),this.m_rB),_=this.m_invMassA,d=this.m_invMassB,p=this.m_invIA,f=this.m_invIB,y=this.m_K;if(y.ex.x=_+d+p*m.y*m.y+f*u.y*u.y,y.ex.y=-p*m.x*m.y-f*u.x*u.y,y.ey.x=y.ex.y,y.ey.y=_+d+p*m.x*m.x+f*u.x*u.x,y.GetInverse(this.m_linearMass),this.m_angularMass=p+f,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),ep.SubVV(ep.AddVV(r,u,ep.s_t0),ep.AddVV(e,m,ep.s_t1),this.m_linearError),this.m_angularError=o-i-this.m_angularOffset,t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;s.SelfMulSub(_,e),n-=p*(ep.CrossVV(m,e)+this.m_angularImpulse),a.SelfMulAdd(d,e),l+=f*(ep.CrossVV(u,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=t.step.dt,c=t.step.inv_dt;{const t=n-i+c*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const s=this.m_angularImpulse,r=h*this.m_maxTorque;this.m_angularImpulse=Zd(this.m_angularImpulse+e,-r,r),e=this.m_angularImpulse-s,i-=a*e,n+=l*e}{const t=this.m_rA,m=this.m_rB,u=ep.AddVV(ep.SubVV(ep.AddVV(s,ep.CrossSV(n,m,ep.s_t0),ep.s_t0),ep.AddVV(e,ep.CrossSV(i,t,ep.s_t1),ep.s_t1),ep.s_t2),ep.MulSV(c*this.m_correctionFactor,this.m_linearError,ep.s_t3),Hy.SolveVelocityConstraints_s_Cdot_v2),_=np.MulMV(this.m_linearMass,u,Hy.SolveVelocityConstraints_s_impulse_v2).SelfNeg(),d=Hy.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(_);const p=h*this.m_maxForce;this.m_linearImpulse.LengthSquared()>p*p&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(p)),ep.SubVV(this.m_linearImpulse,d,_),e.SelfMulSub(r,_),i-=a*ep.CrossVV(t,_),s.SelfMulAdd(o,_),n+=l*ep.CrossVV(m,_)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2MotorJointDef = new b2MotorJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.linearOffset.Set(%.15f, %.15f);\n",this.m_linearOffset.x,this.m_linearOffset.y),t("  jd.angularOffset = %.15f;\n",this.m_angularOffset),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  jd.correctionFactor = %.15f;\n",this.m_correctionFactor),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Hy.SolveVelocityConstraints_s_Cdot_v2=new ep,Hy.SolveVelocityConstraints_s_impulse_v2=new ep,Hy.SolveVelocityConstraints_s_oldImpulse_v2=new ep;class qy extends zy{constructor(t){super(t),this.m_localAnchorB=new ep,this.m_targetA=new ep,this.m_stiffness=0,this.m_damping=0,this.m_beta=0,this.m_impulse=new ep,this.m_maxForce=0,this.m_gamma=0,this.m_indexA=0,this.m_indexB=0,this.m_rB=new ep,this.m_localCenterB=new ep,this.m_invMassB=0,this.m_invIB=0,this.m_mass=new np,this.m_C=new ep,this.m_qB=new op,this.m_lalcB=new ep,this.m_K=new np,this.m_targetA.Copy(Dd(t.target,ep.ZERO)),ap.MulTXV(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB),this.m_maxForce=Dd(t.maxForce,0),this.m_impulse.SetZero(),this.m_stiffness=Dd(t.stiffness,0),this.m_damping=Dd(t.damping,0),this.m_beta=0,this.m_gamma=0}SetTarget(t){this.m_bodyB.IsAwake()||this.m_bodyB.SetAwake(!0),this.m_targetA.Copy(t)}GetTarget(){return this.m_targetA}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexB].c,i=t.positions[this.m_indexB].a,s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_qB.SetAngle(i),o=this.m_bodyB.GetMass(),a=6.28318530718*this.m_stiffness,l=2*o*this.m_damping*a,h=o*(a*a),c=t.step.dt;this.m_gamma=c*(l+c*h),0!==this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=c*h*this.m_gamma,ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),op.MulRV(r,this.m_lalcB,this.m_rB);const m=this.m_K;m.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,m.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,m.ey.x=m.ex.y,m.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,m.GetInverse(this.m_mass),this.m_C.x=e.x+this.m_rB.x-this.m_targetA.x,this.m_C.y=e.y+this.m_rB.y-this.m_targetA.y,this.m_C.SelfMul(this.m_beta),n*=.98,t.step.warmStarting?(this.m_impulse.SelfMul(t.step.dtRatio),s.x+=this.m_invMassB*this.m_impulse.x,s.y+=this.m_invMassB*this.m_impulse.y,n+=this.m_invIB*ep.CrossVV(this.m_rB,this.m_impulse)):this.m_impulse.SetZero(),t.velocities[this.m_indexB].w=n}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexB].v;let i=t.velocities[this.m_indexB].w;const s=ep.AddVCrossSV(e,i,this.m_rB,qy.SolveVelocityConstraints_s_Cdot),n=np.MulMV(this.m_mass,ep.AddVV(s,ep.AddVV(this.m_C,ep.MulSV(this.m_gamma,this.m_impulse,ep.s_t0),ep.s_t0),ep.s_t0).SelfNeg(),qy.SolveVelocityConstraints_s_impulse),r=qy.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);this.m_impulse.SelfAdd(n);const o=t.step.dt*this.m_maxForce;this.m_impulse.LengthSquared()>o*o&&this.m_impulse.SelfMul(o/this.m_impulse.Length()),ep.SubVV(this.m_impulse,r,n),e.SelfMulAdd(this.m_invMassB,n),i+=this.m_invIB*ep.CrossVV(this.m_rB,n),t.velocities[this.m_indexB].w=i}SolvePositionConstraints(t){return!0}GetAnchorA(t){return t.x=this.m_targetA.x,t.y=this.m_targetA.y,t}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return ep.MulSV(t,this.m_impulse,e)}GetReactionTorque(t){return 0}Dump(t){t("Mouse joint dumping is not supported.\n")}ShiftOrigin(t){this.m_targetA.SelfSub(t)}}qy.SolveVelocityConstraints_s_Cdot=new ep,qy.SolveVelocityConstraints_s_impulse=new ep,qy.SolveVelocityConstraints_s_oldImpulse=new ep;class Xy extends zy{constructor(t){super(t),this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_localXAxisA=new ep,this.m_localYAxisA=new ep,this.m_referenceAngle=0,this.m_impulse=new ep(0,0),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorForce=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_axis=new ep(0,0),this.m_perp=new ep(0,0),this.m_s1=0,this.m_s2=0,this.m_a1=0,this.m_a2=0,this.m_K=new np,this.m_K3=new rp,this.m_K2=new np,this.m_translation=0,this.m_axialMass=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_rA=new ep,this.m_rB=new ep,this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_localXAxisA.Copy(Dd(t.localAxisA,new ep(1,0))).SelfNormalize(),ep.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_referenceAngle=Dd(t.referenceAngle,0),this.m_lowerTranslation=Dd(t.lowerTranslation,0),this.m_upperTranslation=Dd(t.upperTranslation,0),this.m_maxMotorForce=Dd(t.maxMotorForce,0),this.m_motorSpeed=Dd(t.motorSpeed,0),this.m_enableLimit=Dd(t.enableLimit,!1),this.m_enableMotor=Dd(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=op.MulRV(h,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const u=op.MulRV(c,this.m_lalcB,this.m_rB),_=ep.AddVV(ep.SubVV(r,e,ep.s_t0),ep.SubVV(u,m,ep.s_t1),Xy.InitVelocityConstraints_s_d),d=this.m_invMassA,p=this.m_invMassB,f=this.m_invIA,y=this.m_invIB;if(op.MulRV(h,this.m_localXAxisA,this.m_axis),this.m_a1=ep.CrossVV(ep.AddVV(_,m,ep.s_t0),this.m_axis),this.m_a2=ep.CrossVV(u,this.m_axis),this.m_axialMass=d+p+f*this.m_a1*this.m_a1+y*this.m_a2*this.m_a2,this.m_axialMass>0&&(this.m_axialMass=1/this.m_axialMass),op.MulRV(h,this.m_localYAxisA,this.m_perp),this.m_s1=ep.CrossVV(ep.AddVV(_,m,ep.s_t0),this.m_perp),this.m_s2=ep.CrossVV(u,this.m_perp),this.m_K.ex.x=d+p+f*this.m_s1*this.m_s1+y*this.m_s2*this.m_s2,this.m_K.ex.y=f*this.m_s1+y*this.m_s2,this.m_K.ey.x=this.m_K.ex.y,this.m_K.ey.y=f+y,0===this.m_K.ey.y&&(this.m_K.ey.y=1),this.m_enableLimit?this.m_translation=ep.DotVV(this.m_axis,_):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor||(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,i=ep.AddVV(ep.MulSV(this.m_impulse.x,this.m_perp,ep.s_t0),ep.MulSV(e,this.m_axis,ep.s_t1),Xy.InitVelocityConstraints_s_P),r=this.m_impulse.x*this.m_s1+this.m_impulse.y+e*this.m_a1,o=this.m_impulse.x*this.m_s2+this.m_impulse.y+e*this.m_a2;s.SelfMulSub(d,i),n-=f*r,a.SelfMulAdd(p,i),l+=y*o}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB;if(this.m_enableMotor){const h=ep.DotVV(this.m_axis,ep.SubVV(s,e,ep.s_t0))+this.m_a2*n-this.m_a1*i;let c=this.m_axialMass*(this.m_motorSpeed-h);const m=this.m_motorImpulse,u=t.step.dt*this.m_maxMotorForce;this.m_motorImpulse=Zd(this.m_motorImpulse+c,-u,u),c=this.m_motorImpulse-m;const _=ep.MulSV(c,this.m_axis,Xy.SolveVelocityConstraints_s_P),d=c*this.m_a1,p=c*this.m_a2;e.SelfMulSub(r,_),i-=a*d,s.SelfMulAdd(o,_),n+=l*p}if(this.m_enableLimit){{const h=this.m_translation-this.m_lowerTranslation,c=ep.DotVV(this.m_axis,ep.SubVV(s,e,ep.s_t0))+this.m_a2*n-this.m_a1*i;let m=-this.m_axialMass*(c+Jd(h,0)*t.step.inv_dt);const u=this.m_lowerImpulse;this.m_lowerImpulse=Jd(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-u;const _=ep.MulSV(m,this.m_axis,Xy.SolveVelocityConstraints_s_P),d=m*this.m_a1,p=m*this.m_a2;e.SelfMulSub(r,_),i-=a*d,s.SelfMulAdd(o,_),n+=l*p}{const h=this.m_upperTranslation-this.m_translation,c=ep.DotVV(this.m_axis,ep.SubVV(e,s,ep.s_t0))+this.m_a1*i-this.m_a2*n;let m=-this.m_axialMass*(c+Jd(h,0)*t.step.inv_dt);const u=this.m_upperImpulse;this.m_upperImpulse=Jd(this.m_upperImpulse+m,0),m=this.m_upperImpulse-u;const _=ep.MulSV(m,this.m_axis,Xy.SolveVelocityConstraints_s_P),d=m*this.m_a1,p=m*this.m_a2;e.SelfMulAdd(r,_),i+=a*d,s.SelfMulSub(o,_),n-=l*p}}{const t=ep.DotVV(this.m_perp,ep.SubVV(s,e,ep.s_t0))+this.m_s2*n-this.m_s1*i,h=n-i,c=this.m_K.Solve(-t,-h,Xy.SolveVelocityConstraints_s_df);this.m_impulse.SelfAdd(c);const m=ep.MulSV(c.x,this.m_perp,Xy.SolveVelocityConstraints_s_P),u=c.x*this.m_s1+c.y,_=c.x*this.m_s2+c.y;e.SelfMulSub(r,m),i-=a*u,s.SelfMulAdd(o,m),n+=l*_}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=this.m_invMassA,l=this.m_invMassB,h=this.m_invIA,c=this.m_invIB,m=op.MulRV(r,this.m_lalcA,this.m_rA),u=op.MulRV(o,this.m_lalcB,this.m_rB),_=ep.SubVV(ep.AddVV(s,u,ep.s_t0),ep.AddVV(e,m,ep.s_t1),Xy.SolvePositionConstraints_s_d),d=op.MulRV(r,this.m_localXAxisA,this.m_axis),p=ep.CrossVV(ep.AddVV(_,m,ep.s_t0),d),f=ep.CrossVV(u,d),y=op.MulRV(r,this.m_localYAxisA,this.m_perp),g=ep.CrossVV(ep.AddVV(_,m,ep.s_t0),y),x=ep.CrossVV(u,y);let v=Xy.SolvePositionConstraints_s_impulse;const S=ep.DotVV(y,_),w=n-i-this.m_referenceAngle;let b=qd(S);const C=qd(w);let A=!1,B=0;if(this.m_enableLimit){const t=ep.DotVV(d,_);qd(this.m_upperTranslation-this.m_lowerTranslation)<.01?(B=t,b=Jd(b,qd(t)),A=!0):t<=this.m_lowerTranslation?(B=Xd(t-this.m_lowerTranslation,0),b=Jd(b,this.m_lowerTranslation-t),A=!0):t>=this.m_upperTranslation&&(B=Jd(t-this.m_upperTranslation,0),b=Jd(b,t-this.m_upperTranslation),A=!0)}if(A){const t=a+l+h*g*g+c*x*x,e=h*g+c*x,i=h*g*p+c*x*f;let s=h+c;0===s&&(s=1);const n=h*p+c*f,r=a+l+h*p*p+c*f*f,o=this.m_K3;o.ex.SetXYZ(t,e,i),o.ey.SetXYZ(e,s,n),o.ez.SetXYZ(i,n,r),v=o.Solve33(-S,-w,-B,v)}else{const t=a+l+h*g*g+c*x*x,e=h*g+c*x;let i=h+c;0===i&&(i=1);const s=this.m_K2;s.ex.Set(t,e),s.ey.Set(e,i);const n=s.Solve(-S,-w,Xy.SolvePositionConstraints_s_impulse1);v.x=n.x,v.y=n.y,v.z=0}const M=ep.AddVV(ep.MulSV(v.x,y,ep.s_t0),ep.MulSV(v.z,d,ep.s_t1),Xy.SolvePositionConstraints_s_P),V=v.x*g+v.y+v.z*p,T=v.x*x+v.y+v.z*f;return e.SelfMulSub(a,M),i-=h*V,s.SelfMulAdd(l,M),n+=c*T,t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,b<=Gd&&C<=Fd}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.x),e.y=t*(this.m_impulse.y*this.m_perp.y+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.y),e}GetReactionTorque(t){return t*this.m_impulse.y}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetReferenceAngle(){return this.m_referenceAngle}GetJointTranslation(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Xy.GetJointTranslation_s_pA),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Xy.GetJointTranslation_s_pB),i=ep.SubVV(e,t,Xy.GetJointTranslation_s_d),s=this.m_bodyA.GetWorldVector(this.m_localXAxisA,Xy.GetJointTranslation_s_axis);return ep.DotVV(i,s)}GetJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;ep.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const i=op.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const s=op.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=ep.AddVV(t.m_sweep.c,i,ep.s_t0),r=ep.AddVV(e.m_sweep.c,s,ep.s_t1),o=ep.SubVV(r,n,ep.s_t2),a=t.GetWorldVector(this.m_localXAxisA,this.m_axis),l=t.m_linearVelocity,h=e.m_linearVelocity,c=t.m_angularVelocity,m=e.m_angularVelocity;return ep.DotVV(o,ep.CrossSV(c,a,ep.s_t0))+ep.DotVV(a,ep.SubVV(ep.AddVCrossSV(h,m,s,ep.s_t0),ep.AddVCrossSV(l,c,i,ep.s_t1),ep.s_t0))}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorForce(t){t!==this.m_maxMotorForce&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorForce=t)}GetMaxMotorForce(){return this.m_maxMotorForce}GetMotorForce(t){return t*this.m_motorImpulse}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerTranslation = %.15f;\n",this.m_lowerTranslation),t("  jd.upperTranslation = %.15f;\n",this.m_upperTranslation),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorForce = %.15f;\n",this.m_maxMotorForce),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ap.MulXV(e,this.m_localAnchorA,Xy.Draw_s_pA),n=ap.MulXV(i,this.m_localAnchorB,Xy.Draw_s_pB),r=op.MulRV(e.q,this.m_localXAxisA,Xy.Draw_s_axis),o=Xy.Draw_s_c1,a=Xy.Draw_s_c2,l=Xy.Draw_s_c3,h=Xy.Draw_s_c4,c=Xy.Draw_s_c5;if(t.DrawSegment(s,n,c),this.m_enableLimit){const i=ep.AddVMulSV(s,this.m_lowerTranslation,r,Xy.Draw_s_lower),n=ep.AddVMulSV(s,this.m_upperTranslation,r,Xy.Draw_s_upper),h=op.MulRV(e.q,this.m_localYAxisA,Xy.Draw_s_perp);t.DrawSegment(i,n,o),t.DrawSegment(ep.AddVMulSV(i,-.5,h,ep.s_t0),ep.AddVMulSV(i,.5,h,ep.s_t1),a),t.DrawSegment(ep.AddVMulSV(n,-.5,h,ep.s_t0),ep.AddVMulSV(n,.5,h,ep.s_t1),l)}else t.DrawSegment(ep.AddVMulSV(s,-1,r,ep.s_t0),ep.AddVMulSV(s,1,r,ep.s_t1),o);t.DrawPoint(s,5,o),t.DrawPoint(n,5,h)}}Xy.InitVelocityConstraints_s_d=new ep,Xy.InitVelocityConstraints_s_P=new ep,Xy.SolveVelocityConstraints_s_P=new ep,Xy.SolveVelocityConstraints_s_df=new ep,Xy.SolvePositionConstraints_s_d=new ep,Xy.SolvePositionConstraints_s_impulse=new sp,Xy.SolvePositionConstraints_s_impulse1=new ep,Xy.SolvePositionConstraints_s_P=new ep,Xy.GetJointTranslation_s_pA=new ep,Xy.GetJointTranslation_s_pB=new ep,Xy.GetJointTranslation_s_d=new ep,Xy.GetJointTranslation_s_axis=new ep,Xy.Draw_s_pA=new ep,Xy.Draw_s_pB=new ep,Xy.Draw_s_axis=new ep,Xy.Draw_s_c1=new hp(.7,.7,.7),Xy.Draw_s_c2=new hp(.3,.9,.3),Xy.Draw_s_c3=new hp(.9,.3,.3),Xy.Draw_s_c4=new hp(.3,.3,.9),Xy.Draw_s_c5=new hp(.4,.4,.4),Xy.Draw_s_lower=new ep,Xy.Draw_s_upper=new ep,Xy.Draw_s_perp=new ep;class Jy extends zy{constructor(t){super(t),this.m_groundAnchorA=new ep,this.m_groundAnchorB=new ep,this.m_lengthA=0,this.m_lengthB=0,this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_uA=new ep,this.m_uB=new ep,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_groundAnchorA.Copy(Dd(t.groundAnchorA,new ep(-1,1))),this.m_groundAnchorB.Copy(Dd(t.groundAnchorB,new ep(1,0))),this.m_localAnchorA.Copy(Dd(t.localAnchorA,new ep(-1,0))),this.m_localAnchorB.Copy(Dd(t.localAnchorB,new ep(1,0))),this.m_lengthA=Dd(t.lengthA,0),this.m_lengthB=Dd(t.lengthB,0),this.m_ratio=Dd(t.ratio,1),this.m_constant=Dd(t.lengthA,0)+this.m_ratio*Dd(t.lengthB,0),this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,i=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const r=t.positions[this.m_indexB].c,o=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;const h=this.m_qA.SetAngle(i),c=this.m_qB.SetAngle(o);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),op.MulRV(h,this.m_lalcA,this.m_rA),ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),op.MulRV(c,this.m_lalcB,this.m_rB),this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA),this.m_uB.Copy(r).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);const m=this.m_uA.Length(),u=this.m_uB.Length();m>.05?this.m_uA.SelfMul(1/m):this.m_uA.SetZero(),u>.05?this.m_uB.SelfMul(1/u):this.m_uB.SetZero();const _=ep.CrossVV(this.m_rA,this.m_uA),d=ep.CrossVV(this.m_rB,this.m_uB),p=this.m_invMassA+this.m_invIA*_*_,f=this.m_invMassB+this.m_invIB*d*d;if(this.m_mass=p+this.m_ratio*this.m_ratio*f,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.step.warmStarting){this.m_impulse*=t.step.dtRatio;const e=ep.MulSV(-this.m_impulse,this.m_uA,Jy.InitVelocityConstraints_s_PA),i=ep.MulSV(-this.m_ratio*this.m_impulse,this.m_uB,Jy.InitVelocityConstraints_s_PB);s.SelfMulAdd(this.m_invMassA,e),n+=this.m_invIA*ep.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,i),l+=this.m_invIB*ep.CrossVV(this.m_rB,i)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=l}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=ep.AddVCrossSV(e,i,this.m_rA,Jy.SolveVelocityConstraints_s_vpA),o=ep.AddVCrossSV(s,n,this.m_rB,Jy.SolveVelocityConstraints_s_vpB),a=-ep.DotVV(this.m_uA,r)-this.m_ratio*ep.DotVV(this.m_uB,o),l=-this.m_mass*a;this.m_impulse+=l;const h=ep.MulSV(-l,this.m_uA,Jy.SolveVelocityConstraints_s_PA),c=ep.MulSV(-this.m_ratio*l,this.m_uB,Jy.SolveVelocityConstraints_s_PB);e.SelfMulAdd(this.m_invMassA,h),i+=this.m_invIA*ep.CrossVV(this.m_rA,h),s.SelfMulAdd(this.m_invMassB,c),n+=this.m_invIB*ep.CrossVV(this.m_rB,c),t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=op.MulRV(r,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=op.MulRV(o,this.m_lalcB,this.m_rB),h=this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),c=this.m_uB.Copy(s).SelfAdd(l).SelfSub(this.m_groundAnchorB),m=h.Length(),u=c.Length();m>.05?h.SelfMul(1/m):h.SetZero(),u>.05?c.SelfMul(1/u):c.SetZero();const _=ep.CrossVV(a,h),d=ep.CrossVV(l,c),p=this.m_invMassA+this.m_invIA*_*_,f=this.m_invMassB+this.m_invIB*d*d;let y=p+this.m_ratio*this.m_ratio*f;y>0&&(y=1/y);const g=this.m_constant-m-this.m_ratio*u,x=qd(g),v=-y*g,S=ep.MulSV(-v,h,Jy.SolvePositionConstraints_s_PA),w=ep.MulSV(-this.m_ratio*v,c,Jy.SolvePositionConstraints_s_PB);return e.SelfMulAdd(this.m_invMassA,S),i+=this.m_invIA*ep.CrossVV(a,S),s.SelfMulAdd(this.m_invMassB,w),n+=this.m_invIB*ep.CrossVV(l,w),t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,x<Gd}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse*this.m_uB.x,e.y=t*this.m_impulse*this.m_uB.y,e}GetReactionTorque(t){return 0}GetGroundAnchorA(){return this.m_groundAnchorA}GetGroundAnchorB(){return this.m_groundAnchorB}GetLengthA(){return this.m_lengthA}GetLengthB(){return this.m_lengthB}GetRatio(){return this.m_ratio}GetCurrentLengthA(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Jy.GetCurrentLengthA_s_p),e=this.m_groundAnchorA;return ep.DistanceVV(t,e)}GetCurrentLengthB(){const t=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Jy.GetCurrentLengthB_s_p),e=this.m_groundAnchorB;return ep.DistanceVV(t,e)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.groundAnchorA.Set(%.15f, %.15f);\n",this.m_groundAnchorA.x,this.m_groundAnchorA.y),t("  jd.groundAnchorB.Set(%.15f, %.15f);\n",this.m_groundAnchorB.x,this.m_groundAnchorB.y),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.lengthA = %.15f;\n",this.m_lengthA),t("  jd.lengthB = %.15f;\n",this.m_lengthB),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}ShiftOrigin(t){this.m_groundAnchorA.SelfSub(t),this.m_groundAnchorB.SelfSub(t)}}Jy.InitVelocityConstraints_s_PA=new ep,Jy.InitVelocityConstraints_s_PB=new ep,Jy.SolveVelocityConstraints_s_vpA=new ep,Jy.SolveVelocityConstraints_s_vpB=new ep,Jy.SolveVelocityConstraints_s_PA=new ep,Jy.SolveVelocityConstraints_s_PB=new ep,Jy.SolvePositionConstraints_s_PA=new ep,Jy.SolvePositionConstraints_s_PB=new ep,Jy.GetCurrentLengthA_s_p=new ep,Jy.GetCurrentLengthB_s_p=new ep;class Zy extends zy{constructor(t){super(t),this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_impulse=new ep,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_enableMotor=!1,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_referenceAngle=0,this.m_lowerAngle=0,this.m_upperAngle=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_K=new np,this.m_angle=0,this.m_axialMass=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_referenceAngle=Dd(t.referenceAngle,0),this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerAngle=Dd(t.lowerAngle,0),this.m_upperAngle=Dd(t.upperAngle,0),this.m_maxMotorTorque=Dd(t.maxMotorTorque,0),this.m_motorSpeed=Dd(t.motorSpeed,0),this.m_enableLimit=Dd(t.enableLimit,!1),this.m_enableMotor=Dd(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),op.MulRV(a,this.m_lalcA,this.m_rA),ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),op.MulRV(l,this.m_lalcB,this.m_rB);const h=this.m_invMassA,c=this.m_invMassB,m=this.m_invIA,u=this.m_invIB;let _;if(this.m_K.ex.x=h+c+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*u,this.m_K.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*u,this.m_K.ex.y=this.m_K.ey.x,this.m_K.ey.y=h+c+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*u,this.m_axialMass=m+u,this.m_axialMass>0?(this.m_axialMass=1/this.m_axialMass,_=!1):_=!0,this.m_angle=n-e-this.m_referenceAngle,(!1===this.m_enableLimit||_)&&(this.m_lowerImpulse=0,this.m_upperImpulse=0),(!1===this.m_enableMotor||_)&&(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,n=Zy.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);i.SelfMulSub(h,n),s-=m*(ep.CrossVV(this.m_rA,n)+e),r.SelfMulAdd(c,n),o+=u*(ep.CrossVV(this.m_rB,n)+e)}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB,h=a+l===0;if(this.m_enableMotor&&!h){const e=n-i-this.m_motorSpeed;let s=-this.m_axialMass*e;const r=this.m_motorImpulse,o=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=Zd(this.m_motorImpulse+s,-o,o),s=this.m_motorImpulse-r,i-=a*s,n+=l*s}if(this.m_enableLimit&&!h){{const e=this.m_angle-this.m_lowerAngle,s=n-i;let r=-this.m_axialMass*(s+Jd(e,0)*t.step.inv_dt);const o=this.m_lowerImpulse;this.m_lowerImpulse=Jd(this.m_lowerImpulse+r,0),r=this.m_lowerImpulse-o,i-=a*r,n+=l*r}{const e=this.m_upperAngle-this.m_angle,s=i-n;let r=-this.m_axialMass*(s+Jd(e,0)*t.step.inv_dt);const o=this.m_upperImpulse;this.m_upperImpulse=Jd(this.m_upperImpulse+r,0),r=this.m_upperImpulse-o,i+=a*r,n-=l*r}}{const t=ep.SubVV(ep.AddVCrossSV(s,n,this.m_rB,ep.s_t0),ep.AddVCrossSV(e,i,this.m_rA,ep.s_t1),Zy.SolveVelocityConstraints_s_Cdot_v2),h=this.m_K.Solve(-t.x,-t.y,Zy.SolveVelocityConstraints_s_impulse_v2);this.m_impulse.x+=h.x,this.m_impulse.y+=h.y,e.SelfMulSub(r,h),i-=a*ep.CrossVV(this.m_rA,h),s.SelfMulAdd(o,h),n+=l*ep.CrossVV(this.m_rB,h)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);let a=0,l=0;const h=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&!h){const t=n-i-this.m_referenceAngle;let e=0;qd(this.m_upperAngle-this.m_lowerAngle)<.06981317007977778?e=Zd(t-this.m_lowerAngle,-.13962634015955555,zd):t<=this.m_lowerAngle?e=Zd(t-this.m_lowerAngle+Fd,-.13962634015955555,0):t>=this.m_upperAngle&&(e=Zd(t-this.m_upperAngle-Fd,0,zd));const s=-this.m_axialMass*e;i-=this.m_invIA*s,n+=this.m_invIB*s,a=qd(e)}{r.SetAngle(i),o.SetAngle(n),ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const t=op.MulRV(r,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const a=op.MulRV(o,this.m_lalcB,this.m_rB),h=ep.SubVV(ep.AddVV(s,a,ep.s_t0),ep.AddVV(e,t,ep.s_t1),Zy.SolvePositionConstraints_s_C_v2);l=h.Length();const c=this.m_invMassA,m=this.m_invMassB,u=this.m_invIA,_=this.m_invIB,d=this.m_K;d.ex.x=c+m+u*t.y*t.y+_*a.y*a.y,d.ex.y=-u*t.x*t.y-_*a.x*a.y,d.ey.x=d.ex.y,d.ey.y=c+m+u*t.x*t.x+_*a.x*a.x;const p=d.Solve(h.x,h.y,Zy.SolvePositionConstraints_s_impulse).SelfNeg();e.SelfMulSub(c,p),i-=u*ep.CrossVV(t,p),s.SelfMulAdd(m,p),n+=_*ep.CrossVV(a,p)}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,l<=Gd&&a<=Fd}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*(this.m_lowerImpulse-this.m_upperImpulse)}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}GetMotorTorque(t){return t*this.m_motorImpulse}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMaxMotorTorque(){return this.m_maxMotorTorque}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerAngle}GetUpperLimit(){return this.m_upperAngle}SetLimits(t,e){t===this.m_lowerAngle&&e===this.m_upperAngle||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerAngle=t,this.m_upperAngle=e)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerAngle = %.15f;\n",this.m_lowerAngle),t("  jd.upperAngle = %.15f;\n",this.m_upperAngle),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ap.MulXV(e,this.m_localAnchorA,Zy.Draw_s_pA),n=ap.MulXV(i,this.m_localAnchorB,Zy.Draw_s_pB),r=Zy.Draw_s_c1,o=Zy.Draw_s_c2,a=Zy.Draw_s_c3,l=Zy.Draw_s_c4,h=Zy.Draw_s_c5;t.DrawPoint(s,5,l),t.DrawPoint(n,5,h);const c=this.m_bodyA.GetAngle(),m=this.m_bodyB.GetAngle()-c-this.m_referenceAngle,u=.5,_=Zy.Draw_s_r.Set(u*Math.cos(m),u*Math.sin(m));if(t.DrawSegment(n,ep.AddVV(n,_,ep.s_t0),r),t.DrawCircle(n,u,r),this.m_enableLimit){const e=Zy.Draw_s_rlo.Set(u*Math.cos(this.m_lowerAngle),u*Math.sin(this.m_lowerAngle)),i=Zy.Draw_s_rhi.Set(u*Math.cos(this.m_upperAngle),u*Math.sin(this.m_upperAngle));t.DrawSegment(n,ep.AddVV(n,e,ep.s_t0),o),t.DrawSegment(n,ep.AddVV(n,i,ep.s_t0),a)}const d=Zy.Draw_s_color_;t.DrawSegment(e.p,s,d),t.DrawSegment(s,n,d),t.DrawSegment(i.p,n,d)}}Zy.InitVelocityConstraints_s_P=new ep,Zy.SolveVelocityConstraints_s_Cdot_v2=new ep,Zy.SolveVelocityConstraints_s_impulse_v2=new ep,Zy.SolvePositionConstraints_s_C_v2=new ep,Zy.SolvePositionConstraints_s_impulse=new ep,Zy.Draw_s_pA=new ep,Zy.Draw_s_pB=new ep,Zy.Draw_s_c1=new hp(.7,.7,.7),Zy.Draw_s_c2=new hp(.3,.9,.3),Zy.Draw_s_c3=new hp(.9,.3,.3),Zy.Draw_s_c4=new hp(.3,.3,.9),Zy.Draw_s_c5=new hp(.4,.4,.4),Zy.Draw_s_color_=new hp(.5,.8,.8),Zy.Draw_s_r=new ep,Zy.Draw_s_rlo=new ep,Zy.Draw_s_rhi=new ep;class Yy extends zy{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_referenceAngle=0,this.m_gamma=0,this.m_impulse=new sp(0,0,0),this.m_indexA=0,this.m_indexB=0,this.m_rA=new ep,this.m_rB=new ep,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=new rp,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_K=new rp,this.m_stiffness=Dd(t.stiffness,0),this.m_damping=Dd(t.damping,0),this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_referenceAngle=Dd(t.referenceAngle,0),this.m_impulse.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,r=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),l=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),op.MulRV(a,this.m_lalcA,this.m_rA),ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),op.MulRV(l,this.m_lalcB,this.m_rB);const h=this.m_invMassA,c=this.m_invMassB,m=this.m_invIA,u=this.m_invIB,_=this.m_K;if(_.ex.x=h+c+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*u,_.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*u,_.ez.x=-this.m_rA.y*m-this.m_rB.y*u,_.ex.y=_.ey.x,_.ey.y=h+c+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*u,_.ez.y=this.m_rA.x*m+this.m_rB.x*u,_.ex.z=_.ez.x,_.ey.z=_.ez.y,_.ez.z=m+u,this.m_stiffness>0){_.GetInverse22(this.m_mass);let i=m+u;const s=n-e-this.m_referenceAngle,r=this.m_damping,o=this.m_stiffness,a=t.step.dt;this.m_gamma=a*(r+a*o),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=s*a*o*this.m_gamma,i+=this.m_gamma,this.m_mass.ez.z=0!==i?1/i:0}else _.GetSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0;if(t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio);const e=Yy.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);i.SelfMulSub(h,e),s-=m*(ep.CrossVV(this.m_rA,e)+this.m_impulse.z),r.SelfMulAdd(c,e),o+=u*(ep.CrossVV(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.SetZero();t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const s=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const r=this.m_invMassA,o=this.m_invMassB,a=this.m_invIA,l=this.m_invIB;if(this.m_stiffness>0){const t=n-i,h=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=h,i-=a*h,n+=l*h;const c=ep.SubVV(ep.AddVCrossSV(s,n,this.m_rB,ep.s_t0),ep.AddVCrossSV(e,i,this.m_rA,ep.s_t1),Yy.SolveVelocityConstraints_s_Cdot1),m=rp.MulM33XY(this.m_mass,c.x,c.y,Yy.SolveVelocityConstraints_s_impulse1).SelfNeg();this.m_impulse.x+=m.x,this.m_impulse.y+=m.y;const u=m;e.SelfMulSub(r,u),i-=a*ep.CrossVV(this.m_rA,u),s.SelfMulAdd(o,u),n+=l*ep.CrossVV(this.m_rB,u)}else{const t=ep.SubVV(ep.AddVCrossSV(s,n,this.m_rB,ep.s_t0),ep.AddVCrossSV(e,i,this.m_rA,ep.s_t1),Yy.SolveVelocityConstraints_s_Cdot1),h=n-i,c=rp.MulM33XYZ(this.m_mass,t.x,t.y,h,Yy.SolveVelocityConstraints_s_impulse).SelfNeg();this.m_impulse.SelfAdd(c);const m=Yy.SolveVelocityConstraints_s_P.Set(c.x,c.y);e.SelfMulSub(r,m),i-=a*(ep.CrossVV(this.m_rA,m)+c.z),s.SelfMulAdd(o,m),n+=l*(ep.CrossVV(this.m_rB,m)+c.z)}t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const r=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n),a=this.m_invMassA,l=this.m_invMassB,h=this.m_invIA,c=this.m_invIB;ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=op.MulRV(r,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const u=op.MulRV(o,this.m_lalcB,this.m_rB);let _,d;const p=this.m_K;if(p.ex.x=a+l+m.y*m.y*h+u.y*u.y*c,p.ey.x=-m.y*m.x*h-u.y*u.x*c,p.ez.x=-m.y*h-u.y*c,p.ex.y=p.ey.x,p.ey.y=a+l+m.x*m.x*h+u.x*u.x*c,p.ez.y=m.x*h+u.x*c,p.ex.z=p.ez.x,p.ey.z=p.ez.y,p.ez.z=h+c,this.m_stiffness>0){const t=ep.SubVV(ep.AddVV(s,u,ep.s_t0),ep.AddVV(e,m,ep.s_t1),Yy.SolvePositionConstraints_s_C1);_=t.Length(),d=0;const r=p.Solve22(t.x,t.y,Yy.SolvePositionConstraints_s_P).SelfNeg();e.SelfMulSub(a,r),i-=h*ep.CrossVV(m,r),s.SelfMulAdd(l,r),n+=c*ep.CrossVV(u,r)}else{const t=ep.SubVV(ep.AddVV(s,u,ep.s_t0),ep.AddVV(e,m,ep.s_t1),Yy.SolvePositionConstraints_s_C1),r=n-i-this.m_referenceAngle;_=t.Length(),d=qd(r);const o=p.Solve33(t.x,t.y,r,Yy.SolvePositionConstraints_s_impulse).SelfNeg(),f=Yy.SolvePositionConstraints_s_P.Set(o.x,o.y);e.SelfMulSub(a,f),i-=h*(ep.CrossVV(this.m_rA,f)+o.z),s.SelfMulAdd(l,f),n+=c*(ep.CrossVV(this.m_rB,f)+o.z)}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,_<=Gd&&d<=Fd}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*this.m_impulse.z}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2WeldJointDef = new b2WeldJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Yy.InitVelocityConstraints_s_P=new ep,Yy.SolveVelocityConstraints_s_Cdot1=new ep,Yy.SolveVelocityConstraints_s_impulse1=new ep,Yy.SolveVelocityConstraints_s_impulse=new sp,Yy.SolveVelocityConstraints_s_P=new ep,Yy.SolvePositionConstraints_s_C1=new ep,Yy.SolvePositionConstraints_s_P=new ep,Yy.SolvePositionConstraints_s_impulse=new sp;class Qy extends zy{constructor(t){super(t),this.m_localAnchorA=new ep,this.m_localAnchorB=new ep,this.m_localXAxisA=new ep,this.m_localYAxisA=new ep,this.m_impulse=0,this.m_motorImpulse=0,this.m_springImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_translation=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_stiffness=0,this.m_damping=0,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new ep,this.m_localCenterB=new ep,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_ax=new ep,this.m_ay=new ep,this.m_sAx=0,this.m_sBx=0,this.m_sAy=0,this.m_sBy=0,this.m_mass=0,this.m_motorMass=0,this.m_axialMass=0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_qA=new op,this.m_qB=new op,this.m_lalcA=new ep,this.m_lalcB=new ep,this.m_rA=new ep,this.m_rB=new ep,this.m_localAnchorA.Copy(Dd(t.localAnchorA,ep.ZERO)),this.m_localAnchorB.Copy(Dd(t.localAnchorB,ep.ZERO)),this.m_localXAxisA.Copy(Dd(t.localAxisA,ep.UNITX)),ep.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_lowerTranslation=Dd(t.lowerTranslation,0),this.m_upperTranslation=Dd(t.upperTranslation,0),this.m_enableLimit=Dd(t.enableLimit,!1),this.m_maxMotorTorque=Dd(t.maxMotorTorque,0),this.m_motorSpeed=Dd(t.motorSpeed,0),this.m_enableMotor=Dd(t.enableMotor,!1),this.m_ax.SetZero(),this.m_ay.SetZero(),this.m_stiffness=Dd(t.stiffness,0),this.m_damping=Dd(t.damping,0)}GetMotorSpeed(){return this.m_motorSpeed}GetMaxMotorTorque(){return this.m_maxMotorTorque}SetSpringFrequencyHz(t){this.m_stiffness=t}GetSpringFrequencyHz(){return this.m_stiffness}SetSpringDampingRatio(t){this.m_damping=t}GetSpringDampingRatio(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,i=this.m_invMassB,s=this.m_invIA,n=this.m_invIB,r=t.positions[this.m_indexA].c,o=t.positions[this.m_indexA].a,a=t.velocities[this.m_indexA].v;let l=t.velocities[this.m_indexA].w;const h=t.positions[this.m_indexB].c,c=t.positions[this.m_indexB].a,m=t.velocities[this.m_indexB].v;let u=t.velocities[this.m_indexB].w;const _=this.m_qA.SetAngle(o),d=this.m_qB.SetAngle(c);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const p=op.MulRV(_,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const f=op.MulRV(d,this.m_lalcB,this.m_rB),y=ep.SubVV(ep.AddVV(h,f,ep.s_t0),ep.AddVV(r,p,ep.s_t1),Qy.InitVelocityConstraints_s_d);op.MulRV(_,this.m_localYAxisA,this.m_ay),this.m_sAy=ep.CrossVV(ep.AddVV(y,p,ep.s_t0),this.m_ay),this.m_sBy=ep.CrossVV(f,this.m_ay),this.m_mass=e+i+s*this.m_sAy*this.m_sAy+n*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),op.MulRV(_,this.m_localXAxisA,this.m_ax),this.m_sAx=ep.CrossVV(ep.AddVV(y,p,ep.s_t0),this.m_ax),this.m_sBx=ep.CrossVV(f,this.m_ax);const g=e+i+s*this.m_sAx*this.m_sAx+n*this.m_sBx*this.m_sBx;if(this.m_axialMass=g>0?1/g:0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_stiffness>0&&g>0){this.m_springMass=1/g;const e=ep.DotVV(y,this.m_ax),i=t.step.dt;this.m_gamma=i*(this.m_damping+i*this.m_stiffness),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*i*this.m_stiffness*this.m_gamma,this.m_springMass=g+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}else this.m_springImpulse=0;if(this.m_enableLimit?this.m_translation=ep.DotVV(this.m_ax,y):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor?(this.m_motorMass=s+n,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_springImpulse*=t.step.dtRatio,this.m_motorImpulse*=t.step.dtRatio;const e=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse,i=ep.AddVV(ep.MulSV(this.m_impulse,this.m_ay,ep.s_t0),ep.MulSV(e,this.m_ax,ep.s_t1),Qy.InitVelocityConstraints_s_P),s=this.m_impulse*this.m_sAy+e*this.m_sAx+this.m_motorImpulse,n=this.m_impulse*this.m_sBy+e*this.m_sBx+this.m_motorImpulse;a.SelfMulSub(this.m_invMassA,i),l-=this.m_invIA*s,m.SelfMulAdd(this.m_invMassB,i),u+=this.m_invIB*n}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=l,t.velocities[this.m_indexB].w=u}SolveVelocityConstraints(t){const e=this.m_invMassA,i=this.m_invMassB,s=this.m_invIA,n=this.m_invIB,r=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const a=t.velocities[this.m_indexB].v;let l=t.velocities[this.m_indexB].w;{const t=ep.DotVV(this.m_ax,ep.SubVV(a,r,ep.s_t0))+this.m_sBx*l-this.m_sAx*o,h=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=h;const c=ep.MulSV(h,this.m_ax,Qy.SolveVelocityConstraints_s_P),m=h*this.m_sAx,u=h*this.m_sBx;r.SelfMulSub(e,c),o-=s*m,a.SelfMulAdd(i,c),l+=n*u}{const e=l-o-this.m_motorSpeed;let i=-this.m_motorMass*e;const r=this.m_motorImpulse,a=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=Zd(this.m_motorImpulse+i,-a,a),i=this.m_motorImpulse-r,o-=s*i,l+=n*i}if(this.m_enableLimit){{const h=this.m_translation-this.m_lowerTranslation,c=ep.DotVV(this.m_ax,ep.SubVV(a,r,ep.s_t0))+this.m_sBx*l-this.m_sAx*o;let m=-this.m_axialMass*(c+Jd(h,0)*t.step.inv_dt);const u=this.m_lowerImpulse;this.m_lowerImpulse=Jd(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-u;const _=ep.MulSV(m,this.m_ax,Qy.SolveVelocityConstraints_s_P),d=m*this.m_sAx,p=m*this.m_sBx;r.SelfMulSub(e,_),o-=s*d,a.SelfMulAdd(i,_),l+=n*p}{const h=this.m_upperTranslation-this.m_translation,c=ep.DotVV(this.m_ax,ep.SubVV(r,a,ep.s_t0))+this.m_sAx*o-this.m_sBx*l;let m=-this.m_axialMass*(c+Jd(h,0)*t.step.inv_dt);const u=this.m_upperImpulse;this.m_upperImpulse=Jd(this.m_upperImpulse+m,0),m=this.m_upperImpulse-u;const _=ep.MulSV(m,this.m_ax,Qy.SolveVelocityConstraints_s_P),d=m*this.m_sAx,p=m*this.m_sBx;r.SelfMulAdd(e,_),o+=s*d,a.SelfMulSub(i,_),l-=n*p}}{const t=ep.DotVV(this.m_ay,ep.SubVV(a,r,ep.s_t0))+this.m_sBy*l-this.m_sAy*o,h=-this.m_mass*t;this.m_impulse+=h;const c=ep.MulSV(h,this.m_ay,Qy.SolveVelocityConstraints_s_P),m=h*this.m_sAy,u=h*this.m_sBy;r.SelfMulSub(e,c),o-=s*m,a.SelfMulAdd(i,c),l+=n*u}t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=l}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let i=t.positions[this.m_indexA].a;const s=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a,r=0;if(this.m_enableLimit){const t=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=op.MulRV(t,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=op.MulRV(o,this.m_lalcB,this.m_rB),h=ep.AddVV(ep.SubVV(s,e,ep.s_t0),ep.SubVV(l,a,ep.s_t1),Qy.SolvePositionConstraints_s_d),c=op.MulRV(t,this.m_localXAxisA,this.m_ax),m=ep.CrossVV(ep.AddVV(h,a,ep.s_t0),this.m_ax),u=ep.CrossVV(l,this.m_ax);let _=0;const d=ep.DotVV(c,h);if(qd(this.m_upperTranslation-this.m_lowerTranslation)<.01?_=d:d<=this.m_lowerTranslation?_=Xd(d-this.m_lowerTranslation,0):d>=this.m_upperTranslation&&(_=Jd(d-this.m_upperTranslation,0)),0!==_){const t=this.m_invMassA+this.m_invMassB+this.m_invIA*m*m+this.m_invIB*u*u;let o=0;0!==t&&(o=-_/t);const a=ep.MulSV(o,c,Qy.SolvePositionConstraints_s_P),l=o*m,h=o*u;e.SelfMulSub(this.m_invMassA,a),i-=this.m_invIA*l,s.SelfMulAdd(this.m_invMassB,a),n+=this.m_invIB*h,r=qd(_)}}{const t=this.m_qA.SetAngle(i),o=this.m_qB.SetAngle(n);ep.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=op.MulRV(t,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const l=op.MulRV(o,this.m_lalcB,this.m_rB),h=ep.AddVV(ep.SubVV(s,e,ep.s_t0),ep.SubVV(l,a,ep.s_t1),Qy.SolvePositionConstraints_s_d),c=op.MulRV(t,this.m_localYAxisA,this.m_ay),m=ep.CrossVV(ep.AddVV(h,a,ep.s_t0),c),u=ep.CrossVV(l,c),_=ep.DotVV(h,c),d=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let p=0;0!==d&&(p=-_/d);const f=ep.MulSV(p,c,Qy.SolvePositionConstraints_s_P),y=p*m,g=p*u;e.SelfMulSub(this.m_invMassA,f),i-=this.m_invIA*y,s.SelfMulAdd(this.m_invMassB,f),n+=this.m_invIB*g,r=Jd(r,qd(_))}return t.positions[this.m_indexA].a=i,t.positions[this.m_indexB].a=n,r<=Gd}GetDefinition(t){return t}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse*this.m_ay.x+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.x),e.y=t*(this.m_impulse*this.m_ay.y+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.y),e}GetReactionTorque(t){return t*this.m_motorImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetJointTranslation(){return this.GetPrismaticJointTranslation()}GetJointLinearSpeed(){return this.GetPrismaticJointSpeed()}GetJointAngle(){return this.GetRevoluteJointAngle()}GetJointAngularSpeed(){return this.GetRevoluteJointSpeed()}GetPrismaticJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,i=t.GetWorldPoint(this.m_localAnchorA,new ep),s=e.GetWorldPoint(this.m_localAnchorB,new ep),n=ep.SubVV(s,i,new ep),r=t.GetWorldVector(this.m_localXAxisA,new ep);return ep.DotVV(n,r)}GetPrismaticJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;ep.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const i=op.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);ep.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const s=op.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=ep.AddVV(t.m_sweep.c,i,ep.s_t0),r=ep.AddVV(e.m_sweep.c,s,ep.s_t1),o=ep.SubVV(r,n,ep.s_t2),a=t.GetWorldVector(this.m_localXAxisA,new ep),l=t.m_linearVelocity,h=e.m_linearVelocity,c=t.m_angularVelocity,m=e.m_angularVelocity;return ep.DotVV(o,ep.CrossSV(c,a,ep.s_t0))+ep.DotVV(a,ep.SubVV(ep.AddVCrossSV(h,m,s,ep.s_t0),ep.AddVCrossSV(l,c,i,ep.s_t1),ep.s_t0))}GetRevoluteJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a}GetRevoluteJointSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMotorTorque(t){return t*this.m_motorImpulse}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}Dump(t){const e=this.m_bodyA.m_islandIndex,i=this.m_bodyB.m_islandIndex;t("  const jd: b2WheelJointDef = new b2WheelJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",i),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),i=this.m_bodyB.GetTransform(),s=ap.MulXV(e,this.m_localAnchorA,Qy.Draw_s_pA),n=ap.MulXV(i,this.m_localAnchorB,Qy.Draw_s_pB),r=op.MulRV(e.q,this.m_localXAxisA,Qy.Draw_s_axis),o=Qy.Draw_s_c1,a=Qy.Draw_s_c2,l=Qy.Draw_s_c3,h=Qy.Draw_s_c4,c=Qy.Draw_s_c5;if(t.DrawSegment(s,n,c),this.m_enableLimit){const i=ep.AddVMulSV(s,this.m_lowerTranslation,r,Qy.Draw_s_lower),n=ep.AddVMulSV(s,this.m_upperTranslation,r,Qy.Draw_s_upper),h=op.MulRV(e.q,this.m_localYAxisA,Qy.Draw_s_perp);t.DrawSegment(i,n,o),t.DrawSegment(ep.AddVMulSV(i,-.5,h,ep.s_t0),ep.AddVMulSV(i,.5,h,ep.s_t1),a),t.DrawSegment(ep.AddVMulSV(n,-.5,h,ep.s_t0),ep.AddVMulSV(n,.5,h,ep.s_t1),l)}else t.DrawSegment(ep.AddVMulSV(s,-1,r,ep.s_t0),ep.AddVMulSV(s,1,r,ep.s_t1),o);t.DrawPoint(s,5,o),t.DrawPoint(n,5,h)}}function Ky(t,e){return Kd(t*e)}function $y(t,e){return t>e?t:e}function tg(t,e){return t<e?t:e}Qy.InitVelocityConstraints_s_d=new ep,Qy.InitVelocityConstraints_s_P=new ep,Qy.SolveVelocityConstraints_s_P=new ep,Qy.SolvePositionConstraints_s_d=new ep,Qy.SolvePositionConstraints_s_P=new ep,Qy.Draw_s_pA=new ep,Qy.Draw_s_pB=new ep,Qy.Draw_s_axis=new ep,Qy.Draw_s_c1=new hp(.7,.7,.7),Qy.Draw_s_c2=new hp(.3,.9,.3),Qy.Draw_s_c3=new hp(.9,.3,.3),Qy.Draw_s_c4=new hp(.3,.3,.9),Qy.Draw_s_c5=new hp(.4,.4,.4),Qy.Draw_s_lower=new ep,Qy.Draw_s_upper=new ep,Qy.Draw_s_perp=new ep;class eg{constructor(t){this._other=null,this.prev=null,this.next=null,this.contact=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class ig{constructor(){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_prev=null,this.m_next=null,this.m_nodeA=new eg(this),this.m_nodeB=new eg(this),this.m_indexA=0,this.m_indexB=0,this.m_manifold=new Lp,this.m_toiCount=0,this.m_toi=0,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_tangentSpeed=0,this.m_oldManifold=new Lp}GetManifold(){return this.m_manifold}GetWorldManifold(t){const e=this.m_fixtureA.GetBody(),i=this.m_fixtureB.GetBody(),s=this.GetShapeA(),n=this.GetShapeB();t.Initialize(this.m_manifold,e.GetTransform(),s.m_radius,i.GetTransform(),n.m_radius)}IsTouching(){return this.m_touchingFlag}SetEnabled(t){this.m_enabledFlag=t}IsEnabled(){return this.m_enabledFlag}GetNext(){return this.m_next}GetFixtureA(){return this.m_fixtureA}GetChildIndexA(){return this.m_indexA}GetShapeA(){return this.m_fixtureA.GetShape()}GetFixtureB(){return this.m_fixtureB}GetChildIndexB(){return this.m_indexB}GetShapeB(){return this.m_fixtureB.GetShape()}FlagForFiltering(){this.m_filterFlag=!0}SetFriction(t){this.m_friction=t}GetFriction(){return this.m_friction}ResetFriction(){this.m_friction=Ky(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction)}SetRestitution(t){this.m_restitution=t}GetRestitution(){return this.m_restitution}ResetRestitution(){this.m_restitution=$y(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}ResetRestitutionThreshold(){this.m_restitutionThreshold=tg(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}SetTangentSpeed(t){this.m_tangentSpeed=t}GetTangentSpeed(){return this.m_tangentSpeed}Reset(t,e,i,s){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!0,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_fixtureA=t,this.m_fixtureB=i,this.m_indexA=e,this.m_indexB=s,this.m_manifold.pointCount=0,this.m_prev=null,this.m_next=null,this.m_nodeA.Reset(),this.m_nodeB.Reset(),this.m_toiCount=0,this.m_friction=Ky(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=$y(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution),this.m_restitutionThreshold=tg(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}Update(t){const e=this.m_oldManifold;this.m_oldManifold=this.m_manifold,this.m_manifold=e,this.m_enabledFlag=!0;let i=!1;const s=this.m_touchingFlag,n=this.m_fixtureA.IsSensor(),r=this.m_fixtureB.IsSensor(),o=n||r,a=this.m_fixtureA.GetBody(),l=this.m_fixtureB.GetBody(),h=a.GetTransform(),c=l.GetTransform();if(o){const t=this.GetShapeA(),e=this.GetShapeB();i=qp(t,this.m_indexA,e,this.m_indexB,h,c),this.m_manifold.pointCount=0}else{this.Evaluate(this.m_manifold,h,c),i=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;const i=e.id;for(let t=0;t<this.m_oldManifold.pointCount;++t){const s=this.m_oldManifold.points[t];if(s.id.key===i.key){e.normalImpulse=s.normalImpulse,e.tangentImpulse=s.tangentImpulse;break}}}i!==s&&(a.SetAwake(!0),l.SetAwake(!0))}this.m_touchingFlag=i,!s&&i&&t&&t.BeginContact(this),s&&!i&&t&&t.EndContact(this),!o&&i&&t&&t.PreSolve(this,this.m_oldManifold)}ComputeTOI(t,e){const i=ig.ComputeTOI_s_input;i.proxyA.SetShape(this.GetShapeA(),this.m_indexA),i.proxyB.SetShape(this.GetShapeB(),this.m_indexB),i.sweepA.Copy(t),i.sweepB.Copy(e),i.tMax=Gd;const s=ig.ComputeTOI_s_output;return Cf(s,i),s.t}}ig.ComputeTOI_s_input=new mf,ig.ComputeTOI_s_output=new df;class sg extends ig{static Create(){return new sg}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=ap.MulXV(i,e.m_p,Af),o=ap.MulXV(n,s.m_p,Bf),a=ep.DistanceSquaredVV(r,o),l=e.m_radius+s.m_radius;a>l*l||(t.type=Pp.e_circles,t.localPoint.Copy(e.m_p),t.localNormal.SetZero(),t.pointCount=1,t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0)}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class ng extends ig{static Create(){return new ng}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=e.m_radius+s.m_radius,o=kf;o[0]=0;const a=Ef(o,e,i,s,n);if(a>r)return;const l=zf;l[0]=0;const h=Ef(l,s,n,e,i);if(h>r)return;let c,m,u,_,d=0,p=0;h>a+5e-4?(c=s,m=e,u=n,_=i,d=l[0],t.type=Pp.e_faceB,p=1):(c=e,m=s,u=i,_=n,d=o[0],t.type=Pp.e_faceA,p=0);const f=Lf;!function(t,e,i,s,n,r){const o=e.m_normals,a=n.m_count,l=n.m_vertices,h=n.m_normals,c=op.MulTRV(r.q,op.MulRV(i.q,o[s],ep.s_t0),Rf);let m=0,u=Id;for(let t=0;t<a;++t){const e=ep.DotVV(c,h[t]);e<u&&(u=e,m=t)}const _=m,d=_+1<a?_+1:0,p=t[0];ap.MulXV(r,l[_],p.v);const f=p.id.cf;f.indexA=s,f.indexB=_,f.typeA=Tp.e_face,f.typeB=Tp.e_vertex;const y=t[1];ap.MulXV(r,l[d],y.v);const g=y.id.cf;g.indexA=s,g.indexB=d,g.typeA=Tp.e_face,g.typeB=Tp.e_vertex}(f,c,u,d,m,_);const y=c.m_count,g=c.m_vertices,x=d,v=d+1<y?d+1:0,S=g[x],w=g[v],b=ep.SubVV(w,S,Of);b.Normalize();const C=ep.CrossVOne(b,Nf),A=ep.MidVV(S,w,Uf),B=op.MulRV(u.q,b,jf),M=ep.CrossVOne(B,Wf),V=ap.MulXV(u,S,qf),T=ap.MulXV(u,w,Xf),P=ep.DotVV(M,V),D=-ep.DotVV(B,V)+r,I=ep.DotVV(B,T)+r,E=Gf,R=Ff;let L;if(L=Up(E,f,ep.NegV(B,Hf),D,x),L<2)return;if(L=Up(R,E,B,I,v),L<2)return;t.localNormal.Copy(C),t.localPoint.Copy(A);let G=0;for(let e=0;e<2;++e){const i=R[e];if(ep.DotVV(M,i.v)-P<=r){const e=t.points[G];if(ap.MulTXV(_,i.v,e.localPoint),e.id.Copy(i.id),p){const t=e.id.cf;e.id.cf.indexA=t.indexB,e.id.cf.indexB=t.indexA,e.id.cf.typeA=t.typeB,e.id.cf.typeB=t.typeA}++G}}t.pointCount=G}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class rg extends ig{static Create(){return new rg}static Destroy(t){}Evaluate(t,e,i){!function(t,e,i,s,n){t.pointCount=0;const r=ap.MulXV(n,s.m_p,Mf),o=ap.MulTXV(i,r,Vf);let a=0,l=-Id;const h=e.m_radius+s.m_radius,c=e.m_count,m=e.m_vertices,u=e.m_normals;for(let t=0;t<c;++t){const e=ep.DotVV(u[t],ep.SubVV(o,m[t],ep.s_t0));if(e>h)return;e>l&&(l=e,a=t)}const _=a,d=(_+1)%c,p=m[_],f=m[d];if(l<Ed)return t.pointCount=1,t.type=Pp.e_faceA,t.localNormal.Copy(u[a]),ep.MidVV(p,f,t.localPoint),t.points[0].localPoint.Copy(s.m_p),void(t.points[0].id.key=0);const y=ep.DotVV(ep.SubVV(o,p,ep.s_t0),ep.SubVV(f,p,ep.s_t1)),g=ep.DotVV(ep.SubVV(o,f,ep.s_t0),ep.SubVV(p,f,ep.s_t1));if(y<=0){if(ep.DistanceSquaredVV(o,p)>h*h)return;t.pointCount=1,t.type=Pp.e_faceA,ep.SubVV(o,p,t.localNormal).SelfNormalize(),t.localPoint.Copy(p),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}else if(g<=0){if(ep.DistanceSquaredVV(o,f)>h*h)return;t.pointCount=1,t.type=Pp.e_faceA,ep.SubVV(o,f,t.localNormal).SelfNormalize(),t.localPoint.Copy(f),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}else{const e=ep.MidVV(p,f,Tf);if(ep.DotVV(ep.SubVV(o,e,ep.s_t1),u[_])>h)return;t.pointCount=1,t.type=Pp.e_faceA,t.localNormal.Copy(u[_]).SelfNormalize(),t.localPoint.Copy(e),t.points[0].localPoint.Copy(s.m_p),t.points[0].id.key=0}}(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class og extends ig{static Create(){return new og}static Destroy(t){}Evaluate(t,e,i){iy(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class ag extends ig{static Create(){return new ag}static Destroy(t){}Evaluate(t,e,i){wy(t,this.GetShapeA(),e,this.GetShapeB(),i)}}class lg extends ig{static Create(){return new lg}static Destroy(t){}Evaluate(t,e,i){const s=lg.Evaluate_s_edge;this.GetShapeA().GetChildEdge(s,this.m_indexA),iy(t,s,e,this.GetShapeB(),i)}}lg.Evaluate_s_edge=new Py;class hg extends ig{static Create(){return new hg}static Destroy(t){}Evaluate(t,e,i){const s=hg.Evaluate_s_edge;this.GetShapeA().GetChildEdge(s,this.m_indexA),wy(t,s,e,this.GetShapeB(),i)}}hg.Evaluate_s_edge=new Py;class cg{constructor(){this.pool=[],this.createFcn=null,this.destroyFcn=null,this.primary=!1}}class mg{constructor(){this.m_registers=[],this.InitializeRegisters()}AddType(t,e,i,s){const n=[];function r(){return n.pop()||t()}function o(t){n.push(t)}this.m_registers[i][s].pool=n,this.m_registers[i][s].createFcn=r,this.m_registers[i][s].destroyFcn=o,this.m_registers[i][s].primary=!0,i!==s&&(this.m_registers[s][i].pool=n,this.m_registers[s][i].createFcn=r,this.m_registers[s][i].destroyFcn=o,this.m_registers[s][i].primary=!1)}InitializeRegisters(){for(let t=0;t<Cy.e_shapeTypeCount;t++){this.m_registers[t]=[];for(let e=0;e<Cy.e_shapeTypeCount;e++)this.m_registers[t][e]=new cg}this.AddType(sg.Create,sg.Destroy,Cy.e_circleShape,Cy.e_circleShape),this.AddType(rg.Create,rg.Destroy,Cy.e_polygonShape,Cy.e_circleShape),this.AddType(ng.Create,ng.Destroy,Cy.e_polygonShape,Cy.e_polygonShape),this.AddType(og.Create,og.Destroy,Cy.e_edgeShape,Cy.e_circleShape),this.AddType(ag.Create,ag.Destroy,Cy.e_edgeShape,Cy.e_polygonShape),this.AddType(lg.Create,lg.Destroy,Cy.e_chainShape,Cy.e_circleShape),this.AddType(hg.Create,hg.Destroy,Cy.e_chainShape,Cy.e_polygonShape)}Create(t,e,i,s){const n=t.GetType(),r=i.GetType(),o=this.m_registers[n][r];if(o.createFcn){const n=o.createFcn();return o.primary?n.Reset(t,e,i,s):n.Reset(i,s,t,e),n}return null}Destroy(t){const e=t.m_fixtureA.GetType(),i=t.m_fixtureB.GetType(),s=this.m_registers[e][i];s.destroyFcn&&s.destroyFcn(t)}}class ug{ShouldCollide(t,e){const i=t.GetBody(),s=e.GetBody();if(s.GetType()===Ay.b2_staticBody&&i.GetType()===Ay.b2_staticBody)return!1;if(!s.ShouldCollideConnected(i))return!1;const n=t.GetFilterData(),r=e.GetFilterData();return n.groupIndex===r.groupIndex&&0!==n.groupIndex?n.groupIndex>0:0!=(n.maskBits&r.categoryBits)&&0!=(n.categoryBits&r.maskBits)}ShouldCollideFixtureParticle(t,e,i){return!0}ShouldCollideParticleParticle(t,e,i){return!0}}ug.b2_defaultFilter=new ug;class _g{BeginContact(t){}EndContact(t){}BeginContactFixtureParticle(t,e){}EndContactFixtureParticle(t,e){}BeginContactParticleParticle(t,e){}EndContactParticleParticle(t,e){}PreSolve(t,e){}PostSolve(t,e){}}_g.b2_defaultListener=new _g;class dg{ReportFixture(t){return!0}ReportParticle(t,e){return!1}ShouldQueryParticleSystem(t){return!0}}class pg{constructor(){this.m_broadPhase=new Qp,this.m_contactList=null,this.m_contactCount=0,this.m_contactFilter=ug.b2_defaultFilter,this.m_contactListener=_g.b2_defaultListener,this.m_contactFactory=new mg}AddPair(t,e){let i=t.fixture,s=e.fixture,n=t.childIndex,r=e.childIndex,o=i.GetBody(),a=s.GetBody();if(o===a)return;let l=a.GetContactList();for(;l;){if(l.other===o){const t=l.contact.GetFixtureA(),e=l.contact.GetFixtureB(),o=l.contact.GetChildIndexA(),a=l.contact.GetChildIndexB();if(t===i&&e===s&&o===n&&a===r)return;if(t===s&&e===i&&o===r&&a===n)return}l=l.next}if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(i,s))return;const h=this.m_contactFactory.Create(i,n,s,r);null!==h&&(i=h.GetFixtureA(),s=h.GetFixtureB(),n=h.GetChildIndexA(),r=h.GetChildIndexB(),o=i.m_body,a=s.m_body,h.m_prev=null,h.m_next=this.m_contactList,null!==this.m_contactList&&(this.m_contactList.m_prev=h),this.m_contactList=h,h.m_nodeA.other=a,h.m_nodeA.prev=null,h.m_nodeA.next=o.m_contactList,null!==o.m_contactList&&(o.m_contactList.prev=h.m_nodeA),o.m_contactList=h.m_nodeA,h.m_nodeB.other=o,h.m_nodeB.prev=null,h.m_nodeB.next=a.m_contactList,null!==a.m_contactList&&(a.m_contactList.prev=h.m_nodeB),a.m_contactList=h.m_nodeB,++this.m_contactCount)}FindNewContacts(){this.m_broadPhase.UpdatePairs(((t,e)=>{this.AddPair(t,e)}))}Destroy(t){const e=t.GetFixtureA(),i=t.GetFixtureB(),s=e.GetBody(),n=i.GetBody();this.m_contactListener&&t.IsTouching()&&this.m_contactListener.EndContact(t),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_contactList&&(this.m_contactList=t.m_next),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA===s.m_contactList&&(s.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB===n.m_contactList&&(n.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!e.IsSensor()&&!i.IsSensor()&&(e.GetBody().SetAwake(!0),i.GetBody().SetAwake(!0)),this.m_contactFactory.Destroy(t),--this.m_contactCount}Collide(){let t=this.m_contactList;for(;t;){const e=t.GetFixtureA(),i=t.GetFixtureB(),s=t.GetChildIndexA(),n=t.GetChildIndexB(),r=e.GetBody(),o=i.GetBody();if(t.m_filterFlag){if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(e,i)){const e=t;t=e.m_next,this.Destroy(e);continue}t.m_filterFlag=!1}const a=r.IsAwake()&&r.m_type!==Ay.b2_staticBody,l=o.IsAwake()&&o.m_type!==Ay.b2_staticBody;if(!a&&!l){t=t.m_next;continue}const h=e.m_proxies[s].treeNode,c=i.m_proxies[n].treeNode;if(Np(h.aabb,c.aabb))t.Update(this.m_contactListener),t=t.m_next;else{const e=t;t=e.m_next,this.Destroy(e)}}}}class fg{constructor(){this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0}Reset(){return this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0,this}}class yg{constructor(){this.dt=0,this.inv_dt=0,this.dtRatio=0,this.velocityIterations=0,this.positionIterations=0,this.particleIterations=0,this.warmStarting=!1}Copy(t){return this.dt=t.dt,this.inv_dt=t.inv_dt,this.dtRatio=t.dtRatio,this.positionIterations=t.positionIterations,this.velocityIterations=t.velocityIterations,this.particleIterations=t.particleIterations,this.warmStarting=t.warmStarting,this}}class gg{constructor(){this.c=new ep,this.a=0}static MakeArray(t){return Wd(t,(t=>new gg))}}class xg{constructor(){this.v=new ep,this.w=0}static MakeArray(t){return Wd(t,(t=>new xg))}}class vg{constructor(){this.rA=new ep,this.rB=new ep,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}static MakeArray(t){return Wd(t,(t=>new vg))}}class Sg{constructor(){this.points=vg.MakeArray(2),this.normal=new ep,this.tangent=new ep,this.normalMass=new np,this.K=new np,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.invIA=0,this.invIB=0,this.friction=0,this.restitution=0,this.threshold=0,this.tangentSpeed=0,this.pointCount=0,this.contactIndex=0}static MakeArray(t){return Wd(t,(t=>new Sg))}}class wg{constructor(){this.localPoints=ep.MakeArray(2),this.localNormal=new ep,this.localPoint=new ep,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.localCenterA=new ep,this.localCenterB=new ep,this.invIA=0,this.invIB=0,this.type=Pp.e_unknown,this.radiusA=0,this.radiusB=0,this.pointCount=0}static MakeArray(t){return Wd(t,(t=>new wg))}}class bg{constructor(){this.normal=new ep,this.point=new ep,this.separation=0}Initialize(t,e,i,s){const n=bg.Initialize_s_pointA,r=bg.Initialize_s_pointB,o=bg.Initialize_s_planePoint,a=bg.Initialize_s_clipPoint;switch(t.type){case Pp.e_circles:ap.MulXV(e,t.localPoint,n),ap.MulXV(i,t.localPoints[0],r),ep.SubVV(r,n,this.normal).SelfNormalize(),ep.MidVV(n,r,this.point),this.separation=ep.DotVV(ep.SubVV(r,n,ep.s_t0),this.normal)-t.radiusA-t.radiusB;break;case Pp.e_faceA:op.MulRV(e.q,t.localNormal,this.normal),ap.MulXV(e,t.localPoint,o),ap.MulXV(i,t.localPoints[s],a),this.separation=ep.DotVV(ep.SubVV(a,o,ep.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a);break;case Pp.e_faceB:op.MulRV(i.q,t.localNormal,this.normal),ap.MulXV(i,t.localPoint,o),ap.MulXV(e,t.localPoints[s],a),this.separation=ep.DotVV(ep.SubVV(a,o,ep.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a),this.normal.SelfNeg()}}}bg.Initialize_s_pointA=new ep,bg.Initialize_s_pointB=new ep,bg.Initialize_s_planePoint=new ep,bg.Initialize_s_clipPoint=new ep;class Cg{constructor(){this.m_step=new yg,this.m_positionConstraints=wg.MakeArray(1024),this.m_velocityConstraints=Sg.MakeArray(1024),this.m_count=0}Initialize(t){if(this.m_step.Copy(t.step),this.m_count=t.count,this.m_positionConstraints.length<this.m_count){const t=Jd(2*this.m_positionConstraints.length,this.m_count);for(;this.m_positionConstraints.length<t;)this.m_positionConstraints[this.m_positionConstraints.length]=new wg}if(this.m_velocityConstraints.length<this.m_count){const t=Jd(2*this.m_velocityConstraints.length,this.m_count);for(;this.m_velocityConstraints.length<t;)this.m_velocityConstraints[this.m_velocityConstraints.length]=new Sg}this.m_positions=t.positions,this.m_velocities=t.velocities,this.m_contacts=t.contacts;for(let t=0;t<this.m_count;++t){const e=this.m_contacts[t],i=e.m_fixtureA,s=e.m_fixtureB,n=i.GetShape(),r=s.GetShape(),o=n.m_radius,a=r.m_radius,l=i.GetBody(),h=s.GetBody(),c=e.GetManifold(),m=c.pointCount,u=this.m_velocityConstraints[t];u.friction=e.m_friction,u.restitution=e.m_restitution,u.threshold=e.m_restitutionThreshold,u.tangentSpeed=e.m_tangentSpeed,u.indexA=l.m_islandIndex,u.indexB=h.m_islandIndex,u.invMassA=l.m_invMass,u.invMassB=h.m_invMass,u.invIA=l.m_invI,u.invIB=h.m_invI,u.contactIndex=t,u.pointCount=m,u.K.SetZero(),u.normalMass.SetZero();const _=this.m_positionConstraints[t];_.indexA=l.m_islandIndex,_.indexB=h.m_islandIndex,_.invMassA=l.m_invMass,_.invMassB=h.m_invMass,_.localCenterA.Copy(l.m_sweep.localCenter),_.localCenterB.Copy(h.m_sweep.localCenter),_.invIA=l.m_invI,_.invIB=h.m_invI,_.localNormal.Copy(c.localNormal),_.localPoint.Copy(c.localPoint),_.pointCount=m,_.radiusA=o,_.radiusB=a,_.type=c.type;for(let t=0;t<m;++t){const e=c.points[t],i=u.points[t];this.m_step.warmStarting?(i.normalImpulse=this.m_step.dtRatio*e.normalImpulse,i.tangentImpulse=this.m_step.dtRatio*e.tangentImpulse):(i.normalImpulse=0,i.tangentImpulse=0),i.rA.SetZero(),i.rB.SetZero(),i.normalMass=0,i.tangentMass=0,i.velocityBias=0,_.localPoints[t].Copy(e.localPoint)}}return this}InitializeVelocityConstraints(){const t=Cg.InitializeVelocityConstraints_s_xfA,e=Cg.InitializeVelocityConstraints_s_xfB,i=Cg.InitializeVelocityConstraints_s_worldManifold;for(let s=0;s<this.m_count;++s){const n=this.m_velocityConstraints[s],r=this.m_positionConstraints[s],o=r.radiusA,a=r.radiusB,l=this.m_contacts[n.contactIndex].GetManifold(),h=n.indexA,c=n.indexB,m=n.invMassA,u=n.invMassB,_=n.invIA,d=n.invIB,p=r.localCenterA,f=r.localCenterB,y=this.m_positions[h].c,g=this.m_positions[h].a,x=this.m_velocities[h].v,v=this.m_velocities[h].w,S=this.m_positions[c].c,w=this.m_positions[c].a,b=this.m_velocities[c].v,C=this.m_velocities[c].w;t.q.SetAngle(g),e.q.SetAngle(w),ep.SubVV(y,op.MulRV(t.q,p,ep.s_t0),t.p),ep.SubVV(S,op.MulRV(e.q,f,ep.s_t0),e.p),i.Initialize(l,t,o,e,a),n.normal.Copy(i.normal),ep.CrossVOne(n.normal,n.tangent);const A=n.pointCount;for(let t=0;t<A;++t){const e=n.points[t];ep.SubVV(i.points[t],y,e.rA),ep.SubVV(i.points[t],S,e.rB);const s=ep.CrossVV(e.rA,n.normal),r=ep.CrossVV(e.rB,n.normal),o=m+u+_*s*s+d*r*r;e.normalMass=o>0?1/o:0;const a=n.tangent,l=ep.CrossVV(e.rA,a),h=ep.CrossVV(e.rB,a),c=m+u+_*l*l+d*h*h;e.tangentMass=c>0?1/c:0,e.velocityBias=0;const p=ep.DotVV(n.normal,ep.SubVV(ep.AddVCrossSV(b,C,e.rB,ep.s_t0),ep.AddVCrossSV(x,v,e.rA,ep.s_t1),ep.s_t0));p<-n.threshold&&(e.velocityBias+=-n.restitution*p)}n.pointCount,0}}WarmStart(){const t=Cg.WarmStart_s_P;for(let e=0;e<this.m_count;++e){const i=this.m_velocityConstraints[e],s=i.indexA,n=i.indexB,r=i.invMassA,o=i.invIA,a=i.invMassB,l=i.invIB,h=i.pointCount,c=this.m_velocities[s].v;let m=this.m_velocities[s].w;const u=this.m_velocities[n].v;let _=this.m_velocities[n].w;const d=i.normal,p=i.tangent;for(let e=0;e<h;++e){const s=i.points[e];ep.AddVV(ep.MulSV(s.normalImpulse,d,ep.s_t0),ep.MulSV(s.tangentImpulse,p,ep.s_t1),t),m-=o*ep.CrossVV(s.rA,t),c.SelfMulSub(r,t),_+=l*ep.CrossVV(s.rB,t),u.SelfMulAdd(a,t)}this.m_velocities[s].w=m,this.m_velocities[n].w=_}}SolveVelocityConstraints(){const t=Cg.SolveVelocityConstraints_s_dv,e=(Cg.SolveVelocityConstraints_s_dv1,Cg.SolveVelocityConstraints_s_dv2,Cg.SolveVelocityConstraints_s_P);Cg.SolveVelocityConstraints_s_a,Cg.SolveVelocityConstraints_s_b,Cg.SolveVelocityConstraints_s_x,Cg.SolveVelocityConstraints_s_d,Cg.SolveVelocityConstraints_s_P1,Cg.SolveVelocityConstraints_s_P2,Cg.SolveVelocityConstraints_s_P1P2;for(let i=0;i<this.m_count;++i){const s=this.m_velocityConstraints[i],n=s.indexA,r=s.indexB,o=s.invMassA,a=s.invIA,l=s.invMassB,h=s.invIB,c=s.pointCount,m=this.m_velocities[n].v;let u=this.m_velocities[n].w;const _=this.m_velocities[r].v;let d=this.m_velocities[r].w;const p=s.normal,f=s.tangent,y=s.friction;for(let i=0;i<c;++i){const n=s.points[i];ep.SubVV(ep.AddVCrossSV(_,d,n.rB,ep.s_t0),ep.AddVCrossSV(m,u,n.rA,ep.s_t1),t);const r=ep.DotVV(t,f)-s.tangentSpeed;let c=n.tangentMass*-r;const p=y*n.normalImpulse,g=Zd(n.tangentImpulse+c,-p,p);c=g-n.tangentImpulse,n.tangentImpulse=g,ep.MulSV(c,f,e),m.SelfMulSub(o,e),u-=a*ep.CrossVV(n.rA,e),_.SelfMulAdd(l,e),d+=h*ep.CrossVV(n.rB,e)}s.pointCount;for(let i=0;i<c;++i){const n=s.points[i];ep.SubVV(ep.AddVCrossSV(_,d,n.rB,ep.s_t0),ep.AddVCrossSV(m,u,n.rA,ep.s_t1),t);const r=ep.DotVV(t,p);let c=-n.normalMass*(r-n.velocityBias);const f=Jd(n.normalImpulse+c,0);c=f-n.normalImpulse,n.normalImpulse=f,ep.MulSV(c,p,e),m.SelfMulSub(o,e),u-=a*ep.CrossVV(n.rA,e),_.SelfMulAdd(l,e),d+=h*ep.CrossVV(n.rB,e)}this.m_velocities[n].w=u,this.m_velocities[r].w=d}}StoreImpulses(){for(let t=0;t<this.m_count;++t){const e=this.m_velocityConstraints[t],i=this.m_contacts[e.contactIndex].GetManifold();for(let t=0;t<e.pointCount;++t)i.points[t].normalImpulse=e.points[t].normalImpulse,i.points[t].tangentImpulse=e.points[t].tangentImpulse}}SolvePositionConstraints(){const t=Cg.SolvePositionConstraints_s_xfA,e=Cg.SolvePositionConstraints_s_xfB,i=Cg.SolvePositionConstraints_s_psm,s=Cg.SolvePositionConstraints_s_rA,n=Cg.SolvePositionConstraints_s_rB,r=Cg.SolvePositionConstraints_s_P;let o=0;for(let a=0;a<this.m_count;++a){const l=this.m_positionConstraints[a],h=l.indexA,c=l.indexB,m=l.localCenterA,u=l.invMassA,_=l.invIA,d=l.localCenterB,p=l.invMassB,f=l.invIB,y=l.pointCount,g=this.m_positions[h].c;let x=this.m_positions[h].a;const v=this.m_positions[c].c;let S=this.m_positions[c].a;for(let a=0;a<y;++a){t.q.SetAngle(x),e.q.SetAngle(S),ep.SubVV(g,op.MulRV(t.q,m,ep.s_t0),t.p),ep.SubVV(v,op.MulRV(e.q,d,ep.s_t0),e.p),i.Initialize(l,t,e,a);const h=i.normal,c=i.point,y=i.separation;ep.SubVV(c,g,s),ep.SubVV(c,v,n),o=Xd(o,y);const w=Zd(.2*(y+Gd),-.2,0),b=ep.CrossVV(s,h),C=ep.CrossVV(n,h),A=u+p+_*b*b+f*C*C,B=A>0?-w/A:0;ep.MulSV(B,h,r),g.SelfMulSub(u,r),x-=_*ep.CrossVV(s,r),v.SelfMulAdd(p,r),S+=f*ep.CrossVV(n,r)}this.m_positions[h].a=x,this.m_positions[c].a=S}return o>-.015}SolveTOIPositionConstraints(t,e){const i=Cg.SolveTOIPositionConstraints_s_xfA,s=Cg.SolveTOIPositionConstraints_s_xfB,n=Cg.SolveTOIPositionConstraints_s_psm,r=Cg.SolveTOIPositionConstraints_s_rA,o=Cg.SolveTOIPositionConstraints_s_rB,a=Cg.SolveTOIPositionConstraints_s_P;let l=0;for(let h=0;h<this.m_count;++h){const c=this.m_positionConstraints[h],m=c.indexA,u=c.indexB,_=c.localCenterA,d=c.localCenterB,p=c.pointCount;let f=0,y=0;m!==t&&m!==e||(f=c.invMassA,y=c.invIA);let g=0,x=0;u!==t&&u!==e||(g=c.invMassB,x=c.invIB);const v=this.m_positions[m].c;let S=this.m_positions[m].a;const w=this.m_positions[u].c;let b=this.m_positions[u].a;for(let t=0;t<p;++t){i.q.SetAngle(S),s.q.SetAngle(b),ep.SubVV(v,op.MulRV(i.q,_,ep.s_t0),i.p),ep.SubVV(w,op.MulRV(s.q,d,ep.s_t0),s.p),n.Initialize(c,i,s,t);const e=n.normal,h=n.point,m=n.separation;ep.SubVV(h,v,r),ep.SubVV(h,w,o),l=Xd(l,m);const u=Zd(.75*(m+Gd),-.2,0),p=ep.CrossVV(r,e),C=ep.CrossVV(o,e),A=f+g+y*p*p+x*C*C,B=A>0?-u/A:0;ep.MulSV(B,e,a),v.SelfMulSub(f,a),S-=y*ep.CrossVV(r,a),w.SelfMulAdd(g,a),b+=x*ep.CrossVV(o,a)}this.m_positions[m].a=S,this.m_positions[u].a=b}return l>=-.0075}}Cg.InitializeVelocityConstraints_s_xfA=new ap,Cg.InitializeVelocityConstraints_s_xfB=new ap,Cg.InitializeVelocityConstraints_s_worldManifold=new Gp,Cg.WarmStart_s_P=new ep,Cg.SolveVelocityConstraints_s_dv=new ep,Cg.SolveVelocityConstraints_s_dv1=new ep,Cg.SolveVelocityConstraints_s_dv2=new ep,Cg.SolveVelocityConstraints_s_P=new ep,Cg.SolveVelocityConstraints_s_a=new ep,Cg.SolveVelocityConstraints_s_b=new ep,Cg.SolveVelocityConstraints_s_x=new ep,Cg.SolveVelocityConstraints_s_d=new ep,Cg.SolveVelocityConstraints_s_P1=new ep,Cg.SolveVelocityConstraints_s_P2=new ep,Cg.SolveVelocityConstraints_s_P1P2=new ep,Cg.SolvePositionConstraints_s_xfA=new ap,Cg.SolvePositionConstraints_s_xfB=new ap,Cg.SolvePositionConstraints_s_psm=new bg,Cg.SolvePositionConstraints_s_rA=new ep,Cg.SolvePositionConstraints_s_rB=new ep,Cg.SolvePositionConstraints_s_P=new ep,Cg.SolveTOIPositionConstraints_s_xfA=new ap,Cg.SolveTOIPositionConstraints_s_xfB=new ap,Cg.SolveTOIPositionConstraints_s_psm=new bg,Cg.SolveTOIPositionConstraints_s_rA=new ep,Cg.SolveTOIPositionConstraints_s_rB=new ep,Cg.SolveTOIPositionConstraints_s_P=new ep;class Ag{constructor(){this.m_bodies=[],this.m_contacts=[],this.m_joints=[],this.m_positions=gg.MakeArray(1024),this.m_velocities=xg.MakeArray(1024),this.m_bodyCount=0,this.m_jointCount=0,this.m_contactCount=0,this.m_bodyCapacity=0,this.m_contactCapacity=0,this.m_jointCapacity=0}Initialize(t,e,i,s){if(this.m_bodyCapacity=t,this.m_contactCapacity=e,this.m_jointCapacity=i,this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0,this.m_listener=s,this.m_positions.length<t){const e=Jd(2*this.m_positions.length,t);for(;this.m_positions.length<e;)this.m_positions[this.m_positions.length]=new gg}if(this.m_velocities.length<t){const e=Jd(2*this.m_velocities.length,t);for(;this.m_velocities.length<e;)this.m_velocities[this.m_velocities.length]=new xg}}Clear(){this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0}AddBody(t){t.m_islandIndex=this.m_bodyCount,this.m_bodies[this.m_bodyCount++]=t}AddContact(t){this.m_contacts[this.m_contactCount++]=t}AddJoint(t){this.m_joints[this.m_jointCount++]=t}Solve(t,e,i,s){const n=Ag.s_timer.Reset(),r=e.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c);const s=e.m_sweep.a,n=this.m_velocities[t].v.Copy(e.m_linearVelocity);let o=e.m_angularVelocity;e.m_sweep.c0.Copy(e.m_sweep.c),e.m_sweep.a0=e.m_sweep.a,e.m_type===Ay.b2_dynamicBody&&(n.x+=r*e.m_invMass*(e.m_gravityScale*e.m_mass*i.x+e.m_force.x),n.y+=r*e.m_invMass*(e.m_gravityScale*e.m_mass*i.y+e.m_force.y),o+=r*e.m_invI*e.m_torque,n.SelfMul(1/(1+r*e.m_linearDamping)),o*=1/(1+r*e.m_angularDamping)),this.m_positions[t].a=s,this.m_velocities[t].w=o}n.Reset();const o=Ag.s_solverData;o.step.Copy(e),o.positions=this.m_positions,o.velocities=this.m_velocities;const a=Ag.s_contactSolverDef;a.step.Copy(e),a.contacts=this.m_contacts,a.count=this.m_contactCount,a.positions=this.m_positions,a.velocities=this.m_velocities;const l=Ag.s_contactSolver.Initialize(a);l.InitializeVelocityConstraints(),e.warmStarting&&l.WarmStart();for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].InitVelocityConstraints(o);t.solveInit=n.GetMilliseconds(),n.Reset();for(let t=0;t<e.velocityIterations;++t){for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].SolveVelocityConstraints(o);l.SolveVelocityConstraints()}l.StoreImpulses(),t.solveVelocity=n.GetMilliseconds();for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let i=this.m_positions[t].a;const s=this.m_velocities[t].v;let n=this.m_velocities[t].w;const o=ep.MulSV(r,s,Ag.s_translation);if(ep.DotVV(o,o)>4){const t=2/o.Length();s.SelfMul(t)}const a=r*n;a*a>Nd&&(n*=Od/qd(a)),e.x+=r*s.x,e.y+=r*s.y,i+=r*n,this.m_positions[t].a=i,this.m_velocities[t].w=n}n.Reset();let h=!1;for(let t=0;t<e.positionIterations;++t){const t=l.SolvePositionConstraints();let e=!0;for(let t=0;t<this.m_jointCount;++t){const i=this.m_joints[t].SolvePositionConstraints(o);e=e&&i}if(t&&e){h=!0;break}}for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];e.m_sweep.c.Copy(this.m_positions[t].c),e.m_sweep.a=this.m_positions[t].a,e.m_linearVelocity.Copy(this.m_velocities[t].v),e.m_angularVelocity=this.m_velocities[t].w,e.SynchronizeTransform()}if(t.solvePosition=n.GetMilliseconds(),this.Report(l.m_velocityConstraints),s){let t=Id;const e=1e-4,i=.0012184696791469947;for(let s=0;s<this.m_bodyCount;++s){const n=this.m_bodies[s];n.GetType()!==Ay.b2_staticBody&&(!n.m_autoSleepFlag||n.m_angularVelocity*n.m_angularVelocity>i||ep.DotVV(n.m_linearVelocity,n.m_linearVelocity)>e?(n.m_sleepTime=0,t=0):(n.m_sleepTime+=r,t=Xd(t,n.m_sleepTime)))}if(t>=.5&&h)for(let t=0;t<this.m_bodyCount;++t)this.m_bodies[t].SetAwake(!1)}}SolveTOI(t,e,i){for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c),this.m_positions[t].a=e.m_sweep.a,this.m_velocities[t].v.Copy(e.m_linearVelocity),this.m_velocities[t].w=e.m_angularVelocity}const s=Ag.s_contactSolverDef;s.contacts=this.m_contacts,s.count=this.m_contactCount,s.step.Copy(t),s.positions=this.m_positions,s.velocities=this.m_velocities;const n=Ag.s_contactSolver.Initialize(s);for(let s=0;s<t.positionIterations&&!n.SolveTOIPositionConstraints(e,i);++s);this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c),this.m_bodies[e].m_sweep.a0=this.m_positions[e].a,this.m_bodies[i].m_sweep.c0.Copy(this.m_positions[i].c),this.m_bodies[i].m_sweep.a0=this.m_positions[i].a,n.InitializeVelocityConstraints();for(let e=0;e<t.velocityIterations;++e)n.SolveVelocityConstraints();const r=t.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let i=this.m_positions[t].a;const s=this.m_velocities[t].v;let n=this.m_velocities[t].w;const o=ep.MulSV(r,s,Ag.s_translation);if(ep.DotVV(o,o)>4){const t=2/o.Length();s.SelfMul(t)}const a=r*n;a*a>Nd&&(n*=Od/qd(a)),e.SelfMulAdd(r,s),i+=r*n,this.m_positions[t].a=i,this.m_velocities[t].w=n;const l=this.m_bodies[t];l.m_sweep.c.Copy(e),l.m_sweep.a=i,l.m_linearVelocity.Copy(s),l.m_angularVelocity=n,l.SynchronizeTransform()}this.Report(n.m_velocityConstraints)}Report(t){if(null!==this.m_listener)for(let e=0;e<this.m_contactCount;++e){const i=this.m_contacts[e];if(!i)continue;const s=t[e],n=Ag.s_impulse;n.count=s.pointCount;for(let t=0;t<s.pointCount;++t)n.normalImpulses[t]=s.points[t].normalImpulse,n.tangentImpulses[t]=s.points[t].tangentImpulse;this.m_listener.PostSolve(i,n)}}}var Bg,Mg,Vg,Tg;Ag.s_timer=new Kp,Ag.s_solverData=new class{constructor(){this.step=new yg}},Ag.s_contactSolverDef=new class{constructor(){this.step=new yg,this.count=0}},Ag.s_contactSolver=new Cg,Ag.s_translation=new ep,Ag.s_impulse=new class{constructor(){this.normalImpulses=jd(2),this.tangentImpulses=jd(2),this.count=0}},function(t){t[t.b2_waterParticle=0]="b2_waterParticle",t[t.b2_zombieParticle=2]="b2_zombieParticle",t[t.b2_wallParticle=4]="b2_wallParticle",t[t.b2_springParticle=8]="b2_springParticle",t[t.b2_elasticParticle=16]="b2_elasticParticle",t[t.b2_viscousParticle=32]="b2_viscousParticle",t[t.b2_powderParticle=64]="b2_powderParticle",t[t.b2_tensileParticle=128]="b2_tensileParticle",t[t.b2_colorMixingParticle=256]="b2_colorMixingParticle",t[t.b2_destructionListenerParticle=512]="b2_destructionListenerParticle",t[t.b2_barrierParticle=1024]="b2_barrierParticle",t[t.b2_staticPressureParticle=2048]="b2_staticPressureParticle",t[t.b2_reactiveParticle=4096]="b2_reactiveParticle",t[t.b2_repulsiveParticle=8192]="b2_repulsiveParticle",t[t.b2_fixtureContactListenerParticle=16384]="b2_fixtureContactListenerParticle",t[t.b2_particleContactListenerParticle=32768]="b2_particleContactListenerParticle",t[t.b2_fixtureContactFilterParticle=65536]="b2_fixtureContactFilterParticle",t[t.b2_particleContactFilterParticle=131072]="b2_particleContactFilterParticle"}(Bg||(Bg={}));class Pg{constructor(){this.flags=0,this.position=new ep,this.velocity=new ep,this.color=new hp(0,0,0,0),this.lifetime=0,this.userData=null,this.group=null}}class Dg{constructor(){this.m_index=Ud}GetIndex(){return this.m_index}SetIndex(t){this.m_index=t}}!function(t){t[t.b2_solidParticleGroup=1]="b2_solidParticleGroup",t[t.b2_rigidParticleGroup=2]="b2_rigidParticleGroup",t[t.b2_particleGroupCanBeEmpty=4]="b2_particleGroupCanBeEmpty",t[t.b2_particleGroupWillBeDestroyed=8]="b2_particleGroupWillBeDestroyed",t[t.b2_particleGroupNeedsUpdateDepth=16]="b2_particleGroupNeedsUpdateDepth",t[t.b2_particleGroupInternalMask=24]="b2_particleGroupInternalMask"}(Mg||(Mg={}));class Ig{constructor(){this.flags=0,this.groupFlags=0,this.position=new ep,this.angle=0,this.linearVelocity=new ep,this.angularVelocity=0,this.color=new hp,this.strength=1,this.shapeCount=0,this.stride=0,this.particleCount=0,this.lifetime=0,this.userData=null,this.group=null}}class Eg{constructor(t){this.m_firstIndex=0,this.m_lastIndex=0,this.m_groupFlags=0,this.m_strength=1,this.m_prev=null,this.m_next=null,this.m_timestamp=-1,this.m_mass=0,this.m_inertia=0,this.m_center=new ep,this.m_linearVelocity=new ep,this.m_angularVelocity=0,this.m_transform=new ap,this.m_userData=null,this.m_system=t}GetNext(){return this.m_next}GetParticleSystem(){return this.m_system}GetParticleCount(){return this.m_lastIndex-this.m_firstIndex}GetBufferIndex(){return this.m_firstIndex}ContainsParticle(t){return this.m_firstIndex<=t&&t<this.m_lastIndex}GetAllParticleFlags(){if(!this.m_system.m_flagsBuffer.data)throw new Error;let t=0;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)t|=this.m_system.m_flagsBuffer.data[e];return t}GetGroupFlags(){return this.m_groupFlags}SetGroupFlags(t){t|=this.m_groupFlags&Mg.b2_particleGroupInternalMask,this.m_system.SetGroupFlags(this,t)}GetMass(){return this.UpdateStatistics(),this.m_mass}GetInertia(){return this.UpdateStatistics(),this.m_inertia}GetCenter(){return this.UpdateStatistics(),this.m_center}GetLinearVelocity(){return this.UpdateStatistics(),this.m_linearVelocity}GetAngularVelocity(){return this.UpdateStatistics(),this.m_angularVelocity}GetTransform(){return this.m_transform}GetPosition(){return this.m_transform.p}GetAngle(){return this.m_transform.q.GetAngle()}GetLinearVelocityFromWorldPoint(t,e){const i=Eg.GetLinearVelocityFromWorldPoint_s_t0;return this.UpdateStatistics(),ep.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,ep.SubVV(t,this.m_center,i),e)}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}ApplyForce(t){this.m_system.ApplyForce(this.m_firstIndex,this.m_lastIndex,t)}ApplyLinearImpulse(t){this.m_system.ApplyLinearImpulse(this.m_firstIndex,this.m_lastIndex,t)}DestroyParticles(t){if(this.m_system.m_world.IsLocked())throw new Error;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)this.m_system.DestroyParticle(e,t)}UpdateStatistics(){if(!this.m_system.m_positionBuffer.data)throw new Error;if(!this.m_system.m_velocityBuffer.data)throw new Error;const t=new ep,e=new ep;if(this.m_timestamp!==this.m_system.m_timestamp){const i=this.m_system.GetParticleMass();this.m_mass=i*(this.m_lastIndex-this.m_firstIndex),this.m_center.SetZero(),this.m_linearVelocity.SetZero();for(let t=this.m_firstIndex;t<this.m_lastIndex;t++)this.m_center.SelfMulAdd(i,this.m_system.m_positionBuffer.data[t]),this.m_linearVelocity.SelfMulAdd(i,this.m_system.m_velocityBuffer.data[t]);if(this.m_mass>0){const t=1/this.m_mass;this.m_center.SelfMul(t),this.m_linearVelocity.SelfMul(t)}this.m_inertia=0,this.m_angularVelocity=0;for(let s=this.m_firstIndex;s<this.m_lastIndex;s++)ep.SubVV(this.m_system.m_positionBuffer.data[s],this.m_center,t),ep.SubVV(this.m_system.m_velocityBuffer.data[s],this.m_linearVelocity,e),this.m_inertia+=i*ep.DotVV(t,t),this.m_angularVelocity+=i*ep.CrossVV(t,e);this.m_inertia>0&&(this.m_angularVelocity*=1/this.m_inertia),this.m_timestamp=this.m_system.m_timestamp}}}Eg.GetLinearVelocityFromWorldPoint_s_t0=new ep;class Rg{constructor(t){this.m_buffer=[],this.m_front=0,this.m_back=0,this.m_buffer.fill(null,0,t)}get m_capacity(){return this.m_buffer.length}Push(t){if(this.m_back>=this.m_capacity){for(let t=this.m_front;t<this.m_back;t++)this.m_buffer[t-this.m_front]=this.m_buffer[t];this.m_back-=this.m_front,this.m_front=0}this.m_buffer[this.m_back]=t,this.m_back++}Pop(){this.m_buffer[this.m_front]=null,this.m_front++}Empty(){return this.m_front===this.m_back}Front(){const t=this.m_buffer[this.m_front];if(!t)throw new Error;return t}}class Lg{constructor(t){this.m_generatorCapacity=0,this.m_generatorCount=0,this.m_countX=0,this.m_countY=0,this.m_diagram=[],this.m_generatorBuffer=Wd(t,(t=>new Gg)),this.m_generatorCapacity=t}AddGenerator(t,e,i){const s=this.m_generatorBuffer[this.m_generatorCount++];s.center.Copy(t),s.tag=e,s.necessary=i}Generate(t,e){const i=1/t,s=new ep(+Id,+Id),n=new ep(-Id,-Id);let r=0;for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.necessary&&(ep.MinV(s,e.center,s),ep.MaxV(n,e.center,n),++r)}if(0===r)return this.m_countX=0,void(this.m_countY=0);s.x-=e,s.y-=e,n.x+=e,n.y+=e,this.m_countX=1+Math.floor(i*(n.x-s.x)),this.m_countY=1+Math.floor(i*(n.y-s.y)),this.m_diagram=[];const o=new Rg(4*this.m_countX*this.m_countY);for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.center.SelfSub(s).SelfMul(i);const n=Math.floor(e.center.x),r=Math.floor(e.center.y);n>=0&&r>=0&&n<this.m_countX&&r<this.m_countY&&o.Push(new Fg(n,r,n+r*this.m_countX,e))}for(;!o.Empty();){const t=o.Front(),e=t.m_x,i=t.m_y,s=t.m_i,n=t.m_generator;o.Pop(),this.m_diagram[s]||(this.m_diagram[s]=n,e>0&&o.Push(new Fg(e-1,i,s-1,n)),i>0&&o.Push(new Fg(e,i-1,s-this.m_countX,n)),e<this.m_countX-1&&o.Push(new Fg(e+1,i,s+1,n)),i<this.m_countY-1&&o.Push(new Fg(e,i+1,s+this.m_countX,n)))}for(let t=0;t<this.m_countY;t++)for(let e=0;e<this.m_countX-1;e++){const i=e+t*this.m_countX,s=this.m_diagram[i],n=this.m_diagram[i+1];s!==n&&(o.Push(new Fg(e,t,i,n)),o.Push(new Fg(e+1,t,i+1,s)))}for(let t=0;t<this.m_countY-1;t++)for(let e=0;e<this.m_countX;e++){const i=e+t*this.m_countX,s=this.m_diagram[i],n=this.m_diagram[i+this.m_countX];s!==n&&(o.Push(new Fg(e,t,i,n)),o.Push(new Fg(e,t+1,i+this.m_countX,s)))}for(;!o.Empty();){const t=o.Front(),e=t.m_x,i=t.m_y,s=t.m_i,n=t.m_generator;o.Pop();const r=this.m_diagram[s],a=n;if(r!==a){const t=r.center.x-e,n=r.center.y-i,l=a.center.x-e,h=a.center.y-i;t*t+n*n>l*l+h*h&&(this.m_diagram[s]=a,e>0&&o.Push(new Fg(e-1,i,s-1,a)),i>0&&o.Push(new Fg(e,i-1,s-this.m_countX,a)),e<this.m_countX-1&&o.Push(new Fg(e+1,i,s+1,a)),i<this.m_countY-1&&o.Push(new Fg(e,i+1,s+this.m_countX,a)))}}}GetNodes(t){for(let e=0;e<this.m_countY-1;e++)for(let i=0;i<this.m_countX-1;i++){const s=i+e*this.m_countX,n=this.m_diagram[s],r=this.m_diagram[s+1],o=this.m_diagram[s+this.m_countX],a=this.m_diagram[s+1+this.m_countX];r!==o&&(n!==r&&n!==o&&(n.necessary||r.necessary||o.necessary)&&t(n.tag,r.tag,o.tag),a!==r&&a!==o&&(n.necessary||r.necessary||o.necessary)&&t(r.tag,a.tag,o.tag))}}}class Gg{constructor(){this.center=new ep,this.tag=0,this.necessary=!1}}class Fg{constructor(t,e,i,s){this.m_x=t,this.m_y=e,this.m_i=i,this.m_generator=s}}function kg(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}function zg(t,e){return t<e}function Og(t,e=0,i=t.length-e,s=zg){let n=e;const r=[];let o=0;for(;;){for(;n+1<i;i++){const e=t[n+Math.floor(Math.random()*(i-n))];r[o++]=i;for(let r=n-1;;){for(;s(t[++r],e););for(;s(e,t[--i]););if(r>=i)break;kg(t,r,i)}}if(0===o)break;n=i,i=r[--o]}return t}function Ng(t,e=0,i=t.length-e,s=zg){return Og(t,e,i,s)}function Ug(t,e,i=t.length){let s=0;for(let n=0;n<i;++n)e(t[n])||(n!==s?kg(t,s++,n):++s);return s}function Wg(t,e,i,s,n){let r=i-e;for(;r>0;){const i=Math.floor(r/2);let o=e+i;n(t[o],s)?(e=++o,r-=i+1):r=i}return e}function jg(t,e,i,s,n){let r=i-e;for(;r>0;){const i=Math.floor(r/2);let o=e+i;n(s,t[o])?r=i:(e=++o,r-=i+1)}return e}function Hg(t,e,i,s){let n=i;for(;e!==n;)kg(t,e++,n++),n===s?n=i:e===i&&(i=n)}class qg{constructor(t){this.data=[],this.count=0,this.capacity=0,this.allocator=t}Append(){return this.count>=this.capacity&&this.Grow(),this.count++}Reserve(t){if(!(this.capacity>=t)){for(let e=this.capacity;e<t;++e)this.data[e]=this.allocator();this.capacity=t}}Grow(){const t=this.capacity?2*this.capacity:256;this.Reserve(t)}Free(){0!==this.data.length&&(this.data=[],this.capacity=0,this.count=0)}Shorten(t){}Data(){return this.data}GetCount(){return this.count}SetCount(t){this.count=t}GetCapacity(){return this.capacity}RemoveIf(t){this.count=Ug(this.data,t,this.count)}Unique(t){this.count=function(t,e,i,s){if(e===i)return i;let n=e;for(;++e!==i;)s(t[n],t[e])||kg(t,++n,e);return++n}(this.data,0,this.count,t)}}class Xg extends dg{constructor(t){super(),this.m_system=t}ShouldQueryParticleSystem(t){return!1}ReportFixture(t){if(t.IsSensor())return!0;const e=t.GetShape().GetChildCount();for(let i=0;i<e;i++){const e=t.GetAABB(i),s=this.m_system.GetInsideBoundsEnumerator(e);let n;for(;(n=s.GetNext())>=0;)this.ReportFixtureAndParticle(t,i,n)}return!0}ReportParticle(t,e){return!1}ReportFixtureAndParticle(t,e,i){}}class Jg{constructor(){this.indexA=0,this.indexB=0,this.weight=0,this.normal=new ep,this.flags=0}SetIndices(t,e){this.indexA=t,this.indexB=e}SetWeight(t){this.weight=t}SetNormal(t){this.normal.Copy(t)}SetFlags(t){this.flags=t}GetIndexA(){return this.indexA}GetIndexB(){return this.indexB}GetWeight(){return this.weight}GetNormal(){return this.normal}GetFlags(){return this.flags}IsEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&this.weight===t.weight&&this.normal.x===t.normal.x&&this.normal.y===t.normal.y}IsNotEqual(t){return!this.IsEqual(t)}ApproximatelyEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&qd(this.weight-t.weight)<.01&&ep.DistanceSquaredVV(this.normal,t.normal)<1e-4}}class Zg{constructor(){this.index=0,this.weight=0,this.normal=new ep,this.mass=0}}class Yg{constructor(){this.indexA=0,this.indexB=0,this.flags=0,this.strength=0,this.distance=0}}class Qg{constructor(){this.indexA=0,this.indexB=0,this.indexC=0,this.flags=0,this.strength=0,this.pa=new ep(0,0),this.pb=new ep(0,0),this.pc=new ep(0,0),this.ka=0,this.kb=0,this.kc=0,this.s=0}}class Kg{constructor(){this.strictContactCheck=!1,this.density=1,this.gravityScale=1,this.radius=1,this.maxCount=0,this.pressureStrength=.005,this.dampingStrength=1,this.elasticStrength=.25,this.springStrength=.25,this.viscousStrength=.25,this.surfaceTensionPressureStrength=.2,this.surfaceTensionNormalStrength=.2,this.repulsiveStrength=1,this.powderStrength=.5,this.ejectionStrength=.5,this.staticPressureStrength=.2,this.staticPressureRelaxation=.2,this.staticPressureIterations=8,this.colorMixingStrength=.5,this.destroyByAge=!0,this.lifetimeGranularity=1/60}Copy(t){return this.strictContactCheck=t.strictContactCheck,this.density=t.density,this.gravityScale=t.gravityScale,this.radius=t.radius,this.maxCount=t.maxCount,this.pressureStrength=t.pressureStrength,this.dampingStrength=t.dampingStrength,this.elasticStrength=t.elasticStrength,this.springStrength=t.springStrength,this.viscousStrength=t.viscousStrength,this.surfaceTensionPressureStrength=t.surfaceTensionPressureStrength,this.surfaceTensionNormalStrength=t.surfaceTensionNormalStrength,this.repulsiveStrength=t.repulsiveStrength,this.powderStrength=t.powderStrength,this.ejectionStrength=t.ejectionStrength,this.staticPressureStrength=t.staticPressureStrength,this.staticPressureRelaxation=t.staticPressureRelaxation,this.staticPressureIterations=t.staticPressureIterations,this.colorMixingStrength=t.colorMixingStrength,this.destroyByAge=t.destroyByAge,this.lifetimeGranularity=t.lifetimeGranularity,this}Clone(){return(new Kg).Copy(this)}}class $g{constructor(t,e){this.m_paused=!1,this.m_timestamp=0,this.m_allParticleFlags=0,this.m_needsUpdateAllParticleFlags=!1,this.m_allGroupFlags=0,this.m_needsUpdateAllGroupFlags=!1,this.m_hasForce=!1,this.m_iterationIndex=0,this.m_inverseDensity=0,this.m_particleDiameter=0,this.m_inverseDiameter=0,this.m_squaredDiameter=0,this.m_count=0,this.m_internalAllocatedCapacity=0,this.m_handleIndexBuffer=new tx,this.m_flagsBuffer=new tx,this.m_positionBuffer=new tx,this.m_velocityBuffer=new tx,this.m_forceBuffer=[],this.m_weightBuffer=[],this.m_staticPressureBuffer=[],this.m_accumulationBuffer=[],this.m_accumulation2Buffer=[],this.m_depthBuffer=[],this.m_colorBuffer=new tx,this.m_groupBuffer=[],this.m_userDataBuffer=new tx,this.m_stuckThreshold=0,this.m_lastBodyContactStepBuffer=new tx,this.m_bodyContactCountBuffer=new tx,this.m_consecutiveContactStepsBuffer=new tx,this.m_stuckParticleBuffer=new qg((()=>0)),this.m_proxyBuffer=new qg((()=>new ex)),this.m_contactBuffer=new qg((()=>new Jg)),this.m_bodyContactBuffer=new qg((()=>new Zg)),this.m_pairBuffer=new qg((()=>new Yg)),this.m_triadBuffer=new qg((()=>new Qg)),this.m_expirationTimeBuffer=new tx,this.m_indexByExpirationTimeBuffer=new tx,this.m_timeElapsed=0,this.m_expirationTimeBufferRequiresSorting=!1,this.m_groupCount=0,this.m_groupList=null,this.m_def=new Kg,this.m_prev=null,this.m_next=null,this.UpdateBodyContacts_callback=null,this.SolveCollision_callback=null,this.SetStrictContactCheck(t.strictContactCheck),this.SetDensity(t.density),this.SetGravityScale(t.gravityScale),this.SetRadius(t.radius),this.SetMaxParticleCount(t.maxCount),this.m_def=t.Clone(),this.m_world=e,this.SetDestructionByAge(this.m_def.destroyByAge)}static computeTag(t,e){return(e+$g.yOffset>>>0<<$g.yShift)+($g.xScale*t+$g.xOffset>>>0)>>>0}static computeRelativeTag(t,e,i){return t+(i<<$g.yShift)+(e<<$g.xShift)>>>0}Drop(){for(;this.m_groupList;)this.DestroyParticleGroup(this.m_groupList);this.FreeUserOverridableBuffer(this.m_handleIndexBuffer),this.FreeUserOverridableBuffer(this.m_flagsBuffer),this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer),this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer),this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer),this.FreeUserOverridableBuffer(this.m_positionBuffer),this.FreeUserOverridableBuffer(this.m_velocityBuffer),this.FreeUserOverridableBuffer(this.m_colorBuffer),this.FreeUserOverridableBuffer(this.m_userDataBuffer),this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer),this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer),this.FreeBuffer(this.m_forceBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_weightBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_staticPressureBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulationBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulation2Buffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_depthBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_groupBuffer,this.m_internalAllocatedCapacity)}CreateParticle(t){if(this.m_world.IsLocked())throw new Error;if(this.m_count>=this.m_internalAllocatedCapacity){const t=this.m_count?2*this.m_count:256;this.ReallocateInternalAllocatedBuffers(t)}if(this.m_count>=this.m_internalAllocatedCapacity){if(!this.m_def.destroyByAge)return Ud;this.DestroyOldestParticle(0,!1),this.SolveZombie()}const e=this.m_count++;this.m_flagsBuffer.data[e]=0,this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[e]=0),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[e]=0),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[e]=0),this.m_positionBuffer.data[e]=(this.m_positionBuffer.data[e]||new ep).Copy(Dd(t.position,ep.ZERO)),this.m_velocityBuffer.data[e]=(this.m_velocityBuffer.data[e]||new ep).Copy(Dd(t.velocity,ep.ZERO)),this.m_weightBuffer[e]=0,this.m_forceBuffer[e]=(this.m_forceBuffer[e]||new ep).SetZero(),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[e]=0),this.m_depthBuffer&&(this.m_depthBuffer[e]=0);const i=(new hp).Copy(Dd(t.color,hp.ZERO));!this.m_colorBuffer.data&&i.IsZero()||(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data[e]=(this.m_colorBuffer.data[e]||new hp).Copy(i)),(this.m_userDataBuffer.data||t.userData)&&(this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data[e]=t.userData),this.m_handleIndexBuffer.data&&(this.m_handleIndexBuffer.data[e]=null);const s=this.m_proxyBuffer.data[this.m_proxyBuffer.Append()],n=Dd(t.lifetime,0),r=n>0;(this.m_expirationTimeBuffer.data||r)&&(this.SetParticleLifetime(e,r?n:this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed())),this.m_indexByExpirationTimeBuffer.data[e]=e),s.index=e;const o=Dd(t.group,null);return this.m_groupBuffer[e]=o,o&&(o.m_firstIndex<o.m_lastIndex?(this.RotateBuffer(o.m_firstIndex,o.m_lastIndex,e),o.m_lastIndex=e+1):(o.m_firstIndex=e,o.m_lastIndex=e+1)),this.SetParticleFlags(e,Dd(t.flags,0)),e}GetParticleHandleFromIndex(t){this.m_handleIndexBuffer.data=this.RequestBuffer(this.m_handleIndexBuffer.data);let e=this.m_handleIndexBuffer.data[t];return e||(e=new Dg,e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e,e)}DestroyParticle(t,e=!1){let i=Bg.b2_zombieParticle;e&&(i|=Bg.b2_destructionListenerParticle),this.SetParticleFlags(t,this.m_flagsBuffer.data[t]|i)}DestroyOldestParticle(t,e=!1){const i=this.GetParticleCount(),s=this.m_indexByExpirationTimeBuffer.data[i-(t+1)],n=this.m_indexByExpirationTimeBuffer.data[t];this.DestroyParticle(this.m_expirationTimeBuffer.data[s]>0?s:n,e)}DestroyParticlesInShape(t,e,i=!1){const s=$g.DestroyParticlesInShape_s_aabb;if(this.m_world.IsLocked())throw new Error;const n=new lx(this,t,e,i),r=s;return t.ComputeAABB(r,e,0),this.m_world.QueryAABB(n,r),n.Destroyed()}CreateParticleGroup(t){const e=$g.CreateParticleGroup_s_transform;if(this.m_world.IsLocked())throw new Error;const i=e;i.SetPositionAngle(Dd(t.position,ep.ZERO),Dd(t.angle,0));const s=this.m_count;if(t.shape&&this.CreateParticlesWithShapeForGroup(t.shape,t,i),t.shapes&&this.CreateParticlesWithShapesForGroup(t.shapes,Dd(t.shapeCount,t.shapes.length),t,i),t.positionData){const e=Dd(t.particleCount,t.positionData.length);for(let s=0;s<e;s++){const e=t.positionData[s];this.CreateParticleForGroup(t,i,e)}}const n=this.m_count;let r=new Eg(this);r.m_firstIndex=s,r.m_lastIndex=n,r.m_strength=Dd(t.strength,1),r.m_userData=t.userData,r.m_transform.Copy(i),r.m_prev=null,r.m_next=this.m_groupList,this.m_groupList&&(this.m_groupList.m_prev=r),this.m_groupList=r,++this.m_groupCount;for(let t=s;t<n;t++)this.m_groupBuffer[t]=r;this.SetGroupFlags(r,Dd(t.groupFlags,0));const o=new ax;return this.UpdateContacts(!0),this.UpdatePairsAndTriads(s,n,o),t.group&&(this.JoinParticleGroups(t.group,r),r=t.group),r}JoinParticleGroups(t,e){if(this.m_world.IsLocked())throw new Error;this.RotateBuffer(e.m_firstIndex,e.m_lastIndex,this.m_count),this.RotateBuffer(t.m_firstIndex,t.m_lastIndex,e.m_firstIndex);const i=new hx(e.m_firstIndex);this.UpdateContacts(!0),this.UpdatePairsAndTriads(t.m_firstIndex,e.m_lastIndex,i);for(let i=e.m_firstIndex;i<e.m_lastIndex;i++)this.m_groupBuffer[i]=t;const s=t.m_groupFlags|e.m_groupFlags;this.SetGroupFlags(t,s),t.m_lastIndex=e.m_lastIndex,e.m_firstIndex=e.m_lastIndex,this.DestroyParticleGroup(e)}SplitParticleGroup(t){this.UpdateContacts(!0);const e=Wd(t.GetParticleCount(),(t=>new sx));$g.InitializeParticleLists(t,e),this.MergeParticleListsInContact(t,e);const i=$g.FindLongestParticleList(t,e);this.MergeZombieParticleListNodes(t,e,i),this.CreateParticleGroupsFromParticleList(t,e,i),this.UpdatePairsAndTriadsWithParticleList(t,e)}GetParticleGroupList(){return this.m_groupList}GetParticleGroupCount(){return this.m_groupCount}GetParticleCount(){return this.m_count}GetMaxParticleCount(){return this.m_def.maxCount}SetMaxParticleCount(t){this.m_def.maxCount=t}GetAllParticleFlags(){return this.m_allParticleFlags}GetAllGroupFlags(){return this.m_allGroupFlags}SetPaused(t){this.m_paused=t}GetPaused(){return this.m_paused}SetDensity(t){this.m_def.density=t,this.m_inverseDensity=1/this.m_def.density}GetDensity(){return this.m_def.density}SetGravityScale(t){this.m_def.gravityScale=t}GetGravityScale(){return this.m_def.gravityScale}SetDamping(t){this.m_def.dampingStrength=t}GetDamping(){return this.m_def.dampingStrength}SetStaticPressureIterations(t){this.m_def.staticPressureIterations=t}GetStaticPressureIterations(){return this.m_def.staticPressureIterations}SetRadius(t){this.m_particleDiameter=2*t,this.m_squaredDiameter=this.m_particleDiameter*this.m_particleDiameter,this.m_inverseDiameter=1/this.m_particleDiameter}GetRadius(){return this.m_particleDiameter/2}GetPositionBuffer(){return this.m_positionBuffer.data}GetVelocityBuffer(){return this.m_velocityBuffer.data}GetColorBuffer(){return this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data}GetGroupBuffer(){return this.m_groupBuffer}GetWeightBuffer(){return this.m_weightBuffer}GetUserDataBuffer(){return this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data}GetFlagsBuffer(){return this.m_flagsBuffer.data}SetParticleFlags(t,e){this.m_flagsBuffer.data[t]&~e&&(this.m_needsUpdateAllParticleFlags=!0),~this.m_allParticleFlags&e&&(e&Bg.b2_tensileParticle&&(this.m_accumulation2Buffer=this.RequestBuffer(this.m_accumulation2Buffer)),e&Bg.b2_colorMixingParticle&&(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data)),this.m_allParticleFlags|=e),this.m_flagsBuffer.data[t]=e}GetParticleFlags(t){return this.m_flagsBuffer.data[t]}SetFlagsBuffer(t){this.SetUserOverridableBuffer(this.m_flagsBuffer,t)}SetPositionBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,i=new Array(e);for(let s=0;s<e;++s)i[s]=new ip(t.subarray(2*s,2*s+2));t=i}this.SetUserOverridableBuffer(this.m_positionBuffer,t)}SetVelocityBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,i=new Array(e);for(let s=0;s<e;++s)i[s]=new ip(t.subarray(2*s,2*s+2));t=i}this.SetUserOverridableBuffer(this.m_velocityBuffer,t)}SetColorBuffer(t){if(t instanceof Float32Array){if(t.length%4!=0)throw new Error;const e=t.length/4,i=new Array(e);for(let s=0;s<e;++s)i[s]=new cp(t.subarray(4*s,4*s+4));t=i}this.SetUserOverridableBuffer(this.m_colorBuffer,t)}SetUserDataBuffer(t){this.SetUserOverridableBuffer(this.m_userDataBuffer,t)}GetContacts(){return this.m_contactBuffer.data}GetContactCount(){return this.m_contactBuffer.count}GetBodyContacts(){return this.m_bodyContactBuffer.data}GetBodyContactCount(){return this.m_bodyContactBuffer.count}GetPairs(){return this.m_pairBuffer.data}GetPairCount(){return this.m_pairBuffer.count}GetTriads(){return this.m_triadBuffer.data}GetTriadCount(){return this.m_triadBuffer.count}SetStuckThreshold(t){this.m_stuckThreshold=t,t>0&&(this.m_lastBodyContactStepBuffer.data=this.RequestBuffer(this.m_lastBodyContactStepBuffer.data),this.m_bodyContactCountBuffer.data=this.RequestBuffer(this.m_bodyContactCountBuffer.data),this.m_consecutiveContactStepsBuffer.data=this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data))}GetStuckCandidates(){return this.m_stuckParticleBuffer.Data()}GetStuckCandidateCount(){return this.m_stuckParticleBuffer.GetCount()}ComputeCollisionEnergy(){const t=$g.ComputeCollisionEnergy_s_v,e=this.m_velocityBuffer.data;let i=0;for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,o=n.indexB,a=n.normal,l=ep.SubVV(e[o],e[r],t),h=ep.DotVV(l,a);h<0&&(i+=h*h)}return.5*this.GetParticleMass()*i}SetStrictContactCheck(t){this.m_def.strictContactCheck=t}GetStrictContactCheck(){return this.m_def.strictContactCheck}SetParticleLifetime(t,e){const i=null===this.m_indexByExpirationTimeBuffer.data;if(this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),i){const t=this.GetParticleCount();for(let e=0;e<t;++e)this.m_indexByExpirationTimeBuffer.data[e]=e}const s=e/this.m_def.lifetimeGranularity,n=s>0?this.GetQuantizedTimeElapsed()+s:s;n!==this.m_expirationTimeBuffer.data[t]&&(this.m_expirationTimeBuffer.data[t]=n,this.m_expirationTimeBufferRequiresSorting=!0)}GetParticleLifetime(t){return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[t])}SetDestructionByAge(t){t&&this.GetExpirationTimeBuffer(),this.m_def.destroyByAge=t}GetDestructionByAge(){return this.m_def.destroyByAge}GetExpirationTimeBuffer(){return this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_expirationTimeBuffer.data}ExpirationTimeToLifetime(t){return(t>0?t-this.GetQuantizedTimeElapsed():t)*this.m_def.lifetimeGranularity}GetIndexByExpirationTimeBuffer(){return this.GetParticleCount()?this.SetParticleLifetime(0,this.GetParticleLifetime(0)):this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data}ParticleApplyLinearImpulse(t,e){this.ApplyLinearImpulse(t,t+1,e)}ApplyLinearImpulse(t,e,i){const s=this.m_velocityBuffer.data,n=(e-t)*this.GetParticleMass(),r=(new ep).Copy(i).SelfMul(1/n);for(let i=t;i<e;i++)s[i].SelfAdd(r)}static IsSignificantForce(t){return 0!==t.x||0!==t.y}ParticleApplyForce(t,e){$g.IsSignificantForce(e)&&this.ForceCanBeApplied(this.m_flagsBuffer.data[t])&&(this.PrepareForceBuffer(),this.m_forceBuffer[t].SelfAdd(e))}ApplyForce(t,e,i){const s=(new ep).Copy(i).SelfMul(1/(e-t));if($g.IsSignificantForce(s)){this.PrepareForceBuffer();for(let i=t;i<e;i++)this.m_forceBuffer[i].SelfAdd(s)}}GetNext(){return this.m_next}QueryAABB(t,e){if(0===this.m_proxyBuffer.count)return;const i=this.m_proxyBuffer.count,s=Wg(this.m_proxyBuffer.data,0,i,$g.computeTag(this.m_inverseDiameter*e.lowerBound.x,this.m_inverseDiameter*e.lowerBound.y),ex.CompareProxyTag),n=jg(this.m_proxyBuffer.data,s,i,$g.computeTag(this.m_inverseDiameter*e.upperBound.x,this.m_inverseDiameter*e.upperBound.y),ex.CompareTagProxy),r=this.m_positionBuffer.data;for(let i=s;i<n;++i){const s=this.m_proxyBuffer.data[i].index,n=r[s];if(e.lowerBound.x<n.x&&n.x<e.upperBound.x&&e.lowerBound.y<n.y&&n.y<e.upperBound.y&&!t.ReportParticle(this,s))break}}QueryShapeAABB(t,e,i,s=0){const n=$g.QueryShapeAABB_s_aabb;e.ComputeAABB(n,i,s),this.QueryAABB(t,n)}QueryPointAABB(t,e,i=.005){const s=$g.QueryPointAABB_s_aabb;s.lowerBound.Set(e.x-i,e.y-i),s.upperBound.Set(e.x+i,e.y+i),this.QueryAABB(t,s)}RayCast(t,e,i){const s=$g.RayCast_s_aabb,n=$g.RayCast_s_p,r=$g.RayCast_s_v,o=$g.RayCast_s_n,a=$g.RayCast_s_point;if(0===this.m_proxyBuffer.count)return;const l=this.m_positionBuffer.data,h=s;ep.MinV(e,i,h.lowerBound),ep.MaxV(e,i,h.upperBound);let c=1;const m=ep.SubVV(i,e,r),u=ep.DotVV(m,m),_=this.GetInsideBoundsEnumerator(h);let d;for(;(d=_.GetNext())>=0;){const i=ep.SubVV(e,l[d],n),s=ep.DotVV(i,m),r=s*s-u*(ep.DotVV(i,i)-this.m_squaredDiameter);if(r>=0){const n=Kd(r);let l=(-s-n)/u;if(l>c)continue;if(l<0&&(l=(-s+n)/u,l<0||l>c))continue;const h=ep.AddVMulSV(i,l,m,o);if(h.Normalize(),c=Xd(c,t.ReportParticle(this,d,ep.AddVMulSV(e,l,m,a),h,l)),c<=0)break}}}ComputeAABB(t){const e=this.GetParticleCount();t.lowerBound.x=+Id,t.lowerBound.y=+Id,t.upperBound.x=-Id,t.upperBound.y=-Id;const i=this.m_positionBuffer.data;for(let s=0;s<e;s++){const e=i[s];ep.MinV(t.lowerBound,e,t.lowerBound),ep.MaxV(t.upperBound,e,t.upperBound)}t.lowerBound.x-=this.m_particleDiameter,t.lowerBound.y-=this.m_particleDiameter,t.upperBound.x+=this.m_particleDiameter,t.upperBound.y+=this.m_particleDiameter}FreeBuffer(t,e){null!==t&&(t.length=0)}FreeUserOverridableBuffer(t){0===t.userSuppliedCapacity&&this.FreeBuffer(t.data,this.m_internalAllocatedCapacity)}ReallocateBuffer3(t,e,i){if(i<=e)throw new Error;const s=t?t.slice():[];return s.length=i,s}ReallocateBuffer5(t,e,i,s,n){if(s<=i)throw new Error;if(e&&!(s<=e))throw new Error;return n&&!t||e||(t=this.ReallocateBuffer3(t,i,s)),t}ReallocateBuffer4(t,e,i,s){return this.ReallocateBuffer5(t.data,t.userSuppliedCapacity,e,i,s)}RequestBuffer(t){return t||(0===this.m_internalAllocatedCapacity&&this.ReallocateInternalAllocatedBuffers(256),(t=[]).length=this.m_internalAllocatedCapacity),t}ReallocateHandleBuffers(t){this.m_handleIndexBuffer.data=this.ReallocateBuffer4(this.m_handleIndexBuffer,this.m_internalAllocatedCapacity,t,!0)}ReallocateInternalAllocatedBuffers(t){function e(t,e){return e&&t>e?e:t}if(t=e(t,this.m_def.maxCount),t=e(t,this.m_flagsBuffer.userSuppliedCapacity),t=e(t,this.m_positionBuffer.userSuppliedCapacity),t=e(t,this.m_velocityBuffer.userSuppliedCapacity),t=e(t,this.m_colorBuffer.userSuppliedCapacity),t=e(t,this.m_userDataBuffer.userSuppliedCapacity),this.m_internalAllocatedCapacity<t){this.ReallocateHandleBuffers(t),this.m_flagsBuffer.data=this.ReallocateBuffer4(this.m_flagsBuffer,this.m_internalAllocatedCapacity,t,!1);const e=this.m_stuckThreshold>0;this.m_lastBodyContactStepBuffer.data=this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer,this.m_internalAllocatedCapacity,t,e),this.m_bodyContactCountBuffer.data=this.ReallocateBuffer4(this.m_bodyContactCountBuffer,this.m_internalAllocatedCapacity,t,e),this.m_consecutiveContactStepsBuffer.data=this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer,this.m_internalAllocatedCapacity,t,e),this.m_positionBuffer.data=this.ReallocateBuffer4(this.m_positionBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_velocityBuffer.data=this.ReallocateBuffer4(this.m_velocityBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_forceBuffer=this.ReallocateBuffer5(this.m_forceBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_weightBuffer=this.ReallocateBuffer5(this.m_weightBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_staticPressureBuffer=this.ReallocateBuffer5(this.m_staticPressureBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_accumulationBuffer=this.ReallocateBuffer5(this.m_accumulationBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_accumulation2Buffer=this.ReallocateBuffer5(this.m_accumulation2Buffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_depthBuffer=this.ReallocateBuffer5(this.m_depthBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_colorBuffer.data=this.ReallocateBuffer4(this.m_colorBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_groupBuffer=this.ReallocateBuffer5(this.m_groupBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_userDataBuffer.data=this.ReallocateBuffer4(this.m_userDataBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_expirationTimeBuffer.data=this.ReallocateBuffer4(this.m_expirationTimeBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_indexByExpirationTimeBuffer.data=this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_internalAllocatedCapacity=t}}CreateParticleForGroup(t,e,i){const s=new Pg;s.flags=Dd(t.flags,0),ap.MulXV(e,i,s.position),ep.AddVV(Dd(t.linearVelocity,ep.ZERO),ep.CrossSV(Dd(t.angularVelocity,0),ep.SubVV(s.position,Dd(t.position,ep.ZERO),ep.s_t0),ep.s_t0),s.velocity),s.color.Copy(Dd(t.color,hp.ZERO)),s.lifetime=Dd(t.lifetime,0),s.userData=t.userData,this.CreateParticle(s)}CreateParticlesStrokeShapeForGroup(t,e,i){const s=$g.CreateParticlesStrokeShapeForGroup_s_edge,n=$g.CreateParticlesStrokeShapeForGroup_s_d,r=$g.CreateParticlesStrokeShapeForGroup_s_p;let o=Dd(e.stride,0);0===o&&(o=this.GetParticleStride());let a=0;const l=t.GetChildCount();for(let h=0;h<l;h++){let l=null;t.GetType()===Cy.e_edgeShape?l=t:(l=s,t.GetChildEdge(l,h));const c=ep.SubVV(l.m_vertex2,l.m_vertex1,n),m=c.Length();for(;a<m;){const t=ep.AddVMulSV(l.m_vertex1,a/m,c,r);this.CreateParticleForGroup(e,i,t),a+=o}a-=m}}CreateParticlesFillShapeForGroup(t,e,i){const s=$g.CreateParticlesFillShapeForGroup_s_aabb,n=$g.CreateParticlesFillShapeForGroup_s_p;let r=Dd(e.stride,0);0===r&&(r=this.GetParticleStride());const o=ap.IDENTITY,a=s;t.ComputeAABB(a,o,0);for(let s=Math.floor(a.lowerBound.y/r)*r;s<a.upperBound.y;s+=r)for(let l=Math.floor(a.lowerBound.x/r)*r;l<a.upperBound.x;l+=r){const r=n.Set(l,s);t.TestPoint(o,r)&&this.CreateParticleForGroup(e,i,r)}}CreateParticlesWithShapeForGroup(t,e,i){switch(t.GetType()){case Cy.e_edgeShape:case Cy.e_chainShape:this.CreateParticlesStrokeShapeForGroup(t,e,i);break;case Cy.e_polygonShape:case Cy.e_circleShape:this.CreateParticlesFillShapeForGroup(t,e,i)}}CreateParticlesWithShapesForGroup(t,e,i,s){const n=new cx(t,e);this.CreateParticlesFillShapeForGroup(n,i,s)}CloneParticle(t,e){const i=new Pg;i.flags=this.m_flagsBuffer.data[t],i.position.Copy(this.m_positionBuffer.data[t]),i.velocity.Copy(this.m_velocityBuffer.data[t]),this.m_colorBuffer.data&&i.color.Copy(this.m_colorBuffer.data[t]),this.m_userDataBuffer.data&&(i.userData=this.m_userDataBuffer.data[t]),i.group=e;const s=this.CreateParticle(i);if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[t];e&&e.SetIndex(s),this.m_handleIndexBuffer.data[s]=e,this.m_handleIndexBuffer.data[t]=null}return this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[s]=this.m_lastBodyContactStepBuffer.data[t]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[s]=this.m_bodyContactCountBuffer.data[t]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[s]=this.m_consecutiveContactStepsBuffer.data[t]),this.m_hasForce&&this.m_forceBuffer[s].Copy(this.m_forceBuffer[t]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[s]=this.m_staticPressureBuffer[t]),this.m_depthBuffer&&(this.m_depthBuffer[s]=this.m_depthBuffer[t]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[s]=this.m_expirationTimeBuffer.data[t]),s}DestroyParticlesInGroup(t,e=!1){for(let i=t.m_firstIndex;i<t.m_lastIndex;i++)this.DestroyParticle(i,e)}DestroyParticleGroup(t){this.m_world.m_destructionListener&&this.m_world.m_destructionListener.SayGoodbyeParticleGroup(t),this.SetGroupFlags(t,0);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_groupBuffer[e]=null;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_groupList&&(this.m_groupList=t.m_next),--this.m_groupCount}static ParticleCanBeConnected(t,e){return 0!=(t&(Bg.b2_wallParticle|Bg.b2_springParticle|Bg.b2_elasticParticle))||null!==e&&0!=(e.GetGroupFlags()&Mg.b2_rigidParticleGroup)}UpdatePairsAndTriads(t,e,i){const s=$g.UpdatePairsAndTriads_s_dab,n=$g.UpdatePairsAndTriads_s_dbc,r=$g.UpdatePairsAndTriads_s_dca,o=this.m_positionBuffer.data;let a=0;for(let i=t;i<e;i++)a|=this.m_flagsBuffer.data[i];if(a&$g.k_pairFlags)for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,a=n.indexB,l=this.m_flagsBuffer.data[r],h=this.m_flagsBuffer.data[a],c=this.m_groupBuffer[r],m=this.m_groupBuffer[a];if(r>=t&&r<e&&a>=t&&a<e&&!((l|h)&Bg.b2_zombieParticle)&&(l|h)&$g.k_pairFlags&&(i.IsNecessary(r)||i.IsNecessary(a))&&$g.ParticleCanBeConnected(l,c)&&$g.ParticleCanBeConnected(h,m)&&i.ShouldCreatePair(r,a)){const t=this.m_pairBuffer.data[this.m_pairBuffer.Append()];t.indexA=r,t.indexB=a,t.flags=n.flags,t.strength=Xd(c?c.m_strength:1,m?m.m_strength:1),t.distance=ep.DistanceVV(o[r],o[a])}Ng(this.m_pairBuffer.data,0,this.m_pairBuffer.count,$g.ComparePairIndices),this.m_pairBuffer.Unique($g.MatchPairIndices)}if(a&$g.k_triadFlags){const a=new Lg(e-t);for(let s=t;s<e;s++){const t=this.m_flagsBuffer.data[s],e=this.m_groupBuffer[s];t&Bg.b2_zombieParticle||!$g.ParticleCanBeConnected(t,e)||a.AddGenerator(o[s],s,i.IsNecessary(s))}const l=this.GetParticleStride();a.Generate(l/2,2*l);const h=this,c=(t,e,a)=>{const l=h.m_flagsBuffer.data[t],c=h.m_flagsBuffer.data[e],m=h.m_flagsBuffer.data[a];if((l|c|m)&$g.k_triadFlags&&i.ShouldCreateTriad(t,e,a)){const i=o[t],u=o[e],_=o[a],d=ep.SubVV(i,u,s),p=ep.SubVV(u,_,n),f=ep.SubVV(_,i,r),y=4*h.m_squaredDiameter;if(ep.DotVV(d,d)>y||ep.DotVV(p,p)>y||ep.DotVV(f,f)>y)return;const g=h.m_groupBuffer[t],x=h.m_groupBuffer[e],v=h.m_groupBuffer[a],S=h.m_triadBuffer.data[h.m_triadBuffer.Append()];S.indexA=t,S.indexB=e,S.indexC=a,S.flags=l|c|m,S.strength=Xd(Xd(g?g.m_strength:1,x?x.m_strength:1),v?v.m_strength:1);const w=(i.x+u.x+_.x)/3,b=(i.y+u.y+_.y)/3;S.pa.x=i.x-w,S.pa.y=i.y-b,S.pb.x=u.x-w,S.pb.y=u.y-b,S.pc.x=_.x-w,S.pc.y=_.y-b,S.ka=-ep.DotVV(f,d),S.kb=-ep.DotVV(d,p),S.kc=-ep.DotVV(p,f),S.s=ep.CrossVV(i,u)+ep.CrossVV(u,_)+ep.CrossVV(_,i)}};a.GetNodes(c),Ng(this.m_triadBuffer.data,0,this.m_triadBuffer.count,$g.CompareTriadIndices),this.m_triadBuffer.Unique($g.MatchTriadIndices)}}UpdatePairsAndTriadsWithReactiveParticles(){const t=new mx(this.m_flagsBuffer);this.UpdatePairsAndTriads(0,this.m_count,t);for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&=~Bg.b2_reactiveParticle;this.m_allParticleFlags&=~Bg.b2_reactiveParticle}static ComparePairIndices(t,e){const i=t.indexA-e.indexA;return 0!==i?i<0:t.indexB<e.indexB}static MatchPairIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB}static CompareTriadIndices(t,e){const i=t.indexA-e.indexA;if(0!==i)return i<0;const s=t.indexB-e.indexB;return 0!==s?s<0:t.indexC<e.indexC}static MatchTriadIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB&&t.indexC===e.indexC}static InitializeParticleLists(t,e){const i=t.GetBufferIndex(),s=t.GetParticleCount();for(let t=0;t<s;t++){const s=e[t];s.list=s,s.next=null,s.count=1,s.index=t+i}}MergeParticleListsInContact(t,e){const i=t.GetBufferIndex();for(let s=0;s<this.m_contactBuffer.count;s++){const n=this.m_contactBuffer.data[s],r=n.indexA,o=n.indexB;if(!t.ContainsParticle(r)||!t.ContainsParticle(o))continue;let a=e[r-i].list,l=e[o-i].list;if(a!==l){if(a.count<l.count){const t=a;a=l,l=t}$g.MergeParticleLists(a,l)}}}static MergeParticleLists(t,e){for(let i=e;;){i.list=t;const e=i.next;if(!e){i.next=t.next;break}i=e}t.next=e,t.count+=e.count,e.count=0}static FindLongestParticleList(t,e){const i=t.GetParticleCount();let s=e[0];for(let t=0;t<i;t++){const i=e[t];s.count<i.count&&(s=i)}return s}MergeZombieParticleListNodes(t,e,i){const s=t.GetParticleCount();for(let t=0;t<s;t++){const s=e[t];s!==i&&this.m_flagsBuffer.data[s.index]&Bg.b2_zombieParticle&&$g.MergeParticleListAndNode(i,s)}}static MergeParticleListAndNode(t,e){e.list=t,e.next=t.next,t.next=e,t.count++,e.count=0}CreateParticleGroupsFromParticleList(t,e,i){const s=t.GetParticleCount(),n=new Ig;n.groupFlags=t.GetGroupFlags(),n.userData=t.GetUserData();for(let t=0;t<s;t++){const s=e[t];if(!s.count||s===i)continue;const r=this.CreateParticleGroup(n);for(let t=s;t;t=t.next){const e=t.index,i=this.CloneParticle(e,r);this.m_flagsBuffer.data[e]|=Bg.b2_zombieParticle,t.index=i}}}UpdatePairsAndTriadsWithParticleList(t,e){const i=t.GetBufferIndex();for(let s=0;s<this.m_pairBuffer.count;s++){const n=this.m_pairBuffer.data[s],r=n.indexA,o=n.indexB;t.ContainsParticle(r)&&(n.indexA=e[r-i].index),t.ContainsParticle(o)&&(n.indexB=e[o-i].index)}for(let s=0;s<this.m_triadBuffer.count;s++){const n=this.m_triadBuffer.data[s],r=n.indexA,o=n.indexB,a=n.indexC;t.ContainsParticle(r)&&(n.indexA=e[r-i].index),t.ContainsParticle(o)&&(n.indexB=e[o-i].index),t.ContainsParticle(a)&&(n.indexC=e[a-i].index)}}ComputeDepth(){const t=[];let e=0;for(let i=0;i<this.m_contactBuffer.count;i++){const s=this.m_contactBuffer.data[i],n=s.indexA,r=s.indexB,o=this.m_groupBuffer[n],a=this.m_groupBuffer[r];o&&o===a&&o.m_groupFlags&Mg.b2_particleGroupNeedsUpdateDepth&&(t[e++]=s)}const i=[];let s=0;for(let t=this.m_groupList;t;t=t.GetNext())if(t.m_groupFlags&Mg.b2_particleGroupNeedsUpdateDepth){i[s++]=t,this.SetGroupFlags(t,t.m_groupFlags&~Mg.b2_particleGroupNeedsUpdateDepth);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_accumulationBuffer[e]=0}for(let i=0;i<e;i++){const e=t[i],s=e.indexA,n=e.indexB,r=e.weight;this.m_accumulationBuffer[s]+=r,this.m_accumulationBuffer[n]+=r}for(let t=0;t<s;t++){const e=i[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++){const e=this.m_accumulationBuffer[t];this.m_depthBuffer[t]=e<.8?0:Id}}const n=Kd(this.m_count)>>0;for(let i=0;i<n;i++){let i=!1;for(let s=0;s<e;s++){const e=t[s],n=e.indexA,r=e.indexB,o=1-e.weight,a=this.m_depthBuffer[n],l=this.m_depthBuffer[r],h=l+o,c=a+o;a>h&&(this.m_depthBuffer[n]=h,i=!0),l>c&&(this.m_depthBuffer[r]=c,i=!0)}if(!i)break}for(let t=0;t<s;t++){const e=i[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++)this.m_depthBuffer[t]<Id?this.m_depthBuffer[t]*=this.m_particleDiameter:this.m_depthBuffer[t]=0}}GetInsideBoundsEnumerator(t){const e=$g.computeTag(this.m_inverseDiameter*t.lowerBound.x-1,this.m_inverseDiameter*t.lowerBound.y-1),i=$g.computeTag(this.m_inverseDiameter*t.upperBound.x+1,this.m_inverseDiameter*t.upperBound.y+1),s=this.m_proxyBuffer.count,n=Wg(this.m_proxyBuffer.data,0,s,e,ex.CompareProxyTag),r=jg(this.m_proxyBuffer.data,0,s,i,ex.CompareTagProxy);return new ix(this,e,i,n,r)}UpdateAllParticleFlags(){this.m_allParticleFlags=0;for(let t=0;t<this.m_count;t++)this.m_allParticleFlags|=this.m_flagsBuffer.data[t];this.m_needsUpdateAllParticleFlags=!1}UpdateAllGroupFlags(){this.m_allGroupFlags=0;for(let t=this.m_groupList;t;t=t.GetNext())this.m_allGroupFlags|=t.m_groupFlags;this.m_needsUpdateAllGroupFlags=!1}AddContact(t,e,i){const s=this.m_flagsBuffer.data,n=this.m_positionBuffer.data,r=ep.SubVV(n[e],n[t],$g.AddContact_s_d),o=ep.DotVV(r,r);if(0<o&&o<this.m_squaredDiameter){const i=Qd(o),n=this.m_contactBuffer.data[this.m_contactBuffer.Append()];n.indexA=t,n.indexB=e,n.flags=s[t]|s[e],n.weight=1-o*i*this.m_inverseDiameter,n.normal.x=i*r.x,n.normal.y=i*r.y}}FindContacts_Reference(t){const e=this.m_proxyBuffer.count;this.m_contactBuffer.count=0;for(let t=0,i=0;t<e;t++){const s=$g.computeRelativeTag(this.m_proxyBuffer.data[t].tag,1,0);for(let i=t+1;i<e&&!(s<this.m_proxyBuffer.data[i].tag);i++)this.AddContact(this.m_proxyBuffer.data[t].index,this.m_proxyBuffer.data[i].index,this.m_contactBuffer);const n=$g.computeRelativeTag(this.m_proxyBuffer.data[t].tag,-1,1);for(;i<e&&!(n<=this.m_proxyBuffer.data[i].tag);i++);const r=$g.computeRelativeTag(this.m_proxyBuffer.data[t].tag,1,1);for(let s=i;s<e&&!(r<this.m_proxyBuffer.data[s].tag);s++)this.AddContact(this.m_proxyBuffer.data[t].index,this.m_proxyBuffer.data[s].index,this.m_contactBuffer)}}FindContacts(t){this.FindContacts_Reference(t)}UpdateProxies_Reference(t){const e=this.m_positionBuffer.data,i=this.m_inverseDiameter;for(let t=0;t<this.m_proxyBuffer.count;++t){const s=this.m_proxyBuffer.data[t],n=e[s.index];s.tag=$g.computeTag(i*n.x,i*n.y)}}UpdateProxies(t){this.UpdateProxies_Reference(t)}SortProxies(t){Og(this.m_proxyBuffer.data,0,this.m_proxyBuffer.count,ex.CompareProxyProxy)}FilterContacts(t){const e=this.GetParticleContactFilter();if(null===e)return;const i=this;this.m_contactBuffer.RemoveIf((t=>0!=(t.flags&Bg.b2_particleContactFilterParticle)&&!e.ShouldCollideParticleParticle(i,t.indexA,t.indexB)))}NotifyContactListenerPreContact(t){if(null!==this.GetParticleContactListener())throw t.Initialize(this.m_contactBuffer,this.m_flagsBuffer),new Error}NotifyContactListenerPostContact(t){const e=this.GetParticleContactListener();if(null!==e){for(let i=0;i<this.m_contactBuffer.count;++i){const s=this.m_contactBuffer.data[i],n=-1;n>=0?t.Invalidate(n):e.BeginContactParticleParticle(this,s)}throw new Error}}static b2ParticleContactIsZombie(t){return(t.flags&Bg.b2_zombieParticle)===Bg.b2_zombieParticle}UpdateContacts(t){this.UpdateProxies(this.m_proxyBuffer),this.SortProxies(this.m_proxyBuffer);const e=new ox;this.NotifyContactListenerPreContact(e),this.FindContacts(this.m_contactBuffer),this.FilterContacts(this.m_contactBuffer),this.NotifyContactListenerPostContact(e),t&&this.m_contactBuffer.RemoveIf($g.b2ParticleContactIsZombie)}NotifyBodyContactListenerPreContact(t){if(null!==this.GetFixtureContactListener())throw t.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer),new Error}NotifyBodyContactListenerPostContact(t){const e=this.GetFixtureContactListener();if(null!==e){for(let i=0;i<this.m_bodyContactBuffer.count;i++){const s=this.m_bodyContactBuffer.data[i],n=-1;n>=0?t.Invalidate(n):e.BeginContactFixtureParticle(this,s)}throw new Error}}UpdateBodyContacts(){const t=$g.UpdateBodyContacts_s_aabb,e=new rx;if(this.NotifyBodyContactListenerPreContact(e),this.m_stuckThreshold>0){const t=this.GetParticleCount();for(let e=0;e<t;e++)this.m_bodyContactCountBuffer.data[e]=0,this.m_timestamp>this.m_lastBodyContactStepBuffer.data[e]+1&&(this.m_consecutiveContactStepsBuffer.data[e]=0)}this.m_bodyContactBuffer.SetCount(0),this.m_stuckParticleBuffer.SetCount(0);const i=t;this.ComputeAABB(i),null===this.UpdateBodyContacts_callback&&(this.UpdateBodyContacts_callback=new ux(this));const s=this.UpdateBodyContacts_callback;s.m_contactFilter=this.GetFixtureContactFilter(),this.m_world.QueryAABB(s,i),this.m_def.strictContactCheck&&this.RemoveSpuriousBodyContacts(),this.NotifyBodyContactListenerPostContact(e)}Solve(t){const e=$g.Solve_s_subStep;if(0!==this.m_count&&(this.m_expirationTimeBuffer.data&&this.SolveLifetimes(t),this.m_allParticleFlags&Bg.b2_zombieParticle&&this.SolveZombie(),this.m_needsUpdateAllParticleFlags&&this.UpdateAllParticleFlags(),this.m_needsUpdateAllGroupFlags&&this.UpdateAllGroupFlags(),!this.m_paused))for(this.m_iterationIndex=0;this.m_iterationIndex<t.particleIterations;this.m_iterationIndex++){++this.m_timestamp;const i=e.Copy(t);i.dt/=t.particleIterations,i.inv_dt*=t.particleIterations,this.UpdateContacts(!1),this.UpdateBodyContacts(),this.ComputeWeight(),this.m_allGroupFlags&Mg.b2_particleGroupNeedsUpdateDepth&&this.ComputeDepth(),this.m_allParticleFlags&Bg.b2_reactiveParticle&&this.UpdatePairsAndTriadsWithReactiveParticles(),this.m_hasForce&&this.SolveForce(i),this.m_allParticleFlags&Bg.b2_viscousParticle&&this.SolveViscous(),this.m_allParticleFlags&Bg.b2_repulsiveParticle&&this.SolveRepulsive(i),this.m_allParticleFlags&Bg.b2_powderParticle&&this.SolvePowder(i),this.m_allParticleFlags&Bg.b2_tensileParticle&&this.SolveTensile(i),this.m_allGroupFlags&Mg.b2_solidParticleGroup&&this.SolveSolid(i),this.m_allParticleFlags&Bg.b2_colorMixingParticle&&this.SolveColorMixing(),this.SolveGravity(i),this.m_allParticleFlags&Bg.b2_staticPressureParticle&&this.SolveStaticPressure(i),this.SolvePressure(i),this.SolveDamping(i),this.m_allParticleFlags&$g.k_extraDampingFlags&&this.SolveExtraDamping(),this.m_allParticleFlags&Bg.b2_elasticParticle&&this.SolveElastic(i),this.m_allParticleFlags&Bg.b2_springParticle&&this.SolveSpring(i),this.LimitVelocity(i),this.m_allGroupFlags&Mg.b2_rigidParticleGroup&&this.SolveRigidDamping(),this.m_allParticleFlags&Bg.b2_barrierParticle&&this.SolveBarrier(i),this.SolveCollision(i),this.m_allGroupFlags&Mg.b2_rigidParticleGroup&&this.SolveRigid(i),this.m_allParticleFlags&Bg.b2_wallParticle&&this.SolveWall();for(let t=0;t<this.m_count;t++)this.m_positionBuffer.data[t].SelfMulAdd(i.dt,this.m_velocityBuffer.data[t])}}SolveCollision(t){const e=$g.SolveCollision_s_aabb,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=e;n.lowerBound.x=+Id,n.lowerBound.y=+Id,n.upperBound.x=-Id,n.upperBound.y=-Id;for(let e=0;e<this.m_count;e++){const r=s[e],o=i[e],a=o.x+t.dt*r.x,l=o.y+t.dt*r.y;n.lowerBound.x=Xd(n.lowerBound.x,Xd(o.x,a)),n.lowerBound.y=Xd(n.lowerBound.y,Xd(o.y,l)),n.upperBound.x=Jd(n.upperBound.x,Jd(o.x,a)),n.upperBound.y=Jd(n.upperBound.y,Jd(o.y,l))}null===this.SolveCollision_callback&&(this.SolveCollision_callback=new _x(this,t));const r=this.SolveCollision_callback;r.m_step=t,this.m_world.QueryAABB(r,n)}LimitVelocity(t){const e=this.m_velocityBuffer.data,i=this.GetCriticalVelocitySquared(t);for(let t=0;t<this.m_count;t++){const s=e[t],n=ep.DotVV(s,s);n>i&&s.SelfMul(Kd(i/n))}}SolveGravity(t){const e=$g.SolveGravity_s_gravity,i=this.m_velocityBuffer.data,s=ep.MulSV(t.dt*this.m_def.gravityScale,this.m_world.GetGravity(),e);for(let t=0;t<this.m_count;t++)i[t].SelfAdd(s)}SolveBarrier(t){const e=$g.SolveBarrier_s_aabb,i=$g.SolveBarrier_s_va,s=$g.SolveBarrier_s_vb,n=$g.SolveBarrier_s_pba,r=$g.SolveBarrier_s_vba,o=$g.SolveBarrier_s_vc,a=$g.SolveBarrier_s_pca,l=$g.SolveBarrier_s_vca,h=$g.SolveBarrier_s_qba,c=$g.SolveBarrier_s_qca,m=$g.SolveBarrier_s_dv,u=$g.SolveBarrier_s_f,_=this.m_positionBuffer.data,d=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++)0!=(this.m_flagsBuffer.data[t]&$g.k_barrierWallFlags)&&d[t].SetZero();const p=2.5*t.dt,f=this.GetParticleMass();for(let y=0;y<this.m_pairBuffer.count;y++){const g=this.m_pairBuffer.data[y];if(g.flags&Bg.b2_barrierParticle){const y=g.indexA,x=g.indexB,v=_[y],S=_[x],w=e;ep.MinV(v,S,w.lowerBound),ep.MaxV(v,S,w.upperBound);const b=this.m_groupBuffer[y],C=this.m_groupBuffer[x],A=this.GetLinearVelocity(b,y,v,i),B=this.GetLinearVelocity(C,x,S,s),M=ep.SubVV(S,v,n),V=ep.SubVV(B,A,r),T=this.GetInsideBoundsEnumerator(w);let P;for(;(P=T.GetNext())>=0;){const e=_[P],i=this.m_groupBuffer[P];if(b!==i&&C!==i){const s=this.GetLinearVelocity(i,P,e,o),n=ep.SubVV(e,v,a),r=ep.SubVV(s,A,l),_=ep.CrossVV(V,r),y=ep.CrossVV(M,r)-ep.CrossVV(n,V),g=ep.CrossVV(M,n);let x,S;const w=h,b=c;if(0===_){if(0===y)continue;if(S=-g/y,!(S>=0&&S<p))continue;if(ep.AddVMulSV(M,S,V,w),ep.AddVMulSV(n,S,r,b),x=ep.DotVV(w,b)/ep.DotVV(w,w),!(x>=0&&x<=1))continue}else{const t=y*y-4*g*_;if(t<0)continue;const e=Kd(t);let i=(-y-e)/(2*_),s=(-y+e)/(2*_);if(i>s){const t=i;i=s,s=t}if(S=i,ep.AddVMulSV(M,S,V,w),ep.AddVMulSV(n,S,r,b),x=ep.DotVV(w,b)/ep.DotVV(w,w),!(S>=0&&S<p&&x>=0&&x<=1)){if(S=s,!(S>=0&&S<p))continue;if(ep.AddVMulSV(M,S,V,w),ep.AddVMulSV(n,S,r,b),x=ep.DotVV(w,b)/ep.DotVV(w,w),!(x>=0&&x<=1))continue}}const C=m;C.x=A.x+x*V.x-s.x,C.y=A.y+x*V.y-s.y;const B=ep.MulSV(f,C,u);if(i&&this.IsRigidGroup(i)){const t=i.GetMass(),s=i.GetInertia();t>0&&i.m_linearVelocity.SelfMulAdd(1/t,B),s>0&&(i.m_angularVelocity+=ep.CrossVV(ep.SubVV(e,i.GetCenter(),ep.s_t0),B)/s)}else d[P].SelfAdd(C);this.ParticleApplyForce(P,B.SelfMul(-t.inv_dt))}}}}}SolveStaticPressure(t){this.m_staticPressureBuffer=this.RequestBuffer(this.m_staticPressureBuffer);const e=this.GetCriticalPressure(t),i=this.m_def.staticPressureStrength*e,s=.25*e,n=this.m_def.staticPressureRelaxation;for(let t=0;t<this.m_def.staticPressureIterations;t++){for(let t=0;t<this.m_count;t++)this.m_accumulationBuffer[t]=0;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&Bg.b2_staticPressureParticle){const t=e.indexA,i=e.indexB,s=e.weight;this.m_accumulationBuffer[t]+=s*this.m_staticPressureBuffer[i],this.m_accumulationBuffer[i]+=s*this.m_staticPressureBuffer[t]}}for(let t=0;t<this.m_count;t++){const e=this.m_weightBuffer[t];if(this.m_flagsBuffer.data[t]&Bg.b2_staticPressureParticle){const r=(this.m_accumulationBuffer[t]+i*(e-1))/(e+n);this.m_staticPressureBuffer[t]=Zd(r,0,s)}else this.m_staticPressureBuffer[t]=0}}}ComputeWeight(){for(let t=0;t<this.m_count;t++)this.m_weightBuffer[t]=0;for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t],i=e.index,s=e.weight;this.m_weightBuffer[i]+=s}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t],i=e.indexA,s=e.indexB,n=e.weight;this.m_weightBuffer[i]+=n,this.m_weightBuffer[s]+=n}}SolvePressure(t){const e=$g.SolvePressure_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.GetCriticalPressure(t),r=this.m_def.pressureStrength*n,o=.25*n;for(let t=0;t<this.m_count;t++){const e=r*Jd(0,this.m_weightBuffer[t]-1);this.m_accumulationBuffer[t]=Xd(e,o)}if(this.m_allParticleFlags&$g.k_noPressureFlags)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&$g.k_noPressureFlags&&(this.m_accumulationBuffer[t]=0);if(this.m_allParticleFlags&Bg.b2_staticPressureParticle)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&Bg.b2_staticPressureParticle&&(this.m_accumulationBuffer[t]+=this.m_staticPressureBuffer[t]);const a=t.dt/(this.m_def.density*this.m_particleDiameter),l=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const n=this.m_bodyContactBuffer.data[t],o=n.index,h=n.body,c=n.weight,m=n.mass,u=n.normal,_=i[o],d=this.m_accumulationBuffer[o]+r*c,p=ep.MulSV(a*c*m*d,u,e);s[o].SelfMulSub(l,p),h.ApplyLinearImpulse(p,_,!0)}for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t],n=i.indexA,r=i.indexB,o=i.weight,l=i.normal,h=this.m_accumulationBuffer[n]+this.m_accumulationBuffer[r],c=ep.MulSV(a*o*h,l,e);s[n].SelfSub(c),s[r].SelfAdd(c)}}SolveDamping(t){const e=$g.SolveDamping_s_v,i=$g.SolveDamping_s_f,s=this.m_positionBuffer.data,n=this.m_velocityBuffer.data,r=this.m_def.dampingStrength,o=1/this.GetCriticalVelocity(t),a=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const l=this.m_bodyContactBuffer.data[t],h=l.index,c=l.body,m=l.weight,u=l.mass,_=l.normal,d=s[h],p=ep.SubVV(c.GetLinearVelocityFromWorldPoint(d,ep.s_t0),n[h],e),f=ep.DotVV(p,_);if(f<0){const t=Jd(r*m,Xd(-o*f,.5)),e=ep.MulSV(t*u*f,_,i);n[h].SelfMulAdd(a,e),c.ApplyLinearImpulse(e.SelfNeg(),d,!0)}}for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t],a=s.indexA,l=s.indexB,h=s.weight,c=s.normal,m=ep.SubVV(n[l],n[a],e),u=ep.DotVV(m,c);if(u<0){const t=Jd(r*h,Xd(-o*u,.5)),e=ep.MulSV(t*u,c,i);n[a].SelfAdd(e),n[l].SelfSub(e)}}}SolveRigidDamping(){const t=$g.SolveRigidDamping_s_t0,e=$g.SolveRigidDamping_s_t1,i=$g.SolveRigidDamping_s_p,s=$g.SolveRigidDamping_s_v,n=[0],r=[0],o=[0],a=[0],l=[0],h=[0],c=this.m_positionBuffer.data,m=this.m_def.dampingStrength;for(let i=0;i<this.m_bodyContactBuffer.count;i++){const u=this.m_bodyContactBuffer.data[i],_=u.index,d=this.m_groupBuffer[_];if(d&&this.IsRigidGroup(d)){const i=u.body,p=u.normal,f=u.weight,y=c[_],g=ep.SubVV(i.GetLinearVelocityFromWorldPoint(y,t),d.GetLinearVelocityFromWorldPoint(y,e),s),x=ep.DotVV(g,p);if(x<0){this.InitDampingParameterWithRigidGroupOrParticle(n,r,o,!0,d,_,y,p),this.InitDampingParameter(a,l,h,i.GetMass(),i.GetInertia()-i.GetMass()*i.GetLocalCenter().LengthSquared(),i.GetWorldCenter(),y,p);const t=m*Xd(f,1)*this.ComputeDampingImpulse(n[0],r[0],o[0],a[0],l[0],h[0],x);this.ApplyDamping(n[0],r[0],o[0],!0,d,_,t,p),i.ApplyLinearImpulse(ep.MulSV(-t,p,ep.s_t0),y,!0)}}}for(let u=0;u<this.m_contactBuffer.count;u++){const _=this.m_contactBuffer.data[u],d=_.indexA,p=_.indexB,f=_.normal,y=_.weight,g=this.m_groupBuffer[d],x=this.m_groupBuffer[p],v=this.IsRigidGroup(g),S=this.IsRigidGroup(x);if(g!==x&&(v||S)){const u=ep.MidVV(c[d],c[p],i),_=ep.SubVV(this.GetLinearVelocity(x,p,u,t),this.GetLinearVelocity(g,d,u,e),s),w=ep.DotVV(_,f);if(w<0){this.InitDampingParameterWithRigidGroupOrParticle(n,r,o,v,g,d,u,f),this.InitDampingParameterWithRigidGroupOrParticle(a,l,h,S,x,p,u,f);const t=m*y*this.ComputeDampingImpulse(n[0],r[0],o[0],a[0],l[0],h[0],w);this.ApplyDamping(n[0],r[0],o[0],v,g,d,t,f),this.ApplyDamping(a[0],l[0],h[0],S,x,p,-t,f)}}}}SolveExtraDamping(){const t=$g.SolveExtraDamping_s_v,e=$g.SolveExtraDamping_s_f,i=this.m_velocityBuffer.data,s=this.m_positionBuffer.data,n=this.GetParticleInvMass();for(let r=0;r<this.m_bodyContactBuffer.count;r++){const o=this.m_bodyContactBuffer.data[r],a=o.index;if(this.m_flagsBuffer.data[a]&$g.k_extraDampingFlags){const r=o.body,l=o.mass,h=o.normal,c=s[a],m=ep.SubVV(r.GetLinearVelocityFromWorldPoint(c,ep.s_t0),i[a],t),u=ep.DotVV(m,h);if(u<0){const t=ep.MulSV(.5*l*u,h,e);i[a].SelfMulAdd(n,t),r.ApplyLinearImpulse(t.SelfNeg(),c,!0)}}}}SolveWall(){const t=this.m_velocityBuffer.data;for(let e=0;e<this.m_count;e++)this.m_flagsBuffer.data[e]&Bg.b2_wallParticle&&t[e].SetZero()}SolveRigid(t){const e=$g.SolveRigid_s_position,i=$g.SolveRigid_s_rotation,s=$g.SolveRigid_s_transform,n=$g.SolveRigid_s_velocityTransform,r=this.m_positionBuffer.data,o=this.m_velocityBuffer.data;for(let a=this.m_groupList;a;a=a.GetNext())if(a.m_groupFlags&Mg.b2_rigidParticleGroup){a.UpdateStatistics();const l=i;l.SetAngle(t.dt*a.m_angularVelocity);const h=ep.AddVV(a.m_center,ep.SubVV(ep.MulSV(t.dt,a.m_linearVelocity,ep.s_t0),op.MulRV(l,a.m_center,ep.s_t1),ep.s_t0),e),c=s;c.SetPositionRotation(h,l),ap.MulXX(c,a.m_transform,a.m_transform);const m=n;m.p.x=t.inv_dt*c.p.x,m.p.y=t.inv_dt*c.p.y,m.q.s=t.inv_dt*c.q.s,m.q.c=t.inv_dt*(c.q.c-1);for(let t=a.m_firstIndex;t<a.m_lastIndex;t++)ap.MulXV(m,r[t],o[t])}}SolveElastic(t){const e=$g.SolveElastic_s_pa,i=$g.SolveElastic_s_pb,s=$g.SolveElastic_s_pc,n=$g.SolveElastic_s_r,r=$g.SolveElastic_s_t0,o=this.m_positionBuffer.data,a=this.m_velocityBuffer.data,l=t.inv_dt*this.m_def.elasticStrength;for(let h=0;h<this.m_triadBuffer.count;h++){const c=this.m_triadBuffer.data[h];if(c.flags&Bg.b2_elasticParticle){const h=c.indexA,m=c.indexB,u=c.indexC,_=c.pa,d=c.pb,p=c.pc,f=e.Copy(o[h]),y=i.Copy(o[m]),g=s.Copy(o[u]),x=a[h],v=a[m],S=a[u];f.SelfMulAdd(t.dt,x),y.SelfMulAdd(t.dt,v),g.SelfMulAdd(t.dt,S);const w=(f.x+y.x+g.x)/3,b=(f.y+y.y+g.y)/3;f.x-=w,f.y-=b,y.x-=w,y.y-=b,g.x-=w,g.y-=b;const C=n;C.s=ep.CrossVV(_,f)+ep.CrossVV(d,y)+ep.CrossVV(p,g),C.c=ep.DotVV(_,f)+ep.DotVV(d,y)+ep.DotVV(p,g);let A=Qd(C.s*C.s+C.c*C.c);isFinite(A)||(A=198177537e11),C.s*=A,C.c*=A;const B=l*c.strength;op.MulRV(C,_,r),ep.SubVV(r,f,r),ep.MulSV(B,r,r),x.SelfAdd(r),op.MulRV(C,d,r),ep.SubVV(r,y,r),ep.MulSV(B,r,r),v.SelfAdd(r),op.MulRV(C,p,r),ep.SubVV(r,g,r),ep.MulSV(B,r,r),S.SelfAdd(r)}}}SolveSpring(t){const e=$g.SolveSpring_s_pa,i=$g.SolveSpring_s_pb,s=$g.SolveSpring_s_d,n=$g.SolveSpring_s_f,r=this.m_positionBuffer.data,o=this.m_velocityBuffer.data,a=t.inv_dt*this.m_def.springStrength;for(let l=0;l<this.m_pairBuffer.count;l++){const h=this.m_pairBuffer.data[l];if(h.flags&Bg.b2_springParticle){const l=h.indexA,c=h.indexB,m=e.Copy(r[l]),u=i.Copy(r[c]),_=o[l],d=o[c];m.SelfMulAdd(t.dt,_),u.SelfMulAdd(t.dt,d);const p=ep.SubVV(u,m,s),f=h.distance,y=p.Length(),g=a*h.strength,x=ep.MulSV(g*(f-y)/y,p,n);_.SelfSub(x),d.SelfAdd(x)}}}SolveTensile(t){const e=$g.SolveTensile_s_weightedNormal,i=$g.SolveTensile_s_s,s=$g.SolveTensile_s_f,n=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++)this.m_accumulation2Buffer[t]=new ep,this.m_accumulation2Buffer[t].SetZero();for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];if(i.flags&Bg.b2_tensileParticle){const t=i.indexA,s=i.indexB,n=i.weight,r=i.normal,o=ep.MulSV((1-n)*n,r,e);this.m_accumulation2Buffer[t].SelfSub(o),this.m_accumulation2Buffer[s].SelfAdd(o)}}const r=this.GetCriticalVelocity(t),o=this.m_def.surfaceTensionPressureStrength*r,a=this.m_def.surfaceTensionNormalStrength*r,l=.5*r;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&Bg.b2_tensileParticle){const t=e.indexA,r=e.indexB,h=e.weight,c=e.normal,m=this.m_weightBuffer[t]+this.m_weightBuffer[r],u=ep.SubVV(this.m_accumulation2Buffer[r],this.m_accumulation2Buffer[t],i),_=Xd(o*(m-2)+a*ep.DotVV(u,c),l)*h,d=ep.MulSV(_,c,s);n[t].SelfSub(d),n[r].SelfAdd(d)}}}SolveViscous(){const t=$g.SolveViscous_s_v,e=$g.SolveViscous_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.m_def.viscousStrength,r=this.GetParticleInvMass();for(let o=0;o<this.m_bodyContactBuffer.count;o++){const a=this.m_bodyContactBuffer.data[o],l=a.index;if(this.m_flagsBuffer.data[l]&Bg.b2_viscousParticle){const o=a.body,h=a.weight,c=a.mass,m=i[l],u=ep.SubVV(o.GetLinearVelocityFromWorldPoint(m,ep.s_t0),s[l],t),_=ep.MulSV(n*c*h,u,e);s[l].SelfMulAdd(r,_),o.ApplyLinearImpulse(_.SelfNeg(),m,!0)}}for(let i=0;i<this.m_contactBuffer.count;i++){const r=this.m_contactBuffer.data[i];if(r.flags&Bg.b2_viscousParticle){const i=r.indexA,o=r.indexB,a=r.weight,l=ep.SubVV(s[o],s[i],t),h=ep.MulSV(n*a,l,e);s[i].SelfAdd(h),s[o].SelfSub(h)}}}SolveRepulsive(t){const e=$g.SolveRepulsive_s_f,i=this.m_velocityBuffer.data,s=this.m_def.repulsiveStrength*this.GetCriticalVelocity(t);for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t];if(n.flags&Bg.b2_repulsiveParticle){const t=n.indexA,r=n.indexB;if(this.m_groupBuffer[t]!==this.m_groupBuffer[r]){const o=n.weight,a=n.normal,l=ep.MulSV(s*o,a,e);i[t].SelfSub(l),i[r].SelfAdd(l)}}}}SolvePowder(t){const e=$g.SolvePowder_s_f,i=this.m_positionBuffer.data,s=this.m_velocityBuffer.data,n=this.m_def.powderStrength*this.GetCriticalVelocity(t),r=.25,o=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const a=this.m_bodyContactBuffer.data[t],l=a.index;if(this.m_flagsBuffer.data[l]&Bg.b2_powderParticle){const t=a.weight;if(t>r){const h=a.body,c=a.mass,m=i[l],u=a.normal,_=ep.MulSV(n*c*(t-r),u,e);s[l].SelfMulSub(o,_),h.ApplyLinearImpulse(_,m,!0)}}}for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];if(i.flags&Bg.b2_powderParticle){const t=i.weight;if(t>r){const o=i.indexA,a=i.indexB,l=i.normal,h=ep.MulSV(n*(t-r),l,e);s[o].SelfSub(h),s[a].SelfAdd(h)}}}}SolveSolid(t){const e=$g.SolveSolid_s_f,i=this.m_velocityBuffer.data;this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer);const s=t.inv_dt*this.m_def.ejectionStrength;for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t],r=n.indexA,o=n.indexB;if(this.m_groupBuffer[r]!==this.m_groupBuffer[o]){const t=n.weight,a=n.normal,l=this.m_depthBuffer[r]+this.m_depthBuffer[o],h=ep.MulSV(s*l*t,a,e);i[r].SelfSub(h),i[o].SelfAdd(h)}}}SolveForce(t){const e=this.m_velocityBuffer.data,i=t.dt*this.GetParticleInvMass();for(let t=0;t<this.m_count;t++)e[t].SelfMulAdd(i,this.m_forceBuffer[t]);this.m_hasForce=!1}SolveColorMixing(){const t=.5*this.m_def.colorMixingStrength;if(t)for(let e=0;e<this.m_contactBuffer.count;e++){const i=this.m_contactBuffer.data[e],s=i.indexA,n=i.indexB;if(this.m_flagsBuffer.data[s]&this.m_flagsBuffer.data[n]&Bg.b2_colorMixingParticle){const e=this.m_colorBuffer.data[s],i=this.m_colorBuffer.data[n];hp.MixColors(e,i,t)}}}SolveZombie(){let t=0;const e=[];for(let t=0;t<this.m_count;t++)e[t]=Ud;let i=0;for(let s=0;s<this.m_count;s++){const n=this.m_flagsBuffer.data[s];if(n&Bg.b2_zombieParticle){const t=this.m_world.m_destructionListener;if(n&Bg.b2_destructionListenerParticle&&t&&t.SayGoodbyeParticle(this,s),this.m_handleIndexBuffer.data){const t=this.m_handleIndexBuffer.data[s];t&&(t.SetIndex(Ud),this.m_handleIndexBuffer.data[s]=null)}e[s]=Ud}else{if(e[s]=t,s!==t){if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[s];e&&e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e}this.m_flagsBuffer.data[t]=this.m_flagsBuffer.data[s],this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[t]=this.m_lastBodyContactStepBuffer.data[s]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[t]=this.m_bodyContactCountBuffer.data[s]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[t]=this.m_consecutiveContactStepsBuffer.data[s]),this.m_positionBuffer.data[t].Copy(this.m_positionBuffer.data[s]),this.m_velocityBuffer.data[t].Copy(this.m_velocityBuffer.data[s]),this.m_groupBuffer[t]=this.m_groupBuffer[s],this.m_hasForce&&this.m_forceBuffer[t].Copy(this.m_forceBuffer[s]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[t]=this.m_staticPressureBuffer[s]),this.m_depthBuffer&&(this.m_depthBuffer[t]=this.m_depthBuffer[s]),this.m_colorBuffer.data&&this.m_colorBuffer.data[t].Copy(this.m_colorBuffer.data[s]),this.m_userDataBuffer.data&&(this.m_userDataBuffer.data[t]=this.m_userDataBuffer.data[s]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[t]=this.m_expirationTimeBuffer.data[s])}t++,i|=n}}for(let t=0;t<this.m_proxyBuffer.count;t++){const i=this.m_proxyBuffer.data[t];i.index=e[i.index]}this.m_proxyBuffer.RemoveIf((t=>t.index<0));for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB]}this.m_contactBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0));for(let t=0;t<this.m_bodyContactBuffer.count;t++){const i=this.m_bodyContactBuffer.data[t];i.index=e[i.index]}this.m_bodyContactBuffer.RemoveIf((t=>t.index<0));for(let t=0;t<this.m_pairBuffer.count;t++){const i=this.m_pairBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB]}this.m_pairBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0));for(let t=0;t<this.m_triadBuffer.count;t++){const i=this.m_triadBuffer.data[t];i.indexA=e[i.indexA],i.indexB=e[i.indexB],i.indexC=e[i.indexC]}if(this.m_triadBuffer.RemoveIf((t=>t.indexA<0||t.indexB<0||t.indexC<0)),this.m_indexByExpirationTimeBuffer.data){let t=0;for(let i=0;i<this.m_count;i++){const s=e[this.m_indexByExpirationTimeBuffer.data[i]];s!==Ud&&(this.m_indexByExpirationTimeBuffer.data[t++]=s)}}for(let i=this.m_groupList;i;i=i.GetNext()){let s=t,n=0,r=!1;for(let t=i.m_firstIndex;t<i.m_lastIndex;t++){const i=e[t];i>=0?(s=Xd(s,i),n=Jd(n,i+1)):r=!0}s<n?(i.m_firstIndex=s,i.m_lastIndex=n,r&&i.m_groupFlags&Mg.b2_solidParticleGroup&&this.SetGroupFlags(i,i.m_groupFlags|Mg.b2_particleGroupNeedsUpdateDepth)):(i.m_firstIndex=0,i.m_lastIndex=0,i.m_groupFlags&Mg.b2_particleGroupCanBeEmpty||this.SetGroupFlags(i,i.m_groupFlags|Mg.b2_particleGroupWillBeDestroyed))}this.m_count=t,this.m_allParticleFlags=i,this.m_needsUpdateAllParticleFlags=!1;for(let t=this.m_groupList;t;){const e=t.GetNext();t.m_groupFlags&Mg.b2_particleGroupWillBeDestroyed&&this.DestroyParticleGroup(t),t=e}}SolveLifetimes(t){this.m_timeElapsed=this.LifetimeToExpirationTime(t.dt);const e=this.GetQuantizedTimeElapsed(),i=this.m_expirationTimeBuffer.data,s=this.m_indexByExpirationTimeBuffer.data,n=this.GetParticleCount();this.m_expirationTimeBufferRequiresSorting&&(Og(s,0,n,((t,e)=>{const s=i[t],n=i[e],r=s<=0;return r===n<=0?s>n:r})),this.m_expirationTimeBufferRequiresSorting=!1);for(let t=n-1;t>=0;--t){const n=s[t],r=i[n];if(e<r||r<=0)break;this.DestroyParticle(n)}}RotateBuffer(t,e,i){if(t!==e&&e!==i){if(Hg(this.m_flagsBuffer.data,t,e,i),this.m_lastBodyContactStepBuffer.data&&Hg(this.m_lastBodyContactStepBuffer.data,t,e,i),this.m_bodyContactCountBuffer.data&&Hg(this.m_bodyContactCountBuffer.data,t,e,i),this.m_consecutiveContactStepsBuffer.data&&Hg(this.m_consecutiveContactStepsBuffer.data,t,e,i),Hg(this.m_positionBuffer.data,t,e,i),Hg(this.m_velocityBuffer.data,t,e,i),Hg(this.m_groupBuffer,t,e,i),this.m_hasForce&&Hg(this.m_forceBuffer,t,e,i),this.m_staticPressureBuffer&&Hg(this.m_staticPressureBuffer,t,e,i),this.m_depthBuffer&&Hg(this.m_depthBuffer,t,e,i),this.m_colorBuffer.data&&Hg(this.m_colorBuffer.data,t,e,i),this.m_userDataBuffer.data&&Hg(this.m_userDataBuffer.data,t,e,i),this.m_handleIndexBuffer.data){Hg(this.m_handleIndexBuffer.data,t,e,i);for(let e=t;e<i;++e){const t=this.m_handleIndexBuffer.data[e];t&&t.SetIndex(s(t.GetIndex()))}}if(this.m_expirationTimeBuffer.data){Hg(this.m_expirationTimeBuffer.data,t,e,i);const n=this.GetParticleCount(),r=this.m_indexByExpirationTimeBuffer.data;for(let t=0;t<n;++t)r[t]=s(r[t])}for(let t=0;t<this.m_proxyBuffer.count;t++){const e=this.m_proxyBuffer.data[t];e.index=s(e.index)}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB)}for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t];e.index=s(e.index)}for(let t=0;t<this.m_pairBuffer.count;t++){const e=this.m_pairBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB)}for(let t=0;t<this.m_triadBuffer.count;t++){const e=this.m_triadBuffer.data[t];e.indexA=s(e.indexA),e.indexB=s(e.indexB),e.indexC=s(e.indexC)}for(let t=this.m_groupList;t;t=t.GetNext())t.m_firstIndex=s(t.m_firstIndex),t.m_lastIndex=s(t.m_lastIndex-1)+1}function s(s){return s<t?s:s<e?s+i-e:s<i?s+t-e:s}}GetCriticalVelocity(t){return this.m_particleDiameter*t.inv_dt}GetCriticalVelocitySquared(t){const e=this.GetCriticalVelocity(t);return e*e}GetCriticalPressure(t){return this.m_def.density*this.GetCriticalVelocitySquared(t)}GetParticleStride(){return.75*this.m_particleDiameter}GetParticleMass(){const t=this.GetParticleStride();return this.m_def.density*t*t}GetParticleInvMass(){const t=1.3333333333333333*this.m_inverseDiameter;return this.m_inverseDensity*t*t}GetFixtureContactFilter(){return this.m_allParticleFlags&Bg.b2_fixtureContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetParticleContactFilter(){return this.m_allParticleFlags&Bg.b2_particleContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetFixtureContactListener(){return this.m_allParticleFlags&Bg.b2_fixtureContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}GetParticleContactListener(){return this.m_allParticleFlags&Bg.b2_particleContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}SetUserOverridableBuffer(t,e){t.data=e,t.userSuppliedCapacity=e.length}SetGroupFlags(t,e){const i=t.m_groupFlags;(i^e)&Mg.b2_solidParticleGroup&&(e|=Mg.b2_particleGroupNeedsUpdateDepth),i&~e&&(this.m_needsUpdateAllGroupFlags=!0),~this.m_allGroupFlags&e&&(e&Mg.b2_solidParticleGroup&&(this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer)),this.m_allGroupFlags|=e),t.m_groupFlags=e}static BodyContactCompare(t,e){return t.index===e.index?t.weight>e.weight:t.index<e.index}RemoveSpuriousBodyContacts(){Og(this.m_bodyContactBuffer.data,0,this.m_bodyContactBuffer.count,$g.BodyContactCompare);const t=$g.RemoveSpuriousBodyContacts_s_n,e=$g.RemoveSpuriousBodyContacts_s_pos,i=$g.RemoveSpuriousBodyContacts_s_normal,s=this;let n=-1,r=0;this.m_bodyContactBuffer.count=Ug(this.m_bodyContactBuffer.data,(o=>{if(o.index!==n&&(r=0,n=o.index),r++>3)return!0;const a=t.Copy(o.normal);a.SelfMul(s.m_particleDiameter*(1-o.weight));const l=ep.AddVV(s.m_positionBuffer.data[o.index],a,e);if(!o.fixture.TestPoint(l)){const t=o.fixture.GetShape().GetChildCount();for(let e=0;e<t;e++){const t=i;if(o.fixture.ComputeDistance(l,t,e)<Gd)return!1}return!0}return!1}),this.m_bodyContactBuffer.count)}DetectStuckParticle(t){this.m_stuckThreshold<=0||(++this.m_bodyContactCountBuffer.data[t],2===this.m_bodyContactCountBuffer.data[t]&&(++this.m_consecutiveContactStepsBuffer.data[t],this.m_consecutiveContactStepsBuffer.data[t]>this.m_stuckThreshold&&(this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()]=t)),this.m_lastBodyContactStepBuffer.data[t]=this.m_timestamp)}ValidateParticleIndex(t){return t>=0&&t<this.GetParticleCount()&&t!==Ud}GetQuantizedTimeElapsed(){return Math.floor(this.m_timeElapsed/4294967296)}LifetimeToExpirationTime(t){return this.m_timeElapsed+Math.floor(t/this.m_def.lifetimeGranularity*4294967296)}ForceCanBeApplied(t){return!(t&Bg.b2_wallParticle)}PrepareForceBuffer(){if(!this.m_hasForce){for(let t=0;t<this.m_count;t++)this.m_forceBuffer[t].SetZero();this.m_hasForce=!0}}IsRigidGroup(t){return null!==t&&0!=(t.m_groupFlags&Mg.b2_rigidParticleGroup)}GetLinearVelocity(t,e,i,s){return t&&this.IsRigidGroup(t)?t.GetLinearVelocityFromWorldPoint(i,s):s.Copy(this.m_velocityBuffer.data[e])}InitDampingParameter(t,e,i,s,n,r,o,a){t[0]=s>0?1/s:0,e[0]=n>0?1/n:0,i[0]=ep.CrossVV(ep.SubVV(o,r,ep.s_t0),a)}InitDampingParameterWithRigidGroupOrParticle(t,e,i,s,n,r,o,a){if(n&&s)this.InitDampingParameter(t,e,i,n.GetMass(),n.GetInertia(),n.GetCenter(),o,a);else{const s=this.m_flagsBuffer.data[r];this.InitDampingParameter(t,e,i,s&Bg.b2_wallParticle?0:this.GetParticleMass(),0,o,o,a)}}ComputeDampingImpulse(t,e,i,s,n,r,o){const a=t+e*i*i+s+n*r*r;return a>0?o/a:0}ApplyDamping(t,e,i,s,n,r,o,a){n&&s?(n.m_linearVelocity.SelfMulAdd(o*t,a),n.m_angularVelocity+=o*i*e):this.m_velocityBuffer.data[r].SelfMulAdd(o*t,a)}}$g.xTruncBits=12,$g.yTruncBits=12,$g.tagBits=32,$g.yOffset=1<<$g.yTruncBits-1,$g.yShift=$g.tagBits-$g.yTruncBits,$g.xShift=$g.tagBits-$g.yTruncBits-$g.xTruncBits,$g.xScale=1<<$g.xShift,$g.xOffset=$g.xScale*(1<<$g.xTruncBits-1),$g.yMask=(1<<$g.yTruncBits)-1<<$g.yShift,$g.xMask=~$g.yMask,$g.DestroyParticlesInShape_s_aabb=new Op,$g.CreateParticleGroup_s_transform=new ap,$g.ComputeCollisionEnergy_s_v=new ep,$g.QueryShapeAABB_s_aabb=new Op,$g.QueryPointAABB_s_aabb=new Op,$g.RayCast_s_aabb=new Op,$g.RayCast_s_p=new ep,$g.RayCast_s_v=new ep,$g.RayCast_s_n=new ep,$g.RayCast_s_point=new ep,$g.k_pairFlags=Bg.b2_springParticle,$g.k_triadFlags=Bg.b2_elasticParticle,$g.k_noPressureFlags=Bg.b2_powderParticle|Bg.b2_tensileParticle,$g.k_extraDampingFlags=Bg.b2_staticPressureParticle,$g.k_barrierWallFlags=Bg.b2_barrierParticle|Bg.b2_wallParticle,$g.CreateParticlesStrokeShapeForGroup_s_edge=new Py,$g.CreateParticlesStrokeShapeForGroup_s_d=new ep,$g.CreateParticlesStrokeShapeForGroup_s_p=new ep,$g.CreateParticlesFillShapeForGroup_s_aabb=new Op,$g.CreateParticlesFillShapeForGroup_s_p=new ep,$g.UpdatePairsAndTriads_s_dab=new ep,$g.UpdatePairsAndTriads_s_dbc=new ep,$g.UpdatePairsAndTriads_s_dca=new ep,$g.AddContact_s_d=new ep,$g.UpdateBodyContacts_s_aabb=new Op,$g.Solve_s_subStep=new yg,$g.SolveCollision_s_aabb=new Op,$g.SolveGravity_s_gravity=new ep,$g.SolveBarrier_s_aabb=new Op,$g.SolveBarrier_s_va=new ep,$g.SolveBarrier_s_vb=new ep,$g.SolveBarrier_s_pba=new ep,$g.SolveBarrier_s_vba=new ep,$g.SolveBarrier_s_vc=new ep,$g.SolveBarrier_s_pca=new ep,$g.SolveBarrier_s_vca=new ep,$g.SolveBarrier_s_qba=new ep,$g.SolveBarrier_s_qca=new ep,$g.SolveBarrier_s_dv=new ep,$g.SolveBarrier_s_f=new ep,$g.SolvePressure_s_f=new ep,$g.SolveDamping_s_v=new ep,$g.SolveDamping_s_f=new ep,$g.SolveRigidDamping_s_t0=new ep,$g.SolveRigidDamping_s_t1=new ep,$g.SolveRigidDamping_s_p=new ep,$g.SolveRigidDamping_s_v=new ep,$g.SolveExtraDamping_s_v=new ep,$g.SolveExtraDamping_s_f=new ep,$g.SolveRigid_s_position=new ep,$g.SolveRigid_s_rotation=new op,$g.SolveRigid_s_transform=new ap,$g.SolveRigid_s_velocityTransform=new ap,$g.SolveElastic_s_pa=new ep,$g.SolveElastic_s_pb=new ep,$g.SolveElastic_s_pc=new ep,$g.SolveElastic_s_r=new op,$g.SolveElastic_s_t0=new ep,$g.SolveSpring_s_pa=new ep,$g.SolveSpring_s_pb=new ep,$g.SolveSpring_s_d=new ep,$g.SolveSpring_s_f=new ep,$g.SolveTensile_s_weightedNormal=new ep,$g.SolveTensile_s_s=new ep,$g.SolveTensile_s_f=new ep,$g.SolveViscous_s_v=new ep,$g.SolveViscous_s_f=new ep,$g.SolveRepulsive_s_f=new ep,$g.SolvePowder_s_f=new ep,$g.SolveSolid_s_f=new ep,$g.RemoveSpuriousBodyContacts_s_n=new ep,$g.RemoveSpuriousBodyContacts_s_pos=new ep,$g.RemoveSpuriousBodyContacts_s_normal=new ep;class tx{constructor(){this._data=null,this.userSuppliedCapacity=0}get data(){return this._data}set data(t){this._data=t}}class ex{constructor(){this.index=Ud,this.tag=0}static CompareProxyProxy(t,e){return t.tag<e.tag}static CompareTagProxy(t,e){return t<e.tag}static CompareProxyTag(t,e){return t.tag<e}}class ix{constructor(t,e,i,s,n){this.m_system=t,this.m_xLower=(e&$g.xMask)>>>0,this.m_xUpper=(i&$g.xMask)>>>0,this.m_yLower=(e&$g.yMask)>>>0,this.m_yUpper=(i&$g.yMask)>>>0,this.m_first=s,this.m_last=n}GetNext(){for(;this.m_first<this.m_last;){const t=(this.m_system.m_proxyBuffer.data[this.m_first].tag&$g.xMask)>>>0;if(t>=this.m_xLower&&t<=this.m_xUpper)return this.m_system.m_proxyBuffer.data[this.m_first++].index;this.m_first++}return Ud}}class sx{constructor(){this.next=null,this.count=0,this.index=0}}class nx{Allocate(t,e){return e}Clear(){}GetCount(){return 0}Invalidate(t){}GetValidBuffer(){return[]}GetBuffer(){return[]}SetCount(t){}}class rx extends nx{Initialize(t,e){}Find(t){return Ud}}class ox extends nx{Initialize(t,e){}Find(t){return Ud}}class ax{IsNecessary(t){return!0}ShouldCreatePair(t,e){return!0}ShouldCreateTriad(t,e,i){return!0}}class lx extends dg{constructor(t,e,i,s){super(),this.m_callDestructionListener=!1,this.m_destroyed=0,this.m_system=t,this.m_shape=e,this.m_xf=i,this.m_callDestructionListener=s,this.m_destroyed=0}ReportFixture(t){return!1}ReportParticle(t,e){return t===this.m_system&&(this.m_shape.TestPoint(this.m_xf,this.m_system.m_positionBuffer.data[e])&&(this.m_system.DestroyParticle(e,this.m_callDestructionListener),this.m_destroyed++),!0)}Destroyed(){return this.m_destroyed}}class hx extends ax{constructor(t){super(),this.m_threshold=0,this.m_threshold=t}ShouldCreatePair(t,e){return t<this.m_threshold&&this.m_threshold<=e||e<this.m_threshold&&this.m_threshold<=t}ShouldCreateTriad(t,e,i){return(t<this.m_threshold||e<this.m_threshold||i<this.m_threshold)&&(this.m_threshold<=t||this.m_threshold<=e||this.m_threshold<=i)}}class cx extends My{constructor(t,e=t.length){super(Cy.e_unknown,0),this.m_shapeCount=0,this.m_shapes=t,this.m_shapeCount=e}Clone(){throw new Error}GetChildCount(){return 1}TestPoint(t,e){for(let i=0;i<this.m_shapeCount;i++)if(this.m_shapes[i].TestPoint(t,e))return!0;return!1}ComputeDistance(t,e,i,s){return 0}RayCast(t,e,i,s){return!1}ComputeAABB(t,e,i){const s=new Op;t.lowerBound.x=+Id,t.lowerBound.y=+Id,t.upperBound.x=-Id,t.upperBound.y=-Id;for(let i=0;i<this.m_shapeCount;i++){const n=this.m_shapes[i].GetChildCount();for(let r=0;r<n;r++){const n=s;this.m_shapes[i].ComputeAABB(n,e,r),t.Combine1(n)}}}ComputeMass(t,e){}SetupDistanceProxy(t,e){}ComputeSubmergedArea(t,e,i,s){return 0}Dump(t){}}class mx extends ax{constructor(t){super(),this.m_flagsBuffer=t}IsNecessary(t){return 0!=(this.m_flagsBuffer.data[t]&Bg.b2_reactiveParticle)}}class ux extends Xg{constructor(t,e=null){super(t),this.m_contactFilter=null,this.m_contactFilter=e}ShouldCollideFixtureParticle(t,e,i){return!(this.m_contactFilter&&this.m_system.GetFlagsBuffer()[i]&Bg.b2_fixtureContactFilterParticle)||this.m_contactFilter.ShouldCollideFixtureParticle(t,this.m_system,i)}ReportFixtureAndParticle(t,e,i){const s=ux.ReportFixtureAndParticle_s_n,n=ux.ReportFixtureAndParticle_s_rp,r=this.m_system.m_positionBuffer.data[i],o=s,a=t.ComputeDistance(r,o,e);if(a<this.m_system.m_particleDiameter&&this.ShouldCollideFixtureParticle(t,this.m_system,i)){const e=t.GetBody(),s=e.GetWorldCenter(),l=e.GetMass(),h=e.GetInertia()-l*e.GetLocalCenter().LengthSquared(),c=l>0?1/l:0,m=h>0?1/h:0,u=this.m_system.m_flagsBuffer.data[i]&Bg.b2_wallParticle?0:this.m_system.GetParticleInvMass(),_=ep.SubVV(r,s,n),d=ep.CrossVV(_,o),p=u+c+m*d*d,f=this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];f.index=i,f.body=e,f.fixture=t,f.weight=1-a*this.m_system.m_inverseDiameter,f.normal.Copy(o.SelfNeg()),f.mass=p>0?1/p:0,this.m_system.DetectStuckParticle(i)}}}ux.ReportFixtureAndParticle_s_n=new ep,ux.ReportFixtureAndParticle_s_rp=new ep;class _x extends Xg{constructor(t,e){super(t),this.m_step=e}ReportFixtureAndParticle(t,e,i){const s=_x.ReportFixtureAndParticle_s_p1,n=_x.ReportFixtureAndParticle_s_output,r=_x.ReportFixtureAndParticle_s_input,o=_x.ReportFixtureAndParticle_s_p,a=_x.ReportFixtureAndParticle_s_v,l=_x.ReportFixtureAndParticle_s_f,h=t.GetBody(),c=this.m_system.m_positionBuffer.data[i],m=this.m_system.m_velocityBuffer.data[i],u=n,_=r;if(0===this.m_system.m_iterationIndex){const e=ap.MulTXV(h.m_xf0,c,s);t.GetShape().GetType()===Cy.e_circleShape&&(e.SelfSub(h.GetLocalCenter()),op.MulRV(h.m_xf0.q,e,e),op.MulTRV(h.m_xf.q,e,e),e.SelfAdd(h.GetLocalCenter())),ap.MulXV(h.m_xf,e,_.p1)}else _.p1.Copy(c);if(ep.AddVMulSV(c,this.m_step.dt,m,_.p2),_.maxFraction=1,t.RayCast(u,_,e)){const t=u.normal,e=o;e.x=(1-u.fraction)*_.p1.x+u.fraction*_.p2.x+Gd*t.x,e.y=(1-u.fraction)*_.p1.y+u.fraction*_.p2.y+Gd*t.y;const s=a;s.x=this.m_step.inv_dt*(e.x-c.x),s.y=this.m_step.inv_dt*(e.y-c.y),this.m_system.m_velocityBuffer.data[i].Copy(s);const n=l;n.x=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.x-s.x),n.y=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.y-s.y),this.m_system.ParticleApplyForce(i,n)}}ReportParticle(t,e){return!1}}_x.ReportFixtureAndParticle_s_p1=new ep,_x.ReportFixtureAndParticle_s_output=new zp,_x.ReportFixtureAndParticle_s_input=new kp,_x.ReportFixtureAndParticle_s_p=new ep,_x.ReportFixtureAndParticle_s_v=new ep,_x.ReportFixtureAndParticle_s_f=new ep;class dx{constructor(t){this.m_contactManager=new pg,this.m_bodyList=null,this.m_jointList=null,this.m_particleSystemList=null,this.m_bodyCount=0,this.m_jointCount=0,this.m_gravity=new ep,this.m_allowSleep=!0,this.m_destructionListener=null,this.m_debugDraw=null,this.m_inv_dt0=0,this.m_newContacts=!1,this.m_locked=!1,this.m_clearForces=!0,this.m_warmStarting=!0,this.m_continuousPhysics=!0,this.m_subStepping=!1,this.m_stepComplete=!0,this.m_profile=new fg,this.m_island=new Ag,this.s_stack=[],this.m_controllerList=null,this.m_controllerCount=0,this.m_gravity.Copy(t)}SetDestructionListener(t){this.m_destructionListener=t}SetContactFilter(t){this.m_contactManager.m_contactFilter=t}SetContactListener(t){this.m_contactManager.m_contactListener=t}SetDebugDraw(t){this.m_debugDraw=t}CreateBody(t={}){if(this.IsLocked())throw new Error;const e=new Fy(t,this);return e.m_prev=null,e.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=e),this.m_bodyList=e,++this.m_bodyCount,e}DestroyBody(t){if(this.IsLocked())throw new Error;let e=t.m_jointList;for(;e;){const i=e;e=e.next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeJoint(i.joint),this.DestroyJoint(i.joint),t.m_jointList=e}t.m_jointList=null;let i=t.m_controllerList;for(;i;){const e=i;i=i.nextController,e.controller.RemoveBody(t)}let s=t.m_contactList;for(;s;){const t=s;s=s.next,this.m_contactManager.Destroy(t.contact)}t.m_contactList=null;let n=t.m_fixtureList;for(;n;){const e=n;n=n.m_next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeFixture(e),e.DestroyProxies(),e.Reset(),t.m_fixtureList=n,t.m_fixtureCount-=1}t.m_fixtureList=null,t.m_fixtureCount=0,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_bodyList&&(this.m_bodyList=t.m_next),--this.m_bodyCount}static _Joint_Create(t){switch(t.type){case By.e_distanceJoint:return new Ny(t);case By.e_mouseJoint:return new qy(t);case By.e_prismaticJoint:return new Xy(t);case By.e_revoluteJoint:return new Zy(t);case By.e_pulleyJoint:return new Jy(t);case By.e_gearJoint:return new jy(t);case By.e_wheelJoint:return new Qy(t);case By.e_weldJoint:return new Yy(t);case By.e_frictionJoint:return new Wy(t);case By.e_motorJoint:return new Hy(t);case By.e_areaJoint:return new Uy(t)}throw new Error}static _Joint_Destroy(t){}CreateJoint(t){if(this.IsLocked())throw new Error;const e=dx._Joint_Create(t);e.m_prev=null,e.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=e),this.m_jointList=e,++this.m_jointCount,e.m_edgeA.prev=null,e.m_edgeA.next=e.m_bodyA.m_jointList,e.m_bodyA.m_jointList&&(e.m_bodyA.m_jointList.prev=e.m_edgeA),e.m_bodyA.m_jointList=e.m_edgeA,e.m_edgeB.prev=null,e.m_edgeB.next=e.m_bodyB.m_jointList,e.m_bodyB.m_jointList&&(e.m_bodyB.m_jointList.prev=e.m_edgeB),e.m_bodyB.m_jointList=e.m_edgeB;const i=e.m_bodyA,s=e.m_bodyB;if(!e.m_collideConnected){let t=s.GetContactList();for(;t;)t.other===i&&t.contact.FlagForFiltering(),t=t.next}return e}DestroyJoint(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,i=t.m_bodyB,s=t.m_collideConnected;if(e.SetAwake(!0),i.SetAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA===e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.Reset(),t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB===i.m_jointList&&(i.m_jointList=t.m_edgeB.next),t.m_edgeB.Reset(),dx._Joint_Destroy(t),--this.m_jointCount,!s){let t=i.GetContactList();for(;t;)t.other===e&&t.contact.FlagForFiltering(),t=t.next}}CreateParticleSystem(t){if(this.IsLocked())throw new Error;const e=new $g(t,this);return e.m_prev=null,e.m_next=this.m_particleSystemList,this.m_particleSystemList&&(this.m_particleSystemList.m_prev=e),this.m_particleSystemList=e,e}DestroyParticleSystem(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_particleSystemList&&(this.m_particleSystemList=t.m_next)}CalculateReasonableParticleIterations(t){return null===this.m_particleSystemList?1:function(t,e,i){return Zd(Math.ceil(Math.sqrt(t/(.01*e))*i),1,8)}(this.m_gravity.Length(),function(t){let e=Id;for(let i=t.GetParticleSystemList();null!==i;i=i.m_next)e=Xd(e,i.GetRadius());return e}(this),t)}Step(t,e,i,s=this.CalculateReasonableParticleIterations(t)){const n=dx.Step_s_stepTimer.Reset();this.m_newContacts&&(this.m_contactManager.FindNewContacts(),this.m_newContacts=!1),this.m_locked=!0;const r=dx.Step_s_step;r.dt=t,r.velocityIterations=e,r.positionIterations=i,r.particleIterations=s,r.inv_dt=t>0?1/t:0,r.dtRatio=this.m_inv_dt0*t,r.warmStarting=this.m_warmStarting;const o=dx.Step_s_timer.Reset();if(this.m_contactManager.Collide(),this.m_profile.collide=o.GetMilliseconds(),this.m_stepComplete&&r.dt>0){const t=dx.Step_s_timer.Reset();for(let t=this.m_particleSystemList;t;t=t.m_next)t.Solve(r);this.Solve(r),this.m_profile.solve=t.GetMilliseconds()}if(this.m_continuousPhysics&&r.dt>0){const t=dx.Step_s_timer.Reset();this.SolveTOI(r),this.m_profile.solveTOI=t.GetMilliseconds()}r.dt>0&&(this.m_inv_dt0=r.inv_dt),this.m_clearForces&&this.ClearForces(),this.m_locked=!1,this.m_profile.step=n.GetMilliseconds()}ClearForces(){for(let t=this.m_bodyList;t;t=t.m_next)t.m_force.SetZero(),t.m_torque=0}DrawParticleSystem(t){if(null===this.m_debugDraw)return;const e=t.GetParticleCount();if(e){const i=t.GetRadius(),s=t.GetPositionBuffer();if(t.m_colorBuffer.data){const n=t.GetColorBuffer();this.m_debugDraw.DrawParticles(s,i,n,e)}else this.m_debugDraw.DrawParticles(s,i,null,e)}}DebugDraw(){if(null===this.m_debugDraw)return;const t=this.m_debugDraw.GetFlags(),e=dx.DebugDraw_s_color.SetRGB(0,0,0);if(t&mp.e_shapeBit)for(let t=this.m_bodyList;t;t=t.m_next){const i=t.m_xf;this.m_debugDraw.PushTransform(i);for(let i=t.GetFixtureList();i;i=i.m_next)t.GetType()===Ay.b2_dynamicBody&&0===t.m_mass?this.DrawShape(i,new hp(1,0,0)):t.IsEnabled()?t.GetType()===Ay.b2_staticBody?(e.SetRGB(.5,.9,.5),this.DrawShape(i,e)):t.GetType()===Ay.b2_kinematicBody?(e.SetRGB(.5,.5,.9),this.DrawShape(i,e)):t.IsAwake()?(e.SetRGB(.9,.7,.7),this.DrawShape(i,e)):(e.SetRGB(.6,.6,.6),this.DrawShape(i,e)):(e.SetRGB(.5,.5,.3),this.DrawShape(i,e));this.m_debugDraw.PopTransform(i)}if(t&mp.e_particleBit)for(let t=this.m_particleSystemList;t;t=t.m_next)this.DrawParticleSystem(t);if(t&mp.e_jointBit)for(let t=this.m_jointList;t;t=t.m_next)t.Draw(this.m_debugDraw);if(t&mp.e_pairBit){e.SetRGB(.3,.9,.9);for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){const i=t.GetFixtureA(),s=t.GetFixtureB(),n=t.GetChildIndexA(),r=t.GetChildIndexB(),o=i.GetAABB(n).GetCenter(),a=s.GetAABB(r).GetCenter();this.m_debugDraw.DrawSegment(o,a,e)}}if(t&mp.e_aabbBit){e.SetRGB(.9,.3,.9);const t=dx.DebugDraw_s_vs;for(let i=this.m_bodyList;i;i=i.m_next)if(i.IsEnabled())for(let s=i.GetFixtureList();s;s=s.m_next)for(let i=0;i<s.m_proxyCount;++i){const n=s.m_proxies[i].treeNode.aabb;t[0].Set(n.lowerBound.x,n.lowerBound.y),t[1].Set(n.upperBound.x,n.lowerBound.y),t[2].Set(n.upperBound.x,n.upperBound.y),t[3].Set(n.lowerBound.x,n.upperBound.y),this.m_debugDraw.DrawPolygon(t,4,e)}}if(t&mp.e_centerOfMassBit)for(let t=this.m_bodyList;t;t=t.m_next){const e=dx.DebugDraw_s_xf;e.q.Copy(t.m_xf.q),e.p.Copy(t.GetWorldCenter()),this.m_debugDraw.DrawTransform(e)}if(t&mp.e_controllerBit)for(let t=this.m_controllerList;t;t=t.m_next)t.Draw(this.m_debugDraw)}QueryAABB(...t){t[0]instanceof dg?this._QueryAABB(t[0],t[1]):this._QueryAABB(null,t[0],t[1])}_QueryAABB(t,e,i){if(this.m_contactManager.m_broadPhase.Query(e,(e=>{const s=e.userData.fixture;return t?t.ReportFixture(s):!i||i(s)})),t instanceof dg)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryAABB(t,e)}QueryAllAABB(t,e=[]){return this.QueryAABB(t,(t=>(e.push(t),!0))),e}QueryPointAABB(...t){t[0]instanceof dg?this._QueryPointAABB(t[0],t[1]):this._QueryPointAABB(null,t[0],t[1])}_QueryPointAABB(t,e,i){if(this.m_contactManager.m_broadPhase.QueryPoint(e,(e=>{const s=e.userData.fixture;return t?t.ReportFixture(s):!i||i(s)})),t instanceof dg)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryPointAABB(t,e)}QueryAllPointAABB(t,e=[]){return this.QueryPointAABB(t,(t=>(e.push(t),!0))),e}QueryFixtureShape(...t){t[0]instanceof dg?this._QueryFixtureShape(t[0],t[1],t[2],t[3]):this._QueryFixtureShape(null,t[0],t[1],t[2],t[3])}_QueryFixtureShape(t,e,i,s,n){const r=dx.QueryFixtureShape_s_aabb;if(e.ComputeAABB(r,s,i),this.m_contactManager.m_broadPhase.Query(r,(r=>{const o=r.userData,a=o.fixture;if(qp(e,i,a.GetShape(),o.childIndex,s,a.GetBody().GetTransform())){if(t)return t.ReportFixture(a);if(n)return n(a)}return!0})),t instanceof dg)for(let e=this.m_particleSystemList;e;e=e.m_next)t.ShouldQueryParticleSystem(e)&&e.QueryAABB(t,r)}QueryAllFixtureShape(t,e,i,s=[]){return this.QueryFixtureShape(t,e,i,(t=>(s.push(t),!0))),s}QueryFixturePoint(...t){t[0]instanceof dg?this._QueryFixturePoint(t[0],t[1]):this._QueryFixturePoint(null,t[0],t[1])}_QueryFixturePoint(t,e,i){if(this.m_contactManager.m_broadPhase.QueryPoint(e,(s=>{const n=s.userData.fixture;if(n.TestPoint(e)){if(t)return t.ReportFixture(n);if(i)return i(n)}return!0})),t)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.QueryPointAABB(t,e)}QueryAllFixturePoint(t,e=[]){return this.QueryFixturePoint(t,(t=>(e.push(t),!0))),e}RayCast(...t){t[0]instanceof class{ReportFixture(t,e,i,s){return s}ReportParticle(t,e,i,s,n){return 0}ShouldQueryParticleSystem(t){return!0}}?this._RayCast(t[0],t[1],t[2]):this._RayCast(null,t[0],t[1],t[2])}_RayCast(t,e,i,s){const n=dx.RayCast_s_input;if(n.maxFraction=1,n.p1.Copy(e),n.p2.Copy(i),this.m_contactManager.m_broadPhase.RayCast(n,((n,r)=>{const o=r.userData,a=o.fixture,l=o.childIndex,h=dx.RayCast_s_output;if(a.RayCast(h,n,l)){const n=h.fraction,r=dx.RayCast_s_point;if(r.Set((1-n)*e.x+n*i.x,(1-n)*e.y+n*i.y),t)return t.ReportFixture(a,r,h.normal,n);if(s)return s(a,r,h.normal,n)}return n.maxFraction})),t)for(let s=this.m_particleSystemList;s;s=s.m_next)t.ShouldQueryParticleSystem(s)&&s.RayCast(t,e,i)}RayCastOne(t,e){let i=null,s=1;return this.RayCast(t,e,((t,e,n,r)=>(r<s&&(s=r,i=t),s))),i}RayCastAll(t,e,i=[]){return this.RayCast(t,e,((t,e,s,n)=>(i.push(t),1))),i}GetBodyList(){return this.m_bodyList}GetJointList(){return this.m_jointList}GetParticleSystemList(){return this.m_particleSystemList}GetContactList(){return this.m_contactManager.m_contactList}SetAllowSleeping(t){if(t!==this.m_allowSleep&&(this.m_allowSleep=t,!this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetAllowSleeping(){return this.m_allowSleep}SetWarmStarting(t){this.m_warmStarting=t}GetWarmStarting(){return this.m_warmStarting}SetContinuousPhysics(t){this.m_continuousPhysics=t}GetContinuousPhysics(){return this.m_continuousPhysics}SetSubStepping(t){this.m_subStepping=t}GetSubStepping(){return this.m_subStepping}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount()}GetBodyCount(){return this.m_bodyCount}GetJointCount(){return this.m_jointCount}GetContactCount(){return this.m_contactManager.m_contactCount}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight()}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance()}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality()}SetGravity(t,e=!0){if(!ep.IsEqualToV(this.m_gravity,t)&&(this.m_gravity.Copy(t),e))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetGravity(){return this.m_gravity}IsLocked(){return this.m_locked}SetAutoClearForces(t){this.m_clearForces=t}GetAutoClearForces(){return this.m_clearForces}ShiftOrigin(t){if(this.IsLocked())throw new Error;for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.SelfSub(t),e.m_sweep.c0.SelfSub(t),e.m_sweep.c.SelfSub(t);for(let e=this.m_jointList;e;e=e.m_next)e.ShiftOrigin(t);this.m_contactManager.m_broadPhase.ShiftOrigin(t)}GetContactManager(){return this.m_contactManager}GetProfile(){return this.m_profile}Dump(t){if(this.m_locked)return;t("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n",this.m_gravity.x,this.m_gravity.y),t("this.m_world.SetGravity(g);\n"),t("const bodies: b2Body[] = [];\n"),t("const joints: b2Joint[] = [];\n");let e=0;for(let i=this.m_bodyList;i;i=i.m_next)i.m_islandIndex=e,i.Dump(t),++e;e=0;for(let t=this.m_jointList;t;t=t.m_next)t.m_index=e,++e;for(let e=this.m_jointList;e;e=e.m_next)e.m_type!==By.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"));for(let e=this.m_jointList;e;e=e.m_next)e.m_type===By.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"))}DrawShape(t,e){if(null===this.m_debugDraw)return;const i=t.GetShape();switch(i.m_type){case Cy.e_circleShape:{const t=i,s=t.m_p,n=t.m_radius,r=ep.UNITX;this.m_debugDraw.DrawSolidCircle(s,n,r,e);break}case Cy.e_edgeShape:{const t=i,s=t.m_vertex1,n=t.m_vertex2;this.m_debugDraw.DrawSegment(s,n,e),!1===t.m_oneSided&&(this.m_debugDraw.DrawPoint(s,4,e),this.m_debugDraw.DrawPoint(n,4,e));break}case Cy.e_chainShape:{const t=i,s=t.m_count,n=t.m_vertices;let r=n[0];for(let t=1;t<s;++t){const i=n[t];this.m_debugDraw.DrawSegment(r,i,e),r=i}break}case Cy.e_polygonShape:{const t=i,s=t.m_count,n=t.m_vertices;this.m_debugDraw.DrawSolidPolygon(n,s,e);break}}}Solve(t){for(let t=this.m_bodyList;t;t=t.m_next)t.m_xf0.Copy(t.m_xf);for(let e=this.m_controllerList;e;e=e.m_next)e.Step(t);this.m_profile.solveInit=0,this.m_profile.solveVelocity=0,this.m_profile.solvePosition=0;const e=this.m_island;e.Initialize(this.m_bodyCount,this.m_contactManager.m_contactCount,this.m_jointCount,this.m_contactManager.m_contactListener);for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const i=this.s_stack;for(let s=this.m_bodyList;s;s=s.m_next){if(s.m_islandFlag)continue;if(!s.IsAwake()||!s.IsEnabled())continue;if(s.GetType()===Ay.b2_staticBody)continue;e.Clear();let n=0;for(i[n++]=s,s.m_islandFlag=!0;n>0;){const t=i[--n];if(!t)throw new Error;if(e.AddBody(t),t.GetType()!==Ay.b2_staticBody){t.m_awakeFlag=!0;for(let s=t.m_contactList;s;s=s.next){const t=s.contact;if(t.m_islandFlag)continue;if(!t.IsEnabled()||!t.IsTouching())continue;const r=t.m_fixtureA.m_isSensor,o=t.m_fixtureB.m_isSensor;if(r||o)continue;e.AddContact(t),t.m_islandFlag=!0;const a=s.other;a.m_islandFlag||(i[n++]=a,a.m_islandFlag=!0)}for(let s=t.m_jointList;s;s=s.next){if(s.joint.m_islandFlag)continue;const t=s.other;t.IsEnabled()&&(e.AddJoint(s.joint),s.joint.m_islandFlag=!0,t.m_islandFlag||(i[n++]=t,t.m_islandFlag=!0))}}}const r=new fg;e.Solve(r,t,this.m_gravity,this.m_allowSleep),this.m_profile.solveInit+=r.solveInit,this.m_profile.solveVelocity+=r.solveVelocity,this.m_profile.solvePosition+=r.solvePosition;for(let t=0;t<e.m_bodyCount;++t){const i=e.m_bodies[t];i.GetType()===Ay.b2_staticBody&&(i.m_islandFlag=!1)}}for(let t=0;t<i.length&&i[t];++t)i[t]=null;const s=new Kp;for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag&&t.GetType()!==Ay.b2_staticBody&&t.SynchronizeFixtures();this.m_contactManager.FindNewContacts(),this.m_profile.broadphase=s.GetMilliseconds()}SolveTOI(t){const e=this.m_island;if(e.Initialize(64,32,0,this.m_contactManager.m_contactListener),this.m_stepComplete){for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let i=null,s=1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){if(!t.IsEnabled())continue;if(t.m_toiCount>8)continue;let e=1;if(t.m_toiFlag)e=t.m_toi;else{const i=t.GetFixtureA(),s=t.GetFixtureB();if(i.IsSensor()||s.IsSensor())continue;const n=i.GetBody(),r=s.GetBody(),o=n.m_type,a=r.m_type,l=n.IsAwake()&&o!==Ay.b2_staticBody,h=r.IsAwake()&&a!==Ay.b2_staticBody;if(!l&&!h)continue;const c=n.IsBullet()||o!==Ay.b2_dynamicBody,m=r.IsBullet()||a!==Ay.b2_dynamicBody;if(!c&&!m)continue;let u=n.m_sweep.alpha0;n.m_sweep.alpha0<r.m_sweep.alpha0?(u=r.m_sweep.alpha0,n.m_sweep.Advance(u)):r.m_sweep.alpha0<n.m_sweep.alpha0&&(u=n.m_sweep.alpha0,r.m_sweep.Advance(u));const _=t.GetChildIndexA(),d=t.GetChildIndexB(),p=dx.SolveTOI_s_toi_input;p.proxyA.SetShape(i.GetShape(),_),p.proxyB.SetShape(s.GetShape(),d),p.sweepA.Copy(n.m_sweep),p.sweepB.Copy(r.m_sweep),p.tMax=1;const f=dx.SolveTOI_s_toi_output;Cf(f,p);const y=f.t;e=f.state===uf.e_touching?Xd(u+(1-u)*y,1):1,t.m_toi=e,t.m_toiFlag=!0}e<s&&(i=t,s=e)}if(null===i||.9999<s){this.m_stepComplete=!0;break}const n=i.GetFixtureA(),r=i.GetFixtureB(),o=n.GetBody(),a=r.GetBody(),l=dx.SolveTOI_s_backup1.Copy(o.m_sweep),h=dx.SolveTOI_s_backup2.Copy(a.m_sweep);if(o.Advance(s),a.Advance(s),i.Update(this.m_contactManager.m_contactListener),i.m_toiFlag=!1,++i.m_toiCount,!i.IsEnabled()||!i.IsTouching()){i.SetEnabled(!1),o.m_sweep.Copy(l),a.m_sweep.Copy(h),o.SynchronizeTransform(),a.SynchronizeTransform();continue}o.SetAwake(!0),a.SetAwake(!0),e.Clear(),e.AddBody(o),e.AddBody(a),e.AddContact(i),o.m_islandFlag=!0,a.m_islandFlag=!0,i.m_islandFlag=!0;for(let t=0;t<2;++t){const i=0===t?o:a;if(i.m_type===Ay.b2_dynamicBody)for(let t=i.m_contactList;t&&e.m_bodyCount!==e.m_bodyCapacity&&e.m_contactCount!==e.m_contactCapacity;t=t.next){const n=t.contact;if(n.m_islandFlag)continue;const r=t.other;if(r.m_type===Ay.b2_dynamicBody&&!i.IsBullet()&&!r.IsBullet())continue;const o=n.m_fixtureA.m_isSensor,a=n.m_fixtureB.m_isSensor;if(o||a)continue;const l=dx.SolveTOI_s_backup.Copy(r.m_sweep);r.m_islandFlag||r.Advance(s),n.Update(this.m_contactManager.m_contactListener),n.IsEnabled()&&n.IsTouching()?(n.m_islandFlag=!0,e.AddContact(n),r.m_islandFlag||(r.m_islandFlag=!0,r.m_type!==Ay.b2_staticBody&&r.SetAwake(!0),e.AddBody(r))):(r.m_sweep.Copy(l),r.SynchronizeTransform())}}const c=dx.SolveTOI_s_subStep;c.dt=(1-s)*t.dt,c.inv_dt=1/c.dt,c.dtRatio=1,c.positionIterations=20,c.velocityIterations=t.velocityIterations,c.particleIterations=t.particleIterations,c.warmStarting=!1,e.SolveTOI(c,o.m_islandIndex,a.m_islandIndex);for(let t=0;t<e.m_bodyCount;++t){const i=e.m_bodies[t];if(i.m_islandFlag=!1,i.m_type===Ay.b2_dynamicBody){i.SynchronizeFixtures();for(let t=i.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(this.m_contactManager.FindNewContacts(),this.m_subStepping){this.m_stepComplete=!1;break}}}AddController(t){return t.m_next=this.m_controllerList,t.m_prev=null,this.m_controllerList&&(this.m_controllerList.m_prev=t),this.m_controllerList=t,++this.m_controllerCount,t}RemoveController(t){return t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),this.m_controllerList===t&&(this.m_controllerList=t.m_next),--this.m_controllerCount,t.m_prev=null,t.m_next=null,t}}dx.Step_s_step=new yg,dx.Step_s_stepTimer=new Kp,dx.Step_s_timer=new Kp,dx.DebugDraw_s_color=new hp(0,0,0),dx.DebugDraw_s_vs=ep.MakeArray(4),dx.DebugDraw_s_xf=new ap,dx.QueryFixtureShape_s_aabb=new Op,dx.RayCast_s_input=new kp,dx.RayCast_s_output=new zp,dx.RayCast_s_point=new ep,dx.SolveTOI_s_subStep=new yg,dx.SolveTOI_s_backup=new lp,dx.SolveTOI_s_backup1=new lp,dx.SolveTOI_s_backup2=new lp,dx.SolveTOI_s_toi_input=new mf,dx.SolveTOI_s_toi_output=new df;class px{constructor(t,e){this.prevBody=null,this.nextBody=null,this.prevController=null,this.nextController=null,this.controller=t,this.body=e}}class fx{constructor(){this.m_bodyList=null,this.m_bodyCount=0,this.m_prev=null,this.m_next=null}GetNext(){return this.m_next}GetPrev(){return this.m_prev}GetBodyList(){return this.m_bodyList}AddBody(t){const e=new px(this,t);e.nextBody=this.m_bodyList,e.prevBody=null,this.m_bodyList&&(this.m_bodyList.prevBody=e),this.m_bodyList=e,++this.m_bodyCount,e.nextController=t.m_controllerList,e.prevController=null,t.m_controllerList&&(t.m_controllerList.prevController=e),t.m_controllerList=e,++t.m_controllerCount}RemoveBody(t){if(this.m_bodyCount<=0)throw new Error;let e=this.m_bodyList;for(;e&&e.body!==t;)e=e.nextBody;if(null===e)throw new Error;e.prevBody&&(e.prevBody.nextBody=e.nextBody),e.nextBody&&(e.nextBody.prevBody=e.prevBody),this.m_bodyList===e&&(this.m_bodyList=e.nextBody),--this.m_bodyCount,e.nextController&&(e.nextController.prevController=e.prevController),e.prevController&&(e.prevController.nextController=e.nextController),t.m_controllerList===e&&(t.m_controllerList=e.nextController),--t.m_controllerCount}Clear(){for(;this.m_bodyList;)this.RemoveBody(this.m_bodyList.body);this.m_bodyCount=0}}class yx extends fx{constructor(){super(...arguments),this.A=new ep(0,0)}Step(t){const e=ep.MulSV(t.dt,this.A,yx.Step_s_dtA);for(let t=this.m_bodyList;t;t=t.nextBody){const i=t.body;i.IsAwake()&&i.SetLinearVelocity(ep.AddVV(i.GetLinearVelocity(),e,ep.s_t0))}}Draw(t){}}yx.Step_s_dtA=new ep;class gx extends fx{constructor(){super(...arguments),this.G=1,this.invSqr=!0}Step(t){if(this.invSqr)for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,i=e.GetWorldCenter(),s=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,r=t.GetWorldCenter(),o=t.GetMass(),a=r.x-i.x,l=r.y-i.y,h=a*a+l*l;if(h<Ed)continue;const c=gx.Step_s_f.Set(a,l);c.SelfMul(this.G/h/Kd(h)*s*o),e.IsAwake()&&e.ApplyForce(c,i),t.IsAwake()&&t.ApplyForce(c.SelfMul(-1),r)}}else for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,i=e.GetWorldCenter(),s=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,r=t.GetWorldCenter(),o=t.GetMass(),a=r.x-i.x,l=r.y-i.y,h=a*a+l*l;if(h<Ed)continue;const c=gx.Step_s_f.Set(a,l);c.SelfMul(this.G/h*s*o),e.IsAwake()&&e.ApplyForce(c,i),t.IsAwake()&&t.ApplyForce(c.SelfMul(-1),r)}}}Draw(t){}}gx.Step_s_f=new ep;class xx extends fx{constructor(){super(...arguments),this.T=new np,this.maxTimestep=0}Step(t){let e=t.dt;if(!(e<=Ed)){e>this.maxTimestep&&this.maxTimestep>0&&(e=this.maxTimestep);for(let t=this.m_bodyList;t;t=t.nextBody){const i=t.body;if(!i.IsAwake())continue;const s=i.GetWorldVector(np.MulMV(this.T,i.GetLocalVector(i.GetLinearVelocity(),ep.s_t0),ep.s_t1),xx.Step_s_damping);i.SetLinearVelocity(ep.AddVV(i.GetLinearVelocity(),ep.MulSV(e,s,ep.s_t0),ep.s_t1))}}}Draw(t){}SetAxisAligned(t,e){this.T.ex.x=-t,this.T.ex.y=0,this.T.ey.x=0,this.T.ey.y=-e,this.maxTimestep=t>0||e>0?1/Jd(t,e):0}}xx.Step_s_damping=new ep,function(t){t[t.b2_pbdStretchingModel=0]="b2_pbdStretchingModel",t[t.b2_xpbdStretchingModel=1]="b2_xpbdStretchingModel"}(Vg||(Vg={})),function(t){t[t.b2_springAngleBendingModel=0]="b2_springAngleBendingModel",t[t.b2_pbdAngleBendingModel=1]="b2_pbdAngleBendingModel",t[t.b2_xpbdAngleBendingModel=2]="b2_xpbdAngleBendingModel",t[t.b2_pbdDistanceBendingModel=3]="b2_pbdDistanceBendingModel",t[t.b2_pbdHeightBendingModel=4]="b2_pbdHeightBendingModel",t[t.b2_pbdTriangleBendingModel=5]="b2_pbdTriangleBendingModel"}(Tg||(Tg={})),Ay.b2_staticBody,Ay.b2_kinematicBody,Ay.b2_dynamicBody,Tg.b2_springAngleBendingModel,Tg.b2_pbdAngleBendingModel,Tg.b2_xpbdAngleBendingModel,Tg.b2_pbdDistanceBendingModel,Tg.b2_pbdHeightBendingModel,Tg.b2_pbdTriangleBendingModel,Vg.b2_pbdStretchingModel,Vg.b2_xpbdStretchingModel;class vx extends Nl{constructor(){super(...arguments),this._world=null}awake(){this._world=new dx(new ep(0,-9.81))}update(){this._world.Step(this.engine.time.deltaTime,vx._velocityIterations,vx._positionIterations)}addRigidBody(t){return this._world.CreateBody(t)}}vx.unitScalar=.1,vx._velocityIterations=8,vx._positionIterations=3;class Sx extends Nl{constructor(){super(...arguments),this.disallowMultipleComponent=!0,this._physicsProcessor=null,this._bodyType=Ay.b2_dynamicBody,this._body=null}awake(){const t=new Gy;t.allowSleep=!0,t.userData=this,t.type=this._bodyType,t.position.Set(this.transform.position.x*vx.unitScalar,this.transform.position.y*vx.unitScalar),t.angle=this.transform.eulerAngles.z,this._body=this._physicsProcessor.addRigidBody(t);const e=this.gameObject.getComponents(wx).map((t=>t.createFixtureDef()));for(const t of e)this._body.CreateFixture(t)}update(){this.updateTransformFromPhysics()}updateTransformFromPhysics(){this.transform.position.x=this._body.GetPosition().x/vx.unitScalar,this.transform.position.y=this._body.GetPosition().y/vx.unitScalar,this.transform.eulerAngles.z=this._body.GetAngle()}set physicsProcessor(t){this._physicsProcessor=t}set bodyType(t){this._bodyType=t}}class wx extends Nl{constructor(){super(...arguments),this.requiredComponents=[Sx],this._fixtureDef=new Ey,this._offset=new Z,this._boxScale=new Z,this._mass=1}createFixtureDef(){this._fixtureDef.density=this._mass,this._fixtureDef.friction=.5,this._fixtureDef.restitution=.5;const t=new Ty;return t.SetAsBox(this._boxScale.x/2*vx.unitScalar,this._boxScale.y/2*vx.unitScalar,this._offset),this._fixtureDef.shape=t,this._fixtureDef}awake(){this.gameObject.addChildFromBuilder(this.engine.instantiater.buildGameObject("debug_box",new pt(this._offset.x,this._offset.y,200)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.border="1px solid yellow",e.style.backgroundColor="rgba(0, 0, 0, 0)",t.setElement(e),t.elementHeight=this._boxScale.y,t.elementWidth=this._boxScale.x})))}set offset(t){this._offset.set(t.x,t.y)}set boxScale(t){this._boxScale.set(t.x,t.y)}set mass(t){this._mass=t}}class bx extends Nl{constructor(){super(...arguments),this._physicsProcessor=null,this.onKeyDown=t=>{" "===t.key&&this.engine.scene.addChildFromBuilder(this.engine.instantiater.buildGameObject("cube",new pt(this.transform.position.x,this.transform.position.y,0)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundColor="red",e.innerText="css is awesome",e.style.fontSize="5px",t.setElement(e),t.elementWidth=10,t.elementHeight=10})).withComponent(Sx,(t=>{t.physicsProcessor=this._physicsProcessor,t.bodyType=Ay.b2_dynamicBody})).withComponent(wx,(t=>{t.boxScale=new Z(10,10)})))}}onEnable(){this.engine.input.addOnKeyDownEventListener(this.onKeyDown)}onDisable(){this.engine.input.removeOnKeyDownEventListener(this.onKeyDown)}set physicsProcessor(t){this._physicsProcessor=t}}class Cx extends class{constructor(t,e){this._engineGlobalObject=t,this._interopObject=e||null,this._sceneBuilder=new Rl(this._engineGlobalObject.sceneProcessor)}get engine(){return this._engineGlobalObject}get interopObject(){return this._interopObject}get sceneBuilder(){return this._sceneBuilder}}{run(){const t=this.engine.instantiater,e=new Ul,i=new Ul;return this.sceneBuilder.withChild(t.buildGameObject("physics_manager").withComponent(vx).getComponent(vx,i)).withChild(t.buildGameObject("floor",new pt(0,-60,0)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundColor="black",t.setElement(e),t.elementWidth=180,t.elementHeight=5})).withComponent(Sx,(t=>{t.physicsProcessor=i.ref,t.bodyType=Ay.b2_staticBody})).withComponent(wx,(t=>{t.boxScale=new Z(180,5)}))).withChild(t.buildGameObject("floor2",new pt(130,20,0),(new dt).setFromAxisAngle(new pt(0,0,1),Math.PI/3)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundColor="black",t.setElement(e),t.elementWidth=180,t.elementHeight=5})).withComponent(Sx,(t=>{t.physicsProcessor=i.ref,t.bodyType=Ay.b2_staticBody})).withComponent(wx,(t=>{t.boxScale=new Z(180,5)}))).withChild(t.buildGameObject("floor3",new pt(-130,20,0),(new dt).setFromAxisAngle(new pt(0,0,1),-Math.PI/3)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundColor="black",t.setElement(e),t.elementWidth=180,t.elementHeight=5})).withComponent(Sx,(t=>{t.physicsProcessor=i.ref,t.bodyType=Ay.b2_staticBody})).withComponent(wx,(t=>{t.boxScale=new Z(180,5)}))).withChild(t.buildGameObject("cube",new pt(0,10,0)).withComponent(Vd,(t=>{const e=document.createElement("div");e.style.backgroundColor="red",t.setElement(e),t.elementWidth=10,t.elementHeight=10})).withComponent(Sx,(t=>{t.physicsProcessor=i.ref,t.bodyType=Ay.b2_dynamicBody})).withComponent(wx,(t=>{t.boxScale=new Z(10,10)}))).withChild(t.buildGameObject("cursor").withComponent(yd).withComponent(Bd).withComponent(bx,(t=>{t.physicsProcessor=i.ref})).getGameObject(e)).withChild(t.buildGameObject("camera",new pt(0,0,100)).withComponent(Cd,(t=>{t.viewSize=200})).withComponent(Md,(t=>{t.setTrackTarget(e.ref)})).withComponent(Td,(t=>{t.renderHeight=500,t.renderWidth=500})))}}var Ax=i(651);md.defaultSpriteSrc=Ax,function(t){const e=new cd(t,{render:{useCss3DRenderer:!0},physics:{usePhysics2D:!1}});e.run(Cx),e.inputHandler.startHandleEvents()}(document.getElementById("game_view"))})()})();